// node_modules/vis-timeline/standalone/esm/vis-timeline-graph2d.mjs
function styleInject(css2, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;
  if (!css2 || typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css2;
  } else {
    style.appendChild(document.createTextNode(css2));
  }
}
var css_248z$e = ".vis .overlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n\n  /* Must be displayed above for example selected Timeline items */\n  z-index: 10;\n}\n\n.vis-active {\n  box-shadow: 0 0 10px #86d5f8;\n}\n";
styleInject(css_248z$e);
var css_248z$d = '/* override some bootstrap styles screwing up the timelines css */\n\n.vis [class*="span"] {\n  min-height: 0;\n  width: auto;\n}\n';
styleInject(css_248z$d);
var css_248z$c = `div.vis-configuration {
  position: relative;
  display: block;
  float: left;
  font-size: 12px;
}

div.vis-configuration-wrapper {
  display: block;
  width: 700px;
}

div.vis-configuration-wrapper::after {
  clear: both;
  content: "";
  display: block;
}

div.vis-configuration.vis-config-option-container {
  display: block;
  width: 495px;
  background-color: #ffffff;
  border: 2px solid #f7f8fa;
  border-radius: 4px;
  margin-top: 20px;
  left: 10px;
  padding-left: 5px;
}

div.vis-configuration.vis-config-button {
  display: block;
  width: 495px;
  height: 25px;
  vertical-align: middle;
  line-height: 25px;
  background-color: #f7f8fa;
  border: 2px solid #ceced0;
  border-radius: 4px;
  margin-top: 20px;
  left: 10px;
  padding-left: 5px;
  cursor: pointer;
  margin-bottom: 30px;
}

div.vis-configuration.vis-config-button.hover {
  background-color: #4588e6;
  border: 2px solid #214373;
  color: #ffffff;
}

div.vis-configuration.vis-config-item {
  display: block;
  float: left;
  width: 495px;
  height: 25px;
  vertical-align: middle;
  line-height: 25px;
}

div.vis-configuration.vis-config-item.vis-config-s2 {
  left: 10px;
  background-color: #f7f8fa;
  padding-left: 5px;
  border-radius: 3px;
}
div.vis-configuration.vis-config-item.vis-config-s3 {
  left: 20px;
  background-color: #e4e9f0;
  padding-left: 5px;
  border-radius: 3px;
}
div.vis-configuration.vis-config-item.vis-config-s4 {
  left: 30px;
  background-color: #cfd8e6;
  padding-left: 5px;
  border-radius: 3px;
}

div.vis-configuration.vis-config-header {
  font-size: 18px;
  font-weight: bold;
}

div.vis-configuration.vis-config-label {
  width: 120px;
  height: 25px;
  line-height: 25px;
}

div.vis-configuration.vis-config-label.vis-config-s3 {
  width: 110px;
}
div.vis-configuration.vis-config-label.vis-config-s4 {
  width: 100px;
}

div.vis-configuration.vis-config-colorBlock {
  top: 1px;
  width: 30px;
  height: 19px;
  border: 1px solid #444444;
  border-radius: 2px;
  padding: 0px;
  margin: 0px;
  cursor: pointer;
}

input.vis-configuration.vis-config-checkbox {
  left: -5px;
}

input.vis-configuration.vis-config-rangeinput {
  position: relative;
  top: -5px;
  width: 60px;
  /*height:13px;*/
  padding: 1px;
  margin: 0;
  pointer-events: none;
}

input.vis-configuration.vis-config-range {
  /*removes default webkit styles*/
  -webkit-appearance: none;

  /*fix for FF unable to apply focus style bug */
  border: 0px solid white;
  background-color: rgba(0, 0, 0, 0);

  /*required for proper track sizing in FF*/
  width: 300px;
  height: 20px;
}
input.vis-configuration.vis-config-range::-webkit-slider-runnable-track {
  width: 300px;
  height: 5px;
  background: #dedede; /* Old browsers */
  background: -moz-linear-gradient(top, #dedede 0%, #c8c8c8 99%); /* FF3.6+ */
  background: -webkit-gradient(
    linear,
    left top,
    left bottom,
    color-stop(0%, #dedede),
    color-stop(99%, #c8c8c8)
  ); /* Chrome,Safari4+ */
  background: -webkit-linear-gradient(
    top,
    #dedede 0%,
    #c8c8c8 99%
  ); /* Chrome10+,Safari5.1+ */
  background: -o-linear-gradient(
    top,
    #dedede 0%,
    #c8c8c8 99%
  ); /* Opera 11.10+ */
  background: -ms-linear-gradient(top, #dedede 0%, #c8c8c8 99%); /* IE10+ */
  background: linear-gradient(to bottom, #dedede 0%, #c8c8c8 99%); /* W3C */
  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#dedede', endColorstr='#c8c8c8',GradientType=0 ); /* IE6-9 */

  border: 1px solid #999999;
  box-shadow: #aaaaaa 0px 0px 3px 0px;
  border-radius: 3px;
}
input.vis-configuration.vis-config-range::-webkit-slider-thumb {
  -webkit-appearance: none;
  border: 1px solid #14334b;
  height: 17px;
  width: 17px;
  border-radius: 50%;
  background: #3876c2; /* Old browsers */
  background: -moz-linear-gradient(top, #3876c2 0%, #385380 100%); /* FF3.6+ */
  background: -webkit-gradient(
    linear,
    left top,
    left bottom,
    color-stop(0%, #3876c2),
    color-stop(100%, #385380)
  ); /* Chrome,Safari4+ */
  background: -webkit-linear-gradient(
    top,
    #3876c2 0%,
    #385380 100%
  ); /* Chrome10+,Safari5.1+ */
  background: -o-linear-gradient(
    top,
    #3876c2 0%,
    #385380 100%
  ); /* Opera 11.10+ */
  background: -ms-linear-gradient(top, #3876c2 0%, #385380 100%); /* IE10+ */
  background: linear-gradient(to bottom, #3876c2 0%, #385380 100%); /* W3C */
  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#3876c2', endColorstr='#385380',GradientType=0 ); /* IE6-9 */
  box-shadow: #111927 0px 0px 1px 0px;
  margin-top: -7px;
}
input.vis-configuration.vis-config-range:focus {
  outline: none;
}
input.vis-configuration.vis-config-range:focus::-webkit-slider-runnable-track {
  background: #9d9d9d; /* Old browsers */
  background: -moz-linear-gradient(top, #9d9d9d 0%, #c8c8c8 99%); /* FF3.6+ */
  background: -webkit-gradient(
    linear,
    left top,
    left bottom,
    color-stop(0%, #9d9d9d),
    color-stop(99%, #c8c8c8)
  ); /* Chrome,Safari4+ */
  background: -webkit-linear-gradient(
    top,
    #9d9d9d 0%,
    #c8c8c8 99%
  ); /* Chrome10+,Safari5.1+ */
  background: -o-linear-gradient(
    top,
    #9d9d9d 0%,
    #c8c8c8 99%
  ); /* Opera 11.10+ */
  background: -ms-linear-gradient(top, #9d9d9d 0%, #c8c8c8 99%); /* IE10+ */
  background: linear-gradient(to bottom, #9d9d9d 0%, #c8c8c8 99%); /* W3C */
  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#9d9d9d', endColorstr='#c8c8c8',GradientType=0 ); /* IE6-9 */
}

input.vis-configuration.vis-config-range::-moz-range-track {
  width: 300px;
  height: 10px;
  background: #dedede; /* Old browsers */
  background: -moz-linear-gradient(top, #dedede 0%, #c8c8c8 99%); /* FF3.6+ */
  background: -webkit-gradient(
    linear,
    left top,
    left bottom,
    color-stop(0%, #dedede),
    color-stop(99%, #c8c8c8)
  ); /* Chrome,Safari4+ */
  background: -webkit-linear-gradient(
    top,
    #dedede 0%,
    #c8c8c8 99%
  ); /* Chrome10+,Safari5.1+ */
  background: -o-linear-gradient(
    top,
    #dedede 0%,
    #c8c8c8 99%
  ); /* Opera 11.10+ */
  background: -ms-linear-gradient(top, #dedede 0%, #c8c8c8 99%); /* IE10+ */
  background: linear-gradient(to bottom, #dedede 0%, #c8c8c8 99%); /* W3C */
  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#dedede', endColorstr='#c8c8c8',GradientType=0 ); /* IE6-9 */

  border: 1px solid #999999;
  box-shadow: #aaaaaa 0px 0px 3px 0px;
  border-radius: 3px;
}
input.vis-configuration.vis-config-range::-moz-range-thumb {
  border: none;
  height: 16px;
  width: 16px;

  border-radius: 50%;
  background: #385380;
}

/*hide the outline behind the border*/
input.vis-configuration.vis-config-range:-moz-focusring {
  outline: 1px solid white;
  outline-offset: -1px;
}

input.vis-configuration.vis-config-range::-ms-track {
  width: 300px;
  height: 5px;

  /*remove bg colour from the track, we'll use ms-fill-lower and ms-fill-upper instead */
  background: transparent;

  /*leave room for the larger thumb to overflow with a transparent border */
  border-color: transparent;
  border-width: 6px 0;

  /*remove default tick marks*/
  color: transparent;
}
input.vis-configuration.vis-config-range::-ms-fill-lower {
  background: #777;
  border-radius: 10px;
}
input.vis-configuration.vis-config-range::-ms-fill-upper {
  background: #ddd;
  border-radius: 10px;
}
input.vis-configuration.vis-config-range::-ms-thumb {
  border: none;
  height: 16px;
  width: 16px;
  border-radius: 50%;
  background: #385380;
}
input.vis-configuration.vis-config-range:focus::-ms-fill-lower {
  background: #888;
}
input.vis-configuration.vis-config-range:focus::-ms-fill-upper {
  background: #ccc;
}

.vis-configuration-popup {
  position: absolute;
  background: rgba(57, 76, 89, 0.85);
  border: 2px solid #f2faff;
  line-height: 30px;
  height: 30px;
  width: 150px;
  text-align: center;
  color: #ffffff;
  font-size: 14px;
  border-radius: 4px;
  -webkit-transition: opacity 0.3s ease-in-out;
  -moz-transition: opacity 0.3s ease-in-out;
  transition: opacity 0.3s ease-in-out;
}
.vis-configuration-popup:after,
.vis-configuration-popup:before {
  left: 100%;
  top: 50%;
  border: solid transparent;
  content: " ";
  height: 0;
  width: 0;
  position: absolute;
  pointer-events: none;
}

.vis-configuration-popup:after {
  border-color: rgba(136, 183, 213, 0);
  border-left-color: rgba(57, 76, 89, 0.85);
  border-width: 8px;
  margin-top: -8px;
}
.vis-configuration-popup:before {
  border-color: rgba(194, 225, 245, 0);
  border-left-color: #f2faff;
  border-width: 12px;
  margin-top: -12px;
}
`;
styleInject(css_248z$c);
var css_248z$b = "div.vis-tooltip {\n  position: absolute;\n  visibility: hidden;\n  padding: 5px;\n  white-space: nowrap;\n\n  font-family: verdana;\n  font-size: 14px;\n  color: #000000;\n  background-color: #f5f4ed;\n\n  -moz-border-radius: 3px;\n  -webkit-border-radius: 3px;\n  border-radius: 3px;\n  border: 1px solid #808074;\n\n  box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);\n  pointer-events: none;\n\n  z-index: 5;\n}\n";
styleInject(css_248z$b);
var css_248z$a = ".vis-timeline {\n  /*\n  -webkit-transition: height .4s ease-in-out;\n  transition:         height .4s ease-in-out;\n  */\n}\n\n.vis-panel {\n  /*\n  -webkit-transition: height .4s ease-in-out, top .4s ease-in-out;\n  transition:         height .4s ease-in-out, top .4s ease-in-out;\n  */\n}\n\n.vis-axis {\n  /*\n  -webkit-transition: top .4s ease-in-out;\n  transition:         top .4s ease-in-out;\n  */\n}\n\n/* TODO: get animation working nicely\n\n.vis-item {\n  -webkit-transition: top .4s ease-in-out;\n  transition:         top .4s ease-in-out;\n}\n\n.vis-item.line {\n  -webkit-transition: height .4s ease-in-out, top .4s ease-in-out;\n  transition:         height .4s ease-in-out, top .4s ease-in-out;\n}\n/**/\n";
styleInject(css_248z$a);
var css_248z$9 = '.vis-current-time {\n  background-color: #ff7f6e;\n  width: 2px;\n  z-index: 1;\n  pointer-events: none;\n}\n\n.vis-rolling-mode-btn {\n  height: 40px;\n  width: 40px;\n  position: absolute;\n  top: 7px;\n  right: 20px;\n  border-radius: 50%;\n  font-size: 28px;\n  cursor: pointer;\n  opacity: 0.8;\n  color: white;\n  font-weight: bold;\n  text-align: center;\n  background: #3876c2;\n}\n.vis-rolling-mode-btn:before {\n  content: "\\26F6";\n}\n\n.vis-rolling-mode-btn:hover {\n  opacity: 1;\n}\n';
styleInject(css_248z$9);
var css_248z$8 = ".vis-custom-time {\n  background-color: #6e94ff;\n  width: 2px;\n  cursor: move;\n  z-index: 1;\n}\n\n.vis-custom-time > .vis-custom-time-marker {\n  background-color: inherit;\n  color: white;\n  font-size: 12px;\n  white-space: nowrap;\n  padding: 3px 5px;\n  top: 0px;\n  cursor: initial;\n  z-index: inherit;\n}\n";
styleInject(css_248z$8);
var css_248z$7 = ".vis-panel.vis-background.vis-horizontal .vis-grid.vis-horizontal {\n  position: absolute;\n  width: 100%;\n  height: 0;\n  border-bottom: 1px solid;\n}\n\n.vis-panel.vis-background.vis-horizontal .vis-grid.vis-minor {\n  border-color: #e5e5e5;\n}\n\n.vis-panel.vis-background.vis-horizontal .vis-grid.vis-major {\n  border-color: #bfbfbf;\n}\n\n.vis-data-axis .vis-y-axis.vis-major {\n  width: 100%;\n  position: absolute;\n  color: #4d4d4d;\n  white-space: nowrap;\n}\n\n.vis-data-axis .vis-y-axis.vis-major.vis-measure {\n  padding: 0;\n  margin: 0;\n  border: 0;\n  visibility: hidden;\n  width: auto;\n}\n\n.vis-data-axis .vis-y-axis.vis-minor {\n  position: absolute;\n  width: 100%;\n  color: #bebebe;\n  white-space: nowrap;\n}\n\n.vis-data-axis .vis-y-axis.vis-minor.vis-measure {\n  padding: 0;\n  margin: 0;\n  border: 0;\n  visibility: hidden;\n  width: auto;\n}\n\n.vis-data-axis .vis-y-axis.vis-title {\n  position: absolute;\n  color: #4d4d4d;\n  white-space: nowrap;\n  bottom: 20px;\n  text-align: center;\n}\n\n.vis-data-axis .vis-y-axis.vis-title.vis-measure {\n  padding: 0;\n  margin: 0;\n  visibility: hidden;\n  width: auto;\n}\n\n.vis-data-axis .vis-y-axis.vis-title.vis-left {\n  bottom: 0;\n  -webkit-transform-origin: left top;\n  -moz-transform-origin: left top;\n  -ms-transform-origin: left top;\n  -o-transform-origin: left top;\n  transform-origin: left bottom;\n  -webkit-transform: rotate(-90deg);\n  -moz-transform: rotate(-90deg);\n  -ms-transform: rotate(-90deg);\n  -o-transform: rotate(-90deg);\n  transform: rotate(-90deg);\n}\n\n.vis-data-axis .vis-y-axis.vis-title.vis-right {\n  bottom: 0;\n  -webkit-transform-origin: right bottom;\n  -moz-transform-origin: right bottom;\n  -ms-transform-origin: right bottom;\n  -o-transform-origin: right bottom;\n  transform-origin: right bottom;\n  -webkit-transform: rotate(90deg);\n  -moz-transform: rotate(90deg);\n  -ms-transform: rotate(90deg);\n  -o-transform: rotate(90deg);\n  transform: rotate(90deg);\n}\n\n.vis-legend {\n  background-color: rgba(247, 252, 255, 0.65);\n  padding: 5px;\n  border: 1px solid #b3b3b3;\n  box-shadow: 2px 2px 10px rgba(154, 154, 154, 0.55);\n}\n\n.vis-legend-text {\n  /*font-size: 10px;*/\n  white-space: nowrap;\n  display: inline-block;\n}\n";
styleInject(css_248z$7);
var css_248z$6 = '.vis-item {\n  position: absolute;\n  color: #1a1a1a;\n  border-color: #97b0f8;\n  border-width: 1px;\n  background-color: #d5ddf6;\n  display: inline-block;\n  z-index: 1;\n  /*overflow: hidden;*/\n}\n\n.vis-item.vis-selected {\n  border-color: #ffc200;\n  background-color: #fff785;\n\n  /* z-index must be higher than the z-index of custom time bar and current time bar */\n  z-index: 2;\n}\n\n.vis-editable.vis-selected {\n  cursor: move;\n}\n\n.vis-item.vis-point.vis-selected {\n  background-color: #fff785;\n}\n\n.vis-item.vis-box {\n  text-align: center;\n  border-style: solid;\n  border-radius: 2px;\n}\n\n.vis-item.vis-point {\n  background: none;\n}\n\n.vis-item.vis-dot {\n  position: absolute;\n  padding: 0;\n  border-width: 4px;\n  border-style: solid;\n  border-radius: 4px;\n}\n\n.vis-item.vis-range {\n  border-style: solid;\n  border-radius: 2px;\n  box-sizing: border-box;\n}\n\n.vis-item.vis-background {\n  border: none;\n  background-color: rgba(213, 221, 246, 0.4);\n  box-sizing: border-box;\n  padding: 0;\n  margin: 0;\n}\n\n.vis-item .vis-item-overflow {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  padding: 0;\n  margin: 0;\n  overflow: hidden;\n}\n\n.vis-item-visible-frame {\n  white-space: nowrap;\n}\n\n.vis-item.vis-range .vis-item-content {\n  position: relative;\n  display: inline-block;\n}\n\n.vis-item.vis-background .vis-item-content {\n  position: absolute;\n  display: inline-block;\n}\n\n.vis-item.vis-line {\n  padding: 0;\n  position: absolute;\n  width: 0;\n  border-left-width: 1px;\n  border-left-style: solid;\n}\n\n.vis-item .vis-item-content {\n  white-space: nowrap;\n  box-sizing: border-box;\n  padding: 5px;\n}\n\n.vis-item .vis-onUpdateTime-tooltip {\n  position: absolute;\n  background: #4f81bd;\n  color: white;\n  width: 200px;\n  text-align: center;\n  white-space: nowrap;\n  padding: 5px;\n  border-radius: 1px;\n  transition: 0.4s;\n  -o-transition: 0.4s;\n  -moz-transition: 0.4s;\n  -webkit-transition: 0.4s;\n}\n\n.vis-item .vis-delete,\n.vis-item .vis-delete-rtl {\n  position: absolute;\n  top: 0px;\n  width: 24px;\n  height: 24px;\n  box-sizing: border-box;\n  padding: 0px 5px;\n  cursor: pointer;\n\n  -webkit-transition: background 0.2s linear;\n  -moz-transition: background 0.2s linear;\n  -ms-transition: background 0.2s linear;\n  -o-transition: background 0.2s linear;\n  transition: background 0.2s linear;\n}\n\n.vis-item .vis-delete {\n  right: -24px;\n}\n\n.vis-item .vis-delete-rtl {\n  left: -24px;\n}\n\n.vis-item .vis-delete:after,\n.vis-item .vis-delete-rtl:after {\n  content: "\\00D7"; /* MULTIPLICATION SIGN */\n  color: red;\n  font-family: arial, sans-serif;\n  font-size: 22px;\n  font-weight: bold;\n\n  -webkit-transition: color 0.2s linear;\n  -moz-transition: color 0.2s linear;\n  -ms-transition: color 0.2s linear;\n  -o-transition: color 0.2s linear;\n  transition: color 0.2s linear;\n}\n\n.vis-item .vis-delete:hover,\n.vis-item .vis-delete-rtl:hover {\n  background: red;\n}\n\n.vis-item .vis-delete:hover:after,\n.vis-item .vis-delete-rtl:hover:after {\n  color: white;\n}\n\n.vis-item .vis-drag-center {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0px;\n  cursor: move;\n}\n\n.vis-item.vis-range .vis-drag-left {\n  position: absolute;\n  width: 24px;\n  max-width: 20%;\n  min-width: 2px;\n  height: 100%;\n  top: 0;\n  left: -4px;\n\n  cursor: w-resize;\n}\n\n.vis-item.vis-range .vis-drag-right {\n  position: absolute;\n  width: 24px;\n  max-width: 20%;\n  min-width: 2px;\n  height: 100%;\n  top: 0;\n  right: -4px;\n\n  cursor: e-resize;\n}\n\n.vis-range.vis-item.vis-readonly .vis-drag-left,\n.vis-range.vis-item.vis-readonly .vis-drag-right {\n  cursor: auto;\n}\n\n.vis-item.vis-cluster {\n  vertical-align: center;\n  text-align: center;\n  border-style: solid;\n  border-radius: 2px;\n}\n\n.vis-item.vis-cluster-line {\n  padding: 0;\n  position: absolute;\n  width: 0;\n  border-left-width: 1px;\n  border-left-style: solid;\n}\n\n.vis-item.vis-cluster-dot {\n  position: absolute;\n  padding: 0;\n  border-width: 4px;\n  border-style: solid;\n  border-radius: 4px;\n}\n';
styleInject(css_248z$6);
var css_248z$5 = '.vis-itemset {\n  position: relative;\n  padding: 0;\n  margin: 0;\n\n  box-sizing: border-box;\n}\n\n.vis-itemset .vis-background,\n.vis-itemset .vis-foreground {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  overflow: visible;\n}\n\n.vis-axis {\n  position: absolute;\n  width: 100%;\n  height: 0;\n  left: 0;\n  z-index: 1;\n}\n\n.vis-foreground .vis-group {\n  position: relative;\n  box-sizing: border-box;\n  border-bottom: 1px solid #bfbfbf;\n}\n\n.vis-foreground .vis-group:last-child {\n  border-bottom: none;\n}\n\n.vis-nesting-group {\n  cursor: pointer;\n}\n\n.vis-label.vis-nested-group.vis-group-level-unknown-but-gte1 {\n  background: #f5f5f5;\n}\n.vis-label.vis-nested-group.vis-group-level-0 {\n  background-color: #ffffff;\n}\n.vis-ltr .vis-label.vis-nested-group.vis-group-level-0 .vis-inner {\n  padding-left: 0;\n}\n.vis-rtl .vis-label.vis-nested-group.vis-group-level-0 .vis-inner {\n  padding-right: 0;\n}\n.vis-label.vis-nested-group.vis-group-level-1 {\n  background-color: rgba(0, 0, 0, 0.05);\n}\n.vis-ltr .vis-label.vis-nested-group.vis-group-level-1 .vis-inner {\n  padding-left: 15px;\n}\n.vis-rtl .vis-label.vis-nested-group.vis-group-level-1 .vis-inner {\n  padding-right: 15px;\n}\n.vis-label.vis-nested-group.vis-group-level-2 {\n  background-color: rgba(0, 0, 0, 0.1);\n}\n.vis-ltr .vis-label.vis-nested-group.vis-group-level-2 .vis-inner {\n  padding-left: 30px;\n}\n.vis-rtl .vis-label.vis-nested-group.vis-group-level-2 .vis-inner {\n  padding-right: 30px;\n}\n.vis-label.vis-nested-group.vis-group-level-3 {\n  background-color: rgba(0, 0, 0, 0.15);\n}\n.vis-ltr .vis-label.vis-nested-group.vis-group-level-3 .vis-inner {\n  padding-left: 45px;\n}\n.vis-rtl .vis-label.vis-nested-group.vis-group-level-3 .vis-inner {\n  padding-right: 45px;\n}\n.vis-label.vis-nested-group.vis-group-level-4 {\n  background-color: rgba(0, 0, 0, 0.2);\n}\n.vis-ltr .vis-label.vis-nested-group.vis-group-level-4 .vis-inner {\n  padding-left: 60px;\n}\n.vis-rtl .vis-label.vis-nested-group.vis-group-level-4 .vis-inner {\n  padding-right: 60px;\n}\n.vis-label.vis-nested-group.vis-group-level-5 {\n  background-color: rgba(0, 0, 0, 0.25);\n}\n.vis-ltr .vis-label.vis-nested-group.vis-group-level-5 .vis-inner {\n  padding-left: 75px;\n}\n.vis-rtl .vis-label.vis-nested-group.vis-group-level-5 .vis-inner {\n  padding-right: 75px;\n}\n.vis-label.vis-nested-group.vis-group-level-6 {\n  background-color: rgba(0, 0, 0, 0.3);\n}\n.vis-ltr .vis-label.vis-nested-group.vis-group-level-6 .vis-inner {\n  padding-left: 90px;\n}\n.vis-rtl .vis-label.vis-nested-group.vis-group-level-6 .vis-inner {\n  padding-right: 90px;\n}\n.vis-label.vis-nested-group.vis-group-level-7 {\n  background-color: rgba(0, 0, 0, 0.35);\n}\n.vis-ltr .vis-label.vis-nested-group.vis-group-level-7 .vis-inner {\n  padding-left: 105px;\n}\n.vis-rtl .vis-label.vis-nested-group.vis-group-level-7 .vis-inner {\n  padding-right: 105px;\n}\n.vis-label.vis-nested-group.vis-group-level-8 {\n  background-color: rgba(0, 0, 0, 0.4);\n}\n.vis-ltr .vis-label.vis-nested-group.vis-group-level-8 .vis-inner {\n  padding-left: 120px;\n}\n.vis-rtl .vis-label.vis-nested-group.vis-group-level-8 .vis-inner {\n  padding-right: 120px;\n}\n.vis-label.vis-nested-group.vis-group-level-9 {\n  background-color: rgba(0, 0, 0, 0.45);\n}\n.vis-ltr .vis-label.vis-nested-group.vis-group-level-9 .vis-inner {\n  padding-left: 135px;\n}\n.vis-rtl .vis-label.vis-nested-group.vis-group-level-9 .vis-inner {\n  padding-right: 135px;\n}\n/* default takes over beginning with level-10 (thats why we add .vis-nested-group\n  to the selectors above, to have higher specifity than these rules for the defaults) */\n.vis-label.vis-nested-group {\n  background-color: rgba(0, 0, 0, 0.5);\n}\n.vis-ltr .vis-label.vis-nested-group .vis-inner {\n  padding-left: 150px;\n}\n.vis-rtl .vis-label.vis-nested-group .vis-inner {\n  padding-right: 150px;\n}\n\n.vis-group-level-unknown-but-gte1 {\n  border: 1px solid red;\n}\n\n/* expanded/collapsed indicators */\n.vis-label.vis-nesting-group:before,\n.vis-label.vis-nesting-group:before {\n  display: inline-block;\n  width: 15px;\n}\n.vis-label.vis-nesting-group.expanded:before {\n  content: "\\25BC";\n}\n.vis-label.vis-nesting-group.collapsed:before {\n  content: "\\25B6";\n}\n.vis-rtl .vis-label.vis-nesting-group.collapsed:before {\n  content: "\\25C0";\n}\n/* compensate missing expanded/collapsed indicator, but only at levels > 0 */\n.vis-ltr .vis-label:not(.vis-nesting-group):not(.vis-group-level-0) {\n  padding-left: 15px;\n}\n.vis-rtl .vis-label:not(.vis-nesting-group):not(.vis-group-level-0) {\n  padding-right: 15px;\n}\n\n.vis-overlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 10;\n}\n';
styleInject(css_248z$5);
var css_248z$4 = ".vis-labelset {\n  position: relative;\n\n  overflow: hidden;\n\n  box-sizing: border-box;\n}\n\n.vis-labelset .vis-label {\n  position: relative;\n  left: 0;\n  top: 0;\n  width: 100%;\n  color: #4d4d4d;\n\n  box-sizing: border-box;\n}\n\n.vis-labelset .vis-label {\n  border-bottom: 1px solid #bfbfbf;\n}\n\n.vis-labelset .vis-label.draggable {\n  cursor: pointer;\n}\n\n.vis-group-is-dragging {\n  background: rgba(0, 0, 0, 0.1);\n}\n\n.vis-labelset .vis-label:last-child {\n  border-bottom: none;\n}\n\n.vis-labelset .vis-label .vis-inner {\n  display: inline-block;\n  padding: 5px;\n}\n\n.vis-labelset .vis-label .vis-inner.vis-hidden {\n  padding: 0;\n}\n";
styleInject(css_248z$4);
var css_248z$3 = ".vis-panel {\n  position: absolute;\n\n  padding: 0;\n  margin: 0;\n\n  box-sizing: border-box;\n}\n\n.vis-panel.vis-center,\n.vis-panel.vis-left,\n.vis-panel.vis-right,\n.vis-panel.vis-top,\n.vis-panel.vis-bottom {\n  border: 1px #bfbfbf;\n}\n\n.vis-panel.vis-center,\n.vis-panel.vis-left,\n.vis-panel.vis-right {\n  border-top-style: solid;\n  border-bottom-style: solid;\n  overflow: hidden;\n}\n\n.vis-left.vis-panel.vis-vertical-scroll,\n.vis-right.vis-panel.vis-vertical-scroll {\n  height: 100%;\n  overflow-x: hidden;\n  overflow-y: scroll;\n}\n\n.vis-left.vis-panel.vis-vertical-scroll {\n  direction: rtl;\n}\n\n.vis-left.vis-panel.vis-vertical-scroll .vis-content {\n  direction: ltr;\n}\n\n.vis-right.vis-panel.vis-vertical-scroll {\n  direction: ltr;\n}\n\n.vis-right.vis-panel.vis-vertical-scroll .vis-content {\n  direction: rtl;\n}\n\n.vis-panel.vis-center,\n.vis-panel.vis-top,\n.vis-panel.vis-bottom {\n  border-left-style: solid;\n  border-right-style: solid;\n}\n\n.vis-background {\n  overflow: hidden;\n}\n\n.vis-panel > .vis-content {\n  position: relative;\n}\n\n.vis-panel .vis-shadow {\n  position: absolute;\n  width: 100%;\n  height: 1px;\n  box-shadow: 0 0 10px rgba(0, 0, 0, 0.8);\n  /* TODO: find a nice way to ensure vis-shadows are drawn on top of items\n  z-index: 1;\n  */\n}\n\n.vis-panel .vis-shadow.vis-top {\n  top: -1px;\n  left: 0;\n}\n\n.vis-panel .vis-shadow.vis-bottom {\n  bottom: -1px;\n  left: 0;\n}\n";
styleInject(css_248z$3);
var css_248z$2 = ".vis-graph-group0 {\n  fill: #4f81bd;\n  fill-opacity: 0;\n  stroke-width: 2px;\n  stroke: #4f81bd;\n}\n\n.vis-graph-group1 {\n  fill: #f79646;\n  fill-opacity: 0;\n  stroke-width: 2px;\n  stroke: #f79646;\n}\n\n.vis-graph-group2 {\n  fill: #8c51cf;\n  fill-opacity: 0;\n  stroke-width: 2px;\n  stroke: #8c51cf;\n}\n\n.vis-graph-group3 {\n  fill: #75c841;\n  fill-opacity: 0;\n  stroke-width: 2px;\n  stroke: #75c841;\n}\n\n.vis-graph-group4 {\n  fill: #ff0100;\n  fill-opacity: 0;\n  stroke-width: 2px;\n  stroke: #ff0100;\n}\n\n.vis-graph-group5 {\n  fill: #37d8e6;\n  fill-opacity: 0;\n  stroke-width: 2px;\n  stroke: #37d8e6;\n}\n\n.vis-graph-group6 {\n  fill: #042662;\n  fill-opacity: 0;\n  stroke-width: 2px;\n  stroke: #042662;\n}\n\n.vis-graph-group7 {\n  fill: #00ff26;\n  fill-opacity: 0;\n  stroke-width: 2px;\n  stroke: #00ff26;\n}\n\n.vis-graph-group8 {\n  fill: #ff00ff;\n  fill-opacity: 0;\n  stroke-width: 2px;\n  stroke: #ff00ff;\n}\n\n.vis-graph-group9 {\n  fill: #8f3938;\n  fill-opacity: 0;\n  stroke-width: 2px;\n  stroke: #8f3938;\n}\n\n.vis-timeline .vis-fill {\n  fill-opacity: 0.1;\n  stroke: none;\n}\n\n.vis-timeline .vis-bar {\n  fill-opacity: 0.5;\n  stroke-width: 1px;\n}\n\n.vis-timeline .vis-point {\n  stroke-width: 2px;\n  fill-opacity: 1;\n}\n\n.vis-timeline .vis-legend-background {\n  stroke-width: 1px;\n  fill-opacity: 0.9;\n  fill: #ffffff;\n  stroke: #c2c2c2;\n}\n\n.vis-timeline .vis-outline {\n  stroke-width: 1px;\n  fill-opacity: 1;\n  fill: #ffffff;\n  stroke: #e5e5e5;\n}\n\n.vis-timeline .vis-icon-fill {\n  fill-opacity: 0.3;\n  stroke: none;\n}\n";
styleInject(css_248z$2);
var css_248z$1 = ".vis-time-axis {\n  position: relative;\n  overflow: hidden;\n}\n\n.vis-time-axis.vis-foreground {\n  top: 0;\n  left: 0;\n  width: 100%;\n}\n\n.vis-time-axis.vis-background {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n\n.vis-time-axis .vis-text {\n  position: absolute;\n  color: #4d4d4d;\n  padding: 3px;\n  overflow: hidden;\n  box-sizing: border-box;\n\n  white-space: nowrap;\n}\n\n.vis-time-axis .vis-text.vis-measure {\n  position: absolute;\n  padding-left: 0;\n  padding-right: 0;\n  margin-left: 0;\n  margin-right: 0;\n  visibility: hidden;\n}\n\n.vis-time-axis .vis-grid.vis-vertical {\n  position: absolute;\n  border-left: 1px solid;\n}\n\n.vis-time-axis .vis-grid.vis-vertical-rtl {\n  position: absolute;\n  border-right: 1px solid;\n}\n\n.vis-time-axis .vis-grid.vis-minor {\n  border-color: #e5e5e5;\n}\n\n.vis-time-axis .vis-grid.vis-major {\n  border-color: #bfbfbf;\n}\n";
styleInject(css_248z$1);
var css_248z = ".vis-timeline {\n  position: relative;\n  border: 1px solid #bfbfbf;\n  overflow: hidden;\n  padding: 0;\n  margin: 0;\n  box-sizing: border-box;\n}\n\n.vis-loading-screen {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n";
styleInject(css_248z);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var de$2 = { exports: {} };
var moment$5 = { exports: {} };
var moment$4 = moment$5.exports;
var hasRequiredMoment;
function requireMoment() {
  if (hasRequiredMoment) return moment$5.exports;
  hasRequiredMoment = 1;
  (function(module, exports) {
    (function(global2, factory) {
      module.exports = factory();
    })(moment$4, (function() {
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      function isArray2(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      function isObject2(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;
          for (k in obj) {
            if (hasOwnProp(obj, k)) {
              return false;
            }
          }
          return true;
        }
      }
      function isUndefined(input) {
        return input === void 0;
      }
      function isNumber2(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      function isDate2(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      function map2(arr, fn) {
        var res = [], i, arrLen = arr.length;
        for (i = 0; i < arrLen; ++i) {
          res.push(fn(arr[i], i));
        }
        return res;
      }
      function extend2(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }
        if (hasOwnProp(b, "toString")) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      function createUTC(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      var some2;
      if (Array.prototype.some) {
        some2 = Array.prototype.some;
      } else {
        some2 = function(fun) {
          var t = Object(this), len = t.length >>> 0, i;
          for (i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
              return true;
            }
          }
          return false;
        };
      }
      function isValid(m) {
        var flags = null, parsedParts = false, isNowValid = m._d && !isNaN(m._d.getTime());
        if (isNowValid) {
          flags = getParsingFlags(m);
          parsedParts = some2.call(flags.parsedDateParts, function(i) {
            return i != null;
          });
          isNowValid = flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
          }
        }
        if (Object.isFrozen == null || !Object.isFrozen(m)) {
          m._isValid = isNowValid;
        } else {
          return isNowValid;
        }
        return m._isValid;
      }
      function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
          extend2(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to2, from2) {
        var i, prop, val, momentPropertiesLen = momentProperties.length;
        if (!isUndefined(from2._isAMomentObject)) {
          to2._isAMomentObject = from2._isAMomentObject;
        }
        if (!isUndefined(from2._i)) {
          to2._i = from2._i;
        }
        if (!isUndefined(from2._f)) {
          to2._f = from2._f;
        }
        if (!isUndefined(from2._l)) {
          to2._l = from2._l;
        }
        if (!isUndefined(from2._strict)) {
          to2._strict = from2._strict;
        }
        if (!isUndefined(from2._tzm)) {
          to2._tzm = from2._tzm;
        }
        if (!isUndefined(from2._isUTC)) {
          to2._isUTC = from2._isUTC;
        }
        if (!isUndefined(from2._offset)) {
          to2._offset = from2._offset;
        }
        if (!isUndefined(from2._pf)) {
          to2._pf = getParsingFlags(from2);
        }
        if (!isUndefined(from2._locale)) {
          to2._locale = from2._locale;
        }
        if (momentPropertiesLen > 0) {
          for (i = 0; i < momentPropertiesLen; i++) {
            prop = momentProperties[i];
            val = from2[prop];
            if (!isUndefined(val)) {
              to2[prop] = val;
            }
          }
        }
        return to2;
      }
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = /* @__PURE__ */ new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }
      function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      function deprecate2(msg, fn) {
        var firstTime = true;
        return extend2(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [], arg, i, key, argLen = arguments.length;
            for (i = 0; i < argLen; i++) {
              arg = "";
              if (typeof arguments[i] === "object") {
                arg += "\n[" + i + "] ";
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ": " + arguments[0][key] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i];
              }
              args.push(arg);
            }
            warn(
              msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
            );
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn(msg);
          deprecations[name] = true;
        }
      }
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      function set2(config) {
        var prop, i;
        for (i in config) {
          if (hasOwnProp(config, i)) {
            prop = config[i];
            if (isFunction(prop)) {
              this[i] = prop;
            } else {
              this["_" + i] = prop;
            }
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp(
          (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
        );
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend2({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject2(parentConfig[prop]) && isObject2(childConfig[prop])) {
              res[prop] = {};
              extend2(res[prop], parentConfig[prop]);
              extend2(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject2(parentConfig[prop])) {
            res[prop] = extend2({}, res[prop]);
          }
        }
        return res;
      }
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      var keys2;
      if (Object.keys) {
        keys2 = Object.keys;
      } else {
        keys2 = function(obj) {
          var i, res = [];
          for (i in obj) {
            if (hasOwnProp(obj, i)) {
              res.push(i);
            }
          }
          return res;
        };
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now3) {
        var output = this._calendar[key] || this._calendar["sameElse"];
        return isFunction(output) ? output.call(mom, now3) : output;
      }
      function zeroFill(number2, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number2), zerosToFill = targetLength - absNumber.length, sign2 = number2 >= 0;
        return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback) {
        var func = callback;
        if (typeof callback === "string") {
          func = function() {
            return this[callback]();
          };
        }
        if (token2) {
          formatTokenFunctions[token2] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(
              func.apply(this, arguments),
              token2
            );
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      function makeFormatFunction(format2) {
        var array2 = format2.match(formattingTokens), i, length;
        for (i = 0, length = array2.length; i < length; i++) {
          if (formatTokenFunctions[array2[i]]) {
            array2[i] = formatTokenFunctions[array2[i]];
          } else {
            array2[i] = removeFormattingTokens(array2[i]);
          }
        }
        return function(mom) {
          var output = "", i2;
          for (i2 = 0; i2 < length; i2++) {
            output += isFunction(array2[i2]) ? array2[i2].call(mom, format2) : array2[i2];
          }
          return output;
        };
      }
      function formatMoment(m, format2) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format2 = expandFormat(format2, m.localeData());
        formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
        return formatFunctions[format2](m);
      }
      function expandFormat(format2, locale2) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
          return locale2.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format2)) {
          format2 = format2.replace(
            localFormattingTokens,
            replaceLongDateFormatTokens
          );
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }
        return format2;
      }
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format2 || !formatUpper) {
          return format2;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number2) {
        return this._ordinal.replace("%d", number2);
      }
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number2, withoutSuffix, string2, isFuture) {
        var output = this._relativeTime[string2];
        return isFunction(output) ? output(number2, withoutSuffix, string2, isFuture) : output.replace(/%d/i, number2);
      }
      function pastFuture(diff2, output) {
        var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
        return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
      }
      var aliases = {
        D: "date",
        dates: "date",
        date: "date",
        d: "day",
        days: "day",
        day: "day",
        e: "weekday",
        weekdays: "weekday",
        weekday: "weekday",
        E: "isoWeekday",
        isoweekdays: "isoWeekday",
        isoweekday: "isoWeekday",
        DDD: "dayOfYear",
        dayofyears: "dayOfYear",
        dayofyear: "dayOfYear",
        h: "hour",
        hours: "hour",
        hour: "hour",
        ms: "millisecond",
        milliseconds: "millisecond",
        millisecond: "millisecond",
        m: "minute",
        minutes: "minute",
        minute: "minute",
        M: "month",
        months: "month",
        month: "month",
        Q: "quarter",
        quarters: "quarter",
        quarter: "quarter",
        s: "second",
        seconds: "second",
        second: "second",
        gg: "weekYear",
        weekyears: "weekYear",
        weekyear: "weekYear",
        GG: "isoWeekYear",
        isoweekyears: "isoWeekYear",
        isoweekyear: "isoWeekYear",
        w: "week",
        weeks: "week",
        week: "week",
        W: "isoWeek",
        isoweeks: "isoWeek",
        isoweek: "isoWeek",
        y: "year",
        years: "year",
        year: "year"
      };
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      var priorities = {
        date: 9,
        day: 11,
        weekday: 11,
        isoWeekday: 11,
        dayOfYear: 4,
        hour: 13,
        millisecond: 16,
        minute: 14,
        month: 8,
        quarter: 7,
        second: 15,
        weekYear: 1,
        isoWeekYear: 1,
        week: 5,
        isoWeek: 5,
        year: 1
      };
      function getPrioritizedUnits(unitsObj) {
        var units = [], u;
        for (u in unitsObj) {
          if (hasOwnProp(unitsObj, u)) {
            units.push({ unit: u, priority: priorities[u] });
          }
        }
        units.sort(function(a, b) {
          return a.priority - b.priority;
        });
        return units;
      }
      var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, match1to2NoLeadingZero = /^[1-9]\d?/, match1to2HasZero = /^([1-9]\d|\d)/, regexes;
      regexes = {};
      function addRegexToken(token2, regex, strictRegex) {
        regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token2, config) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config._strict, config._locale);
      }
      function unescapeFormat(s) {
        return regexEscape(
          s.replace("\\", "").replace(
            /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
            function(matched, p1, p2, p3, p4) {
              return p1 || p2 || p3 || p4;
            }
          )
        );
      }
      function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      function absFloor(number2) {
        if (number2 < 0) {
          return Math.ceil(number2) || 0;
        } else {
          return Math.floor(number2);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      var tokens = {};
      function addParseToken(token2, callback) {
        var i, func = callback, tokenLen;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber2(callback)) {
          func = function(input, array2) {
            array2[callback] = toInt(input);
          };
        }
        tokenLen = token2.length;
        for (i = 0; i < tokenLen; i++) {
          tokens[token2[i]] = func;
        }
      }
      function addWeekParseToken(token2, callback) {
        addParseToken(token2, function(input, array2, config, token3) {
          config._w = config._w || {};
          callback(input, config._w, config, token3);
        });
      }
      function addTimeToArrayFromToken(token2, input, config) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config._a, config, token2);
        }
      }
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : "+" + y;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match2);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array2) {
        array2[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array2) {
        array2[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array2) {
        array2[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$12(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get(this, unit);
          }
        };
      }
      function get(mom, unit) {
        if (!mom.isValid()) {
          return NaN;
        }
        var d = mom._d, isUTC = mom._isUTC;
        switch (unit) {
          case "Milliseconds":
            return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();
          case "Seconds":
            return isUTC ? d.getUTCSeconds() : d.getSeconds();
          case "Minutes":
            return isUTC ? d.getUTCMinutes() : d.getMinutes();
          case "Hours":
            return isUTC ? d.getUTCHours() : d.getHours();
          case "Date":
            return isUTC ? d.getUTCDate() : d.getDate();
          case "Day":
            return isUTC ? d.getUTCDay() : d.getDay();
          case "Month":
            return isUTC ? d.getUTCMonth() : d.getMonth();
          case "FullYear":
            return isUTC ? d.getUTCFullYear() : d.getFullYear();
          default:
            return NaN;
        }
      }
      function set$12(mom, unit, value) {
        var d, isUTC, year, month, date2;
        if (!mom.isValid() || isNaN(value)) {
          return;
        }
        d = mom._d;
        isUTC = mom._isUTC;
        switch (unit) {
          case "Milliseconds":
            return void (isUTC ? d.setUTCMilliseconds(value) : d.setMilliseconds(value));
          case "Seconds":
            return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));
          case "Minutes":
            return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));
          case "Hours":
            return void (isUTC ? d.setUTCHours(value) : d.setHours(value));
          case "Date":
            return void (isUTC ? d.setUTCDate(value) : d.setDate(value));
          // case 'Day': // Not real
          //    return void (isUTC ? d.setUTCDay(value) : d.setDay(value));
          // case 'Month': // Not used because we need to pass two variables
          //     return void (isUTC ? d.setUTCMonth(value) : d.setMonth(value));
          case "FullYear":
            break;
          // See below ...
          default:
            return;
        }
        year = value;
        month = mom.month();
        date2 = mom.date();
        date2 = date2 === 29 && month === 1 && !isLeapYear(year) ? 28 : date2;
        void (isUTC ? d.setUTCFullYear(year, month, date2) : d.setFullYear(year, month, date2));
      }
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units]();
        }
        return this;
      }
      function stringSet(units, value) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
          for (i = 0; i < prioritizedLen; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      function mod(n, x) {
        return (n % x + x) % x;
      }
      var indexOf2;
      if (Array.prototype.indexOf) {
        indexOf2 = Array.prototype.indexOf;
      } else {
        indexOf2 = function(o) {
          var i;
          for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
              return i;
            }
          }
          return -1;
        };
      }
      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format2) {
        return this.localeData().monthsShort(this, format2);
      });
      addFormatToken("MMMM", 0, 0, function(format2) {
        return this.localeData().months(this, format2);
      });
      addRegexToken("M", match1to2, match1to2NoLeadingZero);
      addRegexToken("MM", match1to2, match2);
      addRegexToken("MMM", function(isStrict, locale2) {
        return locale2.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale2) {
        return locale2.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array2) {
        array2[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array2, config, token2) {
        var month = config._locale.monthsParse(input, token2, config._strict);
        if (month != null) {
          array2[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m, format2) {
        if (!m) {
          return isArray2(this._months) ? this._months : this._months["standalone"];
        }
        return isArray2(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
      }
      function localeMonthsShort(m, format2) {
        if (!m) {
          return isArray2(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray2(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
      }
      function handleStrictParse(monthName, format2, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i = 0; i < 12; ++i) {
            mom = createUTC([2e3, i]);
            this._shortMonthsParse[i] = this.monthsShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "MMM") {
            ii = indexOf2.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf2.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "MMM") {
            ii = indexOf2.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf2.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf2.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf2.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format2, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format2, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp(
              "^" + this.months(mom, "").replace(".", "") + "$",
              "i"
            );
            this._shortMonthsParse[i] = new RegExp(
              "^" + this.monthsShort(mom, "").replace(".", "") + "$",
              "i"
            );
          }
          if (!strict && !this._monthsParse[i]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
            return i;
          } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
            return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
          }
        }
      }
      function setMonth(mom, value) {
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber2(value)) {
              return mom;
            }
          }
        }
        var month = value, date2 = mom.date();
        date2 = date2 < 29 ? date2 : Math.min(date2, daysInMonth(mom.year(), month));
        void (mom._isUTC ? mom._d.setUTCMonth(month, date2) : mom._d.setMonth(month, date2));
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get(this, "Month");
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom, shortP, longP;
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          shortP = regexEscape(this.monthsShort(mom, ""));
          longP = regexEscape(this.months(mom, ""));
          shortPieces.push(shortP);
          longPieces.push(longP);
          mixedPieces.push(longP);
          mixedPieces.push(shortP);
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._monthsShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
      }
      function createDate(y, m, d, h, M, s, ms) {
        var date2;
        if (y < 100 && y >= 0) {
          date2 = new Date(y + 400, m, d, h, M, s, ms);
          if (isFinite(date2.getFullYear())) {
            date2.setFullYear(y);
          }
        } else {
          date2 = new Date(y, m, d, h, M, s, ms);
        }
        return date2;
      }
      function createUTCDate(y) {
        var date2, args;
        if (y < 100 && y >= 0) {
          args = Array.prototype.slice.call(arguments);
          args[0] = y + 400;
          date2 = new Date(Date.UTC.apply(null, args));
          if (isFinite(date2.getUTCFullYear())) {
            date2.setUTCFullYear(y);
          }
        } else {
          date2 = new Date(Date.UTC.apply(null, arguments));
        }
        return date2;
      }
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addRegexToken("w", match1to2, match1to2NoLeadingZero);
      addRegexToken("ww", match1to2, match2);
      addRegexToken("W", match1to2, match1to2NoLeadingZero);
      addRegexToken("WW", match1to2, match2);
      addWeekParseToken(
        ["w", "ww", "W", "WW"],
        function(input, week, config, token2) {
          week[token2.substr(0, 1)] = toInt(input);
        }
      );
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format2) {
        return this.localeData().weekdaysMin(this, format2);
      });
      addFormatToken("ddd", 0, 0, function(format2) {
        return this.localeData().weekdaysShort(this, format2);
      });
      addFormatToken("dddd", 0, 0, function(format2) {
        return this.localeData().weekdays(this, format2);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale2) {
        return locale2.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale2) {
        return locale2.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale2) {
        return locale2.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
        var weekday = config._locale.weekdaysParse(input, token2, config._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
        week[token2] = toInt(input);
      });
      function parseWeekday(input, locale2) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale2.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      function parseIsoWeekday(input, locale2) {
        if (typeof input === "string") {
          return locale2.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
      }
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m, format2) {
        var weekdays = isArray2(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }
      function handleStrictParse$1(weekdayName, format2, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i = 0; i < 7; ++i) {
            mom = createUTC([2e3, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(
              mom,
              ""
            ).toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "dddd") {
            ii = indexOf2.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf2.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf2.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "dddd") {
            ii = indexOf2.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf2.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf2.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf2.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf2.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf2.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf2.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf2.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf2.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format2, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format2, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp(
              "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._shortWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._minWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
          }
          if (!this._weekdaysParse[i]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = get(this, "Day");
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, "d");
        } else {
          return day;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          minp = regexEscape(this.weekdaysMin(mom, ""));
          shortp = regexEscape(this.weekdaysShort(mom, ""));
          longp = regexEscape(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._weekdaysShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
        this._weekdaysMinStrictRegex = new RegExp(
          "^(" + minPieces.join("|") + ")",
          "i"
        );
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(
            this.hours(),
            this.minutes(),
            lowercase
          );
        });
      }
      meridiem("a", true);
      meridiem("A", false);
      function matchMeridiem(isStrict, locale2) {
        return locale2._meridiemParse;
      }
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2, match1to2HasZero);
      addRegexToken("h", match1to2, match1to2NoLeadingZero);
      addRegexToken("k", match1to2, match1to2NoLeadingZero);
      addRegexToken("HH", match1to2, match2);
      addRegexToken("hh", match1to2, match2);
      addRegexToken("kk", match1to2, match2);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array2, config) {
        var kInput = toInt(input);
        array2[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array2, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array2, config) {
        array2[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array2, config) {
        var pos = input.length - 2;
        array2[HOUR] = toInt(input.substr(0, pos));
        array2[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array2, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array2[HOUR] = toInt(input.substr(0, pos1));
        array2[MINUTE] = toInt(input.substr(pos1, 2));
        array2[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array2, config) {
        var pos = input.length - 2;
        array2[HOUR] = toInt(input.substr(0, pos));
        array2[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array2, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array2[HOUR] = toInt(input.substr(0, pos1));
        array2[MINUTE] = toInt(input.substr(pos1, 2));
        array2[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales2 = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i, minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
          if (arr1[i] !== arr2[i]) {
            return i;
          }
        }
        return minl;
      }
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      function chooseLocale(names) {
        var i = 0, j, next, locale2, split;
        while (i < names.length) {
          split = normalizeLocale(names[i]).split("-");
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split("-") : null;
          while (j > 0) {
            locale2 = loadLocale(split.slice(0, j).join("-"));
            if (locale2) {
              return locale2;
            }
            if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
              break;
            }
            j--;
          }
          i++;
        }
        return globalLocale;
      }
      function isLocaleNameSane(name) {
        return !!(name && name.match("^[^/\\\\]*$"));
      }
      function loadLocale(name) {
        var oldLocale = null, aliasedRequire;
        if (locales2[name] === void 0 && true && module && module.exports && isLocaleNameSane(name)) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = commonjsRequire;
            aliasedRequire("./locale/" + name);
            getSetGlobalLocale(oldLocale);
          } catch (e) {
            locales2[name] = null;
          }
        }
        return locales2[name];
      }
      function getSetGlobalLocale(key, values2) {
        var data;
        if (key) {
          if (isUndefined(values2)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values2);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn(
                "Locale " + key + " not found. Did you forget to load it?"
              );
            }
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name, config) {
        if (config !== null) {
          var locale2, parentConfig = baseConfig;
          config.abbr = name;
          if (locales2[name] != null) {
            deprecateSimple(
              "defineLocaleOverride",
              "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
            );
            parentConfig = locales2[name]._config;
          } else if (config.parentLocale != null) {
            if (locales2[config.parentLocale] != null) {
              parentConfig = locales2[config.parentLocale]._config;
            } else {
              locale2 = loadLocale(config.parentLocale);
              if (locale2 != null) {
                parentConfig = locale2._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name,
                  config
                });
                return null;
              }
            }
          }
          locales2[name] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function(x) {
              defineLocale(x.name, x.config);
            });
          }
          getSetGlobalLocale(name);
          return locales2[name];
        } else {
          delete locales2[name];
          return null;
        }
      }
      function updateLocale(name, config) {
        if (config != null) {
          var locale2, tmpLocale, parentConfig = baseConfig;
          if (locales2[name] != null && locales2[name].parentLocale != null) {
            locales2[name].set(mergeConfigs(locales2[name]._config, config));
          } else {
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              config.abbr = name;
            }
            locale2 = new Locale(config);
            locale2.parentLocale = locales2[name];
            locales2[name] = locale2;
          }
          getSetGlobalLocale(name);
        } else {
          if (locales2[name] != null) {
            if (locales2[name].parentLocale != null) {
              locales2[name] = locales2[name].parentLocale;
              if (name === getSetGlobalLocale()) {
                getSetGlobalLocale(name);
              }
            } else if (locales2[name] != null) {
              delete locales2[name];
            }
          }
        }
        return locales2[name];
      }
      function getLocale(key) {
        var locale2;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray2(key)) {
          locale2 = loadLocale(key);
          if (locale2) {
            return locale2;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      function listLocales() {
        return keys2(locales2);
      }
      function checkOverflow(m) {
        var overflow, a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config) {
        var i, l, string2 = config._i, match = extendedIsoRegex.exec(string2) || basicIsoRegex.exec(string2), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
        if (match) {
          getParsingFlags(config).iso = true;
          for (i = 0, l = isoDatesLen; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
              dateFormat = isoDates[i][0];
              allowTime = isoDates[i][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i = 0, l = isoTimesLen; i < l; i++) {
              if (isoTimes[i][1].exec(match[3])) {
                timeFormat = (match[2] || " ") + isoTimes[i][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2e3 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      function preprocessRFC2822(s) {
        return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
            parsedInput[0],
            parsedInput[1],
            parsedInput[2]
          ).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
          return h * 60 + m;
        }
      }
      function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match) {
          parsedArray = extractFromRFC2822Strings(
            match[4],
            match[3],
            match[2],
            match[5],
            match[6],
            match[7]
          );
          if (!checkWeekday(match[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = /* @__PURE__ */ new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      hooks.createFromInputFallback = deprecate2(
        "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
        function(config) {
          config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
        }
      );
      function defaults2(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      function configFromArray(config) {
        var i, date2, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults2(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date2 = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date2.getUTCMonth();
          config._a[DATE] = date2.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
          config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(
          null,
          input
        );
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults2(
            w.GG,
            config._a[YEAR],
            weekOfYear(createLocal(), 1, 4).year
          );
          week = defaults2(w.W, 1);
          weekday = defaults2(w.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults2(w.gg, config._a[YEAR], curWeek.year);
          week = defaults2(w.w, curWeek.week);
          if (w.d != null) {
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string2 = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string2.length, totalParsedInputLength = 0, era, tokenLen;
        tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens2.length;
        for (i = 0; i < tokenLen; i++) {
          token2 = tokens2[i];
          parsedInput = (string2.match(getParseRegexForToken(token2, config)) || [])[0];
          if (parsedInput) {
            skipped = string2.substr(0, string2.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string2 = string2.slice(
              string2.indexOf(parsedInput) + parsedInput.length
            );
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string2.length > 0) {
          getParsingFlags(config).unusedInput.push(string2);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(
          config._locale,
          config._a[HOUR],
          config._meridiem
        );
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale2, hour, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour;
        }
        if (locale2.meridiemHour != null) {
          return locale2.meridiemHour(hour, meridiem2);
        } else if (locale2.isPM != null) {
          isPm = locale2.isPM(meridiem2);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
        if (configfLen === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = /* @__PURE__ */ new Date(NaN);
          return;
        }
        for (i = 0; i < configfLen; i++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend2(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
        config._a = map2(
          [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
          function(obj) {
            return obj && parseInt(obj, 10);
          }
        );
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i, format2 = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format2 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate2(input)) {
          config._d = input;
        } else if (isArray2(format2)) {
          configFromStringAndArray(config);
        } else if (format2) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate2(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray2(input)) {
          config._a = map2(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject2(input)) {
          configFromObject(config);
        } else if (isNumber2(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
        var c = {};
        if (format2 === true || format2 === false) {
          strict = format2;
          format2 = void 0;
        }
        if (locale2 === true || locale2 === false) {
          strict = locale2;
          locale2 = void 0;
        }
        if (isObject2(input) && isObjectEmpty(input) || isArray2(input) && input.length === 0) {
          input = void 0;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale2;
        c._i = input;
        c._f = format2;
        c._strict = strict;
        return createFromConfig(c);
      }
      function createLocal(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, false);
      }
      var prototypeMin = deprecate2(
        "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        }
      ), prototypeMax = deprecate2(
        "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        }
      );
      function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray2(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
          }
        }
        return res;
      }
      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      }
      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      }
      var now2 = function() {
        return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
      };
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m) {
        var key, unitHasDecimal = false, i, orderLen = ordering.length;
        for (key in m) {
          if (hasOwnProp(m, key) && !(indexOf2.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }
        for (i = 0; i < orderLen; ++i) {
          if (m[ordering[i]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      function isValid$1() {
        return this._isValid;
      }
      function createInvalid$1() {
        return createDuration(NaN);
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
        minutes2 * 6e4 + // 1000 * 60
        hours2 * 1e3 * 60 * 60;
        this._days = +days2 + weeks2 * 7;
        this._months = +months2 + quarters * 3 + years2 * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function absRound(number2) {
        if (number2 < 0) {
          return Math.round(-1 * number2) * -1;
        } else {
          return Math.round(number2);
        }
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
          if (toInt(array1[i]) !== toInt(array2[i])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function offset(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset2 = this.utcOffset(), sign2 = "+";
          if (offset2 < 0) {
            offset2 = -offset2;
            sign2 = "-";
          }
          return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
        });
      }
      offset("Z", ":");
      offset("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array2, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string2) {
        var matches = (string2 || "").match(matcher), chunk, parts, minutes2;
        if (matches === null) {
          return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes2 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
      }
      function cloneWithOffset(input, model) {
        var res, diff2;
        if (model._isUTC) {
          res = model.clone();
          diff2 = (isMoment(input) || isDate2(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff2);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
      }
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset2 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset2 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(
                this,
                createDuration(input - offset2, "m"),
                1,
                false
              );
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset2 : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c = {}, other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match = null, sign2, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber2(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match = aspNetRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign2,
            h: toInt(match[HOUR]) * sign2,
            m: toInt(match[MINUTE]) * sign2,
            s: toInt(match[SECOND]) * sign2,
            ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
            // the millisecond decimal point is included in the match
          };
        } else if (match = isoRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign2),
            M: parseIso(match[3], sign2),
            w: parseIso(match[4], sign2),
            d: parseIso(match[5], sign2),
            h: parseIso(match[6], sign2),
            m: parseIso(match[7], sign2),
            s: parseIso(match[8], sign2)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(
            createLocal(duration.from),
            createLocal(duration.to)
          );
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign2) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign2;
      }
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(
              name,
              "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
            );
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months2) {
          setMonth(mom, get(mom, "Month") + months2 * isAdding);
        }
        if (days2) {
          set$12(mom, "Date", get(mom, "Date") + days2 * isAdding);
        }
        if (milliseconds2) {
          mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days2 || months2);
        }
      }
      var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString2(input) {
        return typeof input === "string" || input instanceof String;
      }
      function isMomentInput(input) {
        return isMoment(input) || isDate2(input) || isString2(input) || isNumber2(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      function isMomentInputObject(input) {
        var objectTest = isObject2(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i, property, propertyLen = properties.length;
        for (i = 0; i < propertyLen; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function isNumberOrStringArray(input) {
        var arrayTest = isArray2(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber2(item) && isString2(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      function isCalendarSpec(input) {
        var objectTest = isObject2(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i, property;
        for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function getCalendarFormat(myMoment, now3) {
        var diff2 = myMoment.diff(now3, "days", true);
        return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
      }
      function calendar$1(time, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
        var now3 = time || createLocal(), sod = cloneWithOffset(now3, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now3) : formats[format2]);
        return this.format(
          output || this.localeData().calendar(format2, this, createLocal(now3))
        );
      }
      function clone2() {
        return new Moment(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from2, to2, units, inclusivity) {
        var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output = monthDiff(this, that) / 12;
            break;
          case "month":
            output = monthDiff(this, that);
            break;
          case "quarter":
            output = monthDiff(this, that) / 3;
            break;
          case "second":
            output = (this - that) / 1e3;
            break;
          // 1000
          case "minute":
            output = (this - that) / 6e4;
            break;
          // 1000 * 60
          case "hour":
            output = (this - that) / 36e5;
            break;
          // 1000 * 60 * 60
          case "day":
            output = (this - that - zoneDelta) / 864e5;
            break;
          // 1000 * 60 * 60 * 24, negate dst
          case "week":
            output = (this - that - zoneDelta) / 6048e5;
            break;
          // 1000 * 60 * 60 * 24 * 7, negate dst
          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
      }
      function monthDiff(a, b) {
        if (a.date() < b.date()) {
          return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString2() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(
            m,
            utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        if (isFunction(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
          }
        }
        return formatMoment(
          m,
          utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func = "moment", zone = "", prefix, year, datetime, suffix;
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix = "[" + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }
      function format(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      function locale(key) {
        var newLocaleData;
        if (key === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate2(
        "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
        function(key) {
          if (key === void 0) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        }
      );
      function localeData() {
        return this._locale;
      }
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return new Date(y, m, d).valueOf();
        }
      }
      function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y, m, d);
        }
      }
      function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3,
              1
            );
            break;
          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday()
            );
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1)
            );
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time = this._d.valueOf();
            time -= mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            );
            break;
          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3 + 3,
              1
            ) - 1;
            break;
          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday() + 7
            ) - 1;
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1) + 7
            ) - 1;
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            ) - 1;
            break;
          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      function toDate() {
        return new Date(this.valueOf());
      }
      function toArray2() {
        var m = this;
        return [
          m.year(),
          m.month(),
          m.date(),
          m.hour(),
          m.minute(),
          m.second(),
          m.millisecond()
        ];
      }
      function toObject2() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      function isValid$2() {
        return isValid(this);
      }
      function parsingFlags() {
        return extend2({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(
        ["N", "NN", "NNN", "NNNN", "NNNNN"],
        function(input, array2, config, token2) {
          var era = config._locale.erasParse(input, token2, config._strict);
          if (era) {
            getParsingFlags(config).era = era;
          } else {
            getParsingFlags(config).invalidEra = input;
          }
        }
      );
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array2, config, token2) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
          match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array2[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
          array2[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m, format2) {
        var i, l, date2, eras = this._eras || getLocale("en")._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
          switch (typeof eras[i].since) {
            case "string":
              date2 = hooks(eras[i].since).startOf("day");
              eras[i].since = date2.valueOf();
              break;
          }
          switch (typeof eras[i].until) {
            case "undefined":
              eras[i].until = Infinity;
              break;
            case "string":
              date2 = hooks(eras[i].until).startOf("day").valueOf();
              eras[i].until = date2.valueOf();
              break;
          }
        }
        return eras;
      }
      function localeErasParse(eraName, format2, strict) {
        var i, l, eras = this.eras(), name, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i = 0, l = eras.length; i < l; ++i) {
          name = eras[i].name.toUpperCase();
          abbr = eras[i].abbr.toUpperCase();
          narrow = eras[i].narrow.toUpperCase();
          if (strict) {
            switch (format2) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras[i];
                }
                break;
              case "NNNN":
                if (name === eraName) {
                  return eras[i];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras[i];
                }
                break;
            }
          } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i];
          }
        }
      }
      function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
        }
      }
      function getEraName() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].name;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].name;
          }
        }
        return "";
      }
      function getEraNarrow() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].narrow;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].narrow;
          }
        }
        return "";
      }
      function getEraAbbr() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].abbr;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].abbr;
          }
        }
        return "";
      }
      function getEraYear() {
        var i, l, dir, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          dir = eras[i].since <= eras[i].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
            return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
          }
        }
        return this.year();
      }
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      function matchEraAbbr(isStrict, locale2) {
        return locale2.erasAbbrRegex(isStrict);
      }
      function matchEraName(isStrict, locale2) {
        return locale2.erasNameRegex(isStrict);
      }
      function matchEraNarrow(isStrict, locale2) {
        return locale2.erasNarrowRegex(isStrict);
      }
      function matchEraYearOrdinal(isStrict, locale2) {
        return locale2._eraYearOrdinalRegex || matchUnsigned;
      }
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, erasName, erasAbbr, erasNarrow, eras = this.eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          erasName = regexEscape(eras[i].name);
          erasAbbr = regexEscape(eras[i].abbr);
          erasNarrow = regexEscape(eras[i].narrow);
          namePieces.push(erasName);
          abbrPieces.push(erasAbbr);
          narrowPieces.push(erasNarrow);
          mixedPieces.push(erasName);
          mixedPieces.push(erasAbbr);
          mixedPieces.push(erasNarrow);
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp(
          "^(" + narrowPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match2);
      addRegexToken("gg", match1to2, match2);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(
        ["gggg", "ggggg", "GGGG", "GGGGG"],
        function(input, week, config, token2) {
          week[token2.substr(0, 2)] = toInt(input);
        }
      );
      addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
        week[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.week(),
          this.weekday() + this.localeData()._week.dow,
          this.localeData()._week.dow,
          this.localeData()._week.doy
        );
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.isoWeek(),
          this.isoWeekday(),
          1,
          4
        );
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date2 = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date2.getUTCFullYear());
        this.month(date2.getUTCMonth());
        this.date(date2.getUTCDate());
        return this;
      }
      addFormatToken("Q", 0, "Qo", "quarter");
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array2) {
        array2[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken("D", ["DD", 2], "Do", "date");
      addRegexToken("D", match1to2, match1to2NoLeadingZero);
      addRegexToken("DD", match1to2, match2);
      addRegexToken("Do", function(isStrict, locale2) {
        return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE);
      addParseToken("Do", function(input, array2) {
        array2[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken(["DDD", "DDDD"], function(input, array2, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round(
          (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
        ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      addFormatToken("m", ["mm", 2], 0, "minute");
      addRegexToken("m", match1to2, match1to2HasZero);
      addRegexToken("mm", match1to2, match2);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addRegexToken("s", match1to2, match1to2HasZero);
      addRegexToken("ss", match1to2, match2);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match2);
      addRegexToken("SSS", match1to3, match3);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array2) {
        array2[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      var proto = Moment.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone2;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray2;
      proto.toObject = toObject2;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[/* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON;
      proto.toString = toString2;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate2(
        "dates accessor is deprecated. Use date instead.",
        getSetDayOfMonth
      );
      proto.months = deprecate2(
        "months accessor is deprecated. Use month instead",
        getSetMonth
      );
      proto.years = deprecate2(
        "years accessor is deprecated. Use year instead",
        getSetYear
      );
      proto.zone = deprecate2(
        "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
        getSetZone
      );
      proto.isDSTShifted = deprecate2(
        "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
        isDaylightSavingTimeShifted
      );
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      function preParsePostFormat(string2) {
        return string2;
      }
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set2;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format2, index, field, setter) {
        var locale2 = getLocale(), utc = createUTC().set(setter, index);
        return locale2[field](utc, format2);
      }
      function listMonthsImpl(format2, index, field) {
        if (isNumber2(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
        if (index != null) {
          return get$1(format2, index, field, "month");
        }
        var i, out = [];
        for (i = 0; i < 12; i++) {
          out[i] = get$1(format2, i, field, "month");
        }
        return out;
      }
      function listWeekdaysImpl(localeSorted, format2, index, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber2(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        } else {
          format2 = localeSorted;
          index = format2;
          localeSorted = false;
          if (isNumber2(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        }
        var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
        if (index != null) {
          return get$1(format2, (index + shift) % 7, field, "day");
        }
        for (i = 0; i < 7; i++) {
          out[i] = get$1(format2, (i + shift) % 7, field, "day");
        }
        return out;
      }
      function listMonths(format2, index) {
        return listMonthsImpl(format2, index, "months");
      }
      function listMonthsShort(format2, index) {
        return listMonthsImpl(format2, index, "monthsShort");
      }
      function listWeekdays(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
      }
      function listWeekdaysShort(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
      }
      function listWeekdaysMin(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
      }
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number2) {
          var b = number2 % 10, output = toInt(number2 % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number2 + output;
        }
      });
      hooks.lang = deprecate2(
        "moment.lang is deprecated. Use moment.locale instead.",
        getSetGlobalLocale
      );
      hooks.langData = deprecate2(
        "moment.langData is deprecated. Use moment.localeData instead.",
        getLocale
      );
      var mathAbs = Math.abs;
      function abs2() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      function absCeil(number2) {
        if (number2 < 0) {
          return Math.floor(number2);
        } else {
          return Math.ceil(number2);
        }
      }
      function bubble() {
        var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
        if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
          milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
          days2 = 0;
          months2 = 0;
        }
        data.milliseconds = milliseconds2 % 1e3;
        seconds2 = absFloor(milliseconds2 / 1e3);
        data.seconds = seconds2 % 60;
        minutes2 = absFloor(seconds2 / 60);
        data.minutes = minutes2 % 60;
        hours2 = absFloor(minutes2 / 60);
        data.hours = hours2 % 24;
        days2 += absFloor(hours2 / 24);
        monthsFromDays = absFloor(daysToMonths(days2));
        months2 += monthsFromDays;
        days2 -= absCeil(monthsToDays(monthsFromDays));
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        data.days = days2;
        data.months = months2;
        data.years = years2;
        return this;
      }
      function daysToMonths(days2) {
        return days2 * 4800 / 146097;
      }
      function monthsToDays(months2) {
        return months2 * 146097 / 4800;
      }
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days2, months2, milliseconds2 = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days2 = this._days + milliseconds2 / 864e5;
          months2 = this._months + daysToMonths(days2);
          switch (units) {
            case "month":
              return months2;
            case "quarter":
              return months2 / 3;
            case "year":
              return months2 / 12;
          }
        } else {
          days2 = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case "week":
              return days2 / 7 + milliseconds2 / 6048e5;
            case "day":
              return days2 + milliseconds2 / 864e5;
            case "hour":
              return days2 * 24 + milliseconds2 / 36e5;
            case "minute":
              return days2 * 1440 + milliseconds2 / 6e4;
            case "second":
              return days2 * 86400 + milliseconds2 / 1e3;
            // Math.floor prevents floating point math errors here
            case "millisecond":
              return Math.floor(days2 * 864e5) + milliseconds2;
            default:
              throw new Error("Unknown unit " + units);
          }
        }
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y"), valueOf$1 = asMilliseconds;
      function clone$1() {
        return createDuration(this);
      }
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      function makeGetter(name) {
        return function() {
          return this.isValid() ? this._data[name] : NaN;
        };
      }
      var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round2 = Math.round, thresholds = {
        ss: 44,
        // a few seconds to seconds
        s: 45,
        // seconds to minute
        m: 45,
        // minutes to hour
        h: 22,
        // hours to day
        d: 26,
        // days to month/week
        w: null,
        // weeks to month
        M: 11
        // months to year
      };
      function substituteTimeAgo(string2, number2, withoutSuffix, isFuture, locale2) {
        return locale2.relativeTime(number2 || 1, !!withoutSuffix, string2, isFuture);
      }
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
        var duration = createDuration(posNegDuration).abs(), seconds2 = round2(duration.as("s")), minutes2 = round2(duration.as("m")), hours2 = round2(duration.as("h")), days2 = round2(duration.as("d")), months2 = round2(duration.as("M")), weeks2 = round2(duration.as("w")), years2 = round2(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
        if (thresholds2.w != null) {
          a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale2;
        return substituteTimeAgo.apply(null, a);
      }
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round2;
        }
        if (typeof roundingFunction === "function") {
          round2 = roundingFunction;
          return true;
        }
        return false;
      }
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale2, output;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale2 = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale2);
        if (withSuffix) {
          output = locale2.pastFuture(+this, output);
        }
        return locale2.postformat(output);
      }
      var abs$1 = Math.abs;
      function sign(x) {
        return (x > 0) - (x < 0) || +x;
      }
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes2 = absFloor(seconds2 / 60);
        hours2 = absFloor(minutes2 / 60);
        seconds2 %= 60;
        minutes2 %= 60;
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign(this._months) !== sign(total) ? "-" : "";
        daysSign = sign(this._days) !== sign(total) ? "-" : "";
        hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
        return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
      }
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs2;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate2(
        "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
        toISOString$1
      );
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array2, config) {
        config._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array2, config) {
        config._d = new Date(toInt(input));
      });
      hooks.version = "2.30.1";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now2;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate2;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        // <input type="datetime-local" step="0.001" />
        DATE: "YYYY-MM-DD",
        // <input type="date" />
        TIME: "HH:mm",
        // <input type="time" />
        TIME_SECONDS: "HH:mm:ss",
        // <input type="time" step="1" />
        TIME_MS: "HH:mm:ss.SSS",
        // <input type="time" step="0.001" />
        WEEK: "GGGG-[W]WW",
        // <input type="week" />
        MONTH: "YYYY-MM"
        // <input type="month" />
      };
      return hooks;
    }));
  })(moment$5);
  return moment$5.exports;
}
var de$1 = de$2.exports;
var hasRequiredDe;
function requireDe() {
  if (hasRequiredDe) return de$2.exports;
  hasRequiredDe = 1;
  (function(module, exports) {
    (function(global2, factory) {
      typeof commonjsRequire === "function" ? factory(requireMoment()) : factory(global2.moment);
    })(de$1, (function(moment2) {
      function processRelativeTime(number2, withoutSuffix, key, isFuture) {
        var format = {
          m: ["eine Minute", "einer Minute"],
          h: ["eine Stunde", "einer Stunde"],
          d: ["ein Tag", "einem Tag"],
          dd: [number2 + " Tage", number2 + " Tagen"],
          w: ["eine Woche", "einer Woche"],
          M: ["ein Monat", "einem Monat"],
          MM: [number2 + " Monate", number2 + " Monaten"],
          y: ["ein Jahr", "einem Jahr"],
          yy: [number2 + " Jahre", number2 + " Jahren"]
        };
        return withoutSuffix ? format[key][0] : format[key][1];
      }
      var de2 = moment2.defineLocale("de", {
        months: "Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split(
          "_"
        ),
        monthsShort: "Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),
        monthsParseExact: true,
        weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split(
          "_"
        ),
        weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),
        weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D. MMMM YYYY",
          LLL: "D. MMMM YYYY HH:mm",
          LLLL: "dddd, D. MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[heute um] LT [Uhr]",
          sameElse: "L",
          nextDay: "[morgen um] LT [Uhr]",
          nextWeek: "dddd [um] LT [Uhr]",
          lastDay: "[gestern um] LT [Uhr]",
          lastWeek: "[letzten] dddd [um] LT [Uhr]"
        },
        relativeTime: {
          future: "in %s",
          past: "vor %s",
          s: "ein paar Sekunden",
          ss: "%d Sekunden",
          m: processRelativeTime,
          mm: "%d Minuten",
          h: processRelativeTime,
          hh: "%d Stunden",
          d: processRelativeTime,
          dd: processRelativeTime,
          w: processRelativeTime,
          ww: "%d Wochen",
          M: processRelativeTime,
          MM: processRelativeTime,
          y: processRelativeTime,
          yy: processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      return de2;
    }));
  })();
  return de$2.exports;
}
requireDe();
var es$2 = { exports: {} };
var es$1 = es$2.exports;
var hasRequiredEs;
function requireEs() {
  if (hasRequiredEs) return es$2.exports;
  hasRequiredEs = 1;
  (function(module, exports) {
    (function(global2, factory) {
      typeof commonjsRequire === "function" ? factory(requireMoment()) : factory(global2.moment);
    })(es$1, (function(moment2) {
      var monthsShortDot = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split(
        "_"
      ), monthsShort = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), monthsParse = [
        /^ene/i,
        /^feb/i,
        /^mar/i,
        /^abr/i,
        /^may/i,
        /^jun/i,
        /^jul/i,
        /^ago/i,
        /^sep/i,
        /^oct/i,
        /^nov/i,
        /^dic/i
      ], monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
      var es2 = moment2.defineLocale("es", {
        months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split(
          "_"
        ),
        monthsShort: function(m, format) {
          if (!m) {
            return monthsShortDot;
          } else if (/-MMM-/.test(format)) {
            return monthsShort[m.month()];
          } else {
            return monthsShortDot[m.month()];
          }
        },
        monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
        monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
        monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        weekdays: "domingo_lunes_martes_mircoles_jueves_viernes_sbado".split("_"),
        weekdaysShort: "dom._lun._mar._mi._jue._vie._sb.".split("_"),
        weekdaysMin: "do_lu_ma_mi_ju_vi_s".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "H:mm",
          LTS: "H:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D [de] MMMM [de] YYYY",
          LLL: "D [de] MMMM [de] YYYY H:mm",
          LLLL: "dddd, D [de] MMMM [de] YYYY H:mm"
        },
        calendar: {
          sameDay: function() {
            return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          },
          nextDay: function() {
            return "[maana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          },
          nextWeek: function() {
            return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          },
          lastDay: function() {
            return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          },
          lastWeek: function() {
            return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "en %s",
          past: "hace %s",
          s: "unos segundos",
          ss: "%d segundos",
          m: "un minuto",
          mm: "%d minutos",
          h: "una hora",
          hh: "%d horas",
          d: "un da",
          dd: "%d das",
          w: "una semana",
          ww: "%d semanas",
          M: "un mes",
          MM: "%d meses",
          y: "un ao",
          yy: "%d aos"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        },
        invalidDate: "Fecha invlida"
      });
      return es2;
    }));
  })();
  return es$2.exports;
}
requireEs();
var fr$2 = { exports: {} };
var fr$1 = fr$2.exports;
var hasRequiredFr;
function requireFr() {
  if (hasRequiredFr) return fr$2.exports;
  hasRequiredFr = 1;
  (function(module, exports) {
    (function(global2, factory) {
      typeof commonjsRequire === "function" ? factory(requireMoment()) : factory(global2.moment);
    })(fr$1, (function(moment2) {
      var monthsStrictRegex = /^(janvier|fvrier|mars|avril|mai|juin|juillet|aot|septembre|octobre|novembre|dcembre)/i, monthsShortStrictRegex = /(janv\.?|fvr\.?|mars|avr\.?|mai|juin|juil\.?|aot|sept\.?|oct\.?|nov\.?|dc\.?)/i, monthsRegex = /(janv\.?|fvr\.?|mars|avr\.?|mai|juin|juil\.?|aot|sept\.?|oct\.?|nov\.?|dc\.?|janvier|fvrier|mars|avril|mai|juin|juillet|aot|septembre|octobre|novembre|dcembre)/i, monthsParse = [
        /^janv/i,
        /^fvr/i,
        /^mars/i,
        /^avr/i,
        /^mai/i,
        /^juin/i,
        /^juil/i,
        /^aot/i,
        /^sept/i,
        /^oct/i,
        /^nov/i,
        /^dc/i
      ];
      var fr2 = moment2.defineLocale("fr", {
        months: "janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre".split(
          "_"
        ),
        monthsShort: "janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.".split(
          "_"
        ),
        monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex,
        monthsShortStrictRegex,
        monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
        weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
        weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[Aujourdhui ] LT",
          nextDay: "[Demain ] LT",
          nextWeek: "dddd [] LT",
          lastDay: "[Hier ] LT",
          lastWeek: "dddd [dernier ] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "dans %s",
          past: "il y a %s",
          s: "quelques secondes",
          ss: "%d secondes",
          m: "une minute",
          mm: "%d minutes",
          h: "une heure",
          hh: "%d heures",
          d: "un jour",
          dd: "%d jours",
          w: "une semaine",
          ww: "%d semaines",
          M: "un mois",
          MM: "%d mois",
          y: "un an",
          yy: "%d ans"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
        ordinal: function(number2, period) {
          switch (period) {
            // TODO: Return 'e' when day of month > 1. Move this case inside
            // block for masculine words below.
            // See https://github.com/moment/moment/issues/3375
            case "D":
              return number2 + (number2 === 1 ? "er" : "");
            // Words with masculine grammatical gender: mois, trimestre, jour
            default:
            case "M":
            case "Q":
            case "DDD":
            case "d":
              return number2 + (number2 === 1 ? "er" : "e");
            // Words with feminine grammatical gender: semaine
            case "w":
            case "W":
              return number2 + (number2 === 1 ? "re" : "e");
          }
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      return fr2;
    }));
  })();
  return fr$2.exports;
}
requireFr();
var it$2 = { exports: {} };
var it$1 = it$2.exports;
var hasRequiredIt;
function requireIt() {
  if (hasRequiredIt) return it$2.exports;
  hasRequiredIt = 1;
  (function(module, exports) {
    (function(global2, factory) {
      typeof commonjsRequire === "function" ? factory(requireMoment()) : factory(global2.moment);
    })(it$1, (function(moment2) {
      var it2 = moment2.defineLocale("it", {
        months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split(
          "_"
        ),
        monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),
        weekdays: "domenica_luned_marted_mercoled_gioved_venerd_sabato".split(
          "_"
        ),
        weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"),
        weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: function() {
            return "[Oggi a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
          },
          nextDay: function() {
            return "[Domani a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
          },
          nextWeek: function() {
            return "dddd [a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
          },
          lastDay: function() {
            return "[Ieri a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
          },
          lastWeek: function() {
            switch (this.day()) {
              case 0:
                return "[La scorsa] dddd [a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
              default:
                return "[Lo scorso] dddd [a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
            }
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "tra %s",
          past: "%s fa",
          s: "alcuni secondi",
          ss: "%d secondi",
          m: "un minuto",
          mm: "%d minuti",
          h: "un'ora",
          hh: "%d ore",
          d: "un giorno",
          dd: "%d giorni",
          w: "una settimana",
          ww: "%d settimane",
          M: "un mese",
          MM: "%d mesi",
          y: "un anno",
          yy: "%d anni"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      return it2;
    }));
  })();
  return it$2.exports;
}
requireIt();
var ja$2 = { exports: {} };
var ja$1 = ja$2.exports;
var hasRequiredJa;
function requireJa() {
  if (hasRequiredJa) return ja$2.exports;
  hasRequiredJa = 1;
  (function(module, exports) {
    (function(global2, factory) {
      typeof commonjsRequire === "function" ? factory(requireMoment()) : factory(global2.moment);
    })(ja$1, (function(moment2) {
      var ja2 = moment2.defineLocale("ja", {
        eras: [
          {
            since: "2019-05-01",
            offset: 1,
            name: "",
            narrow: "",
            abbr: "R"
          },
          {
            since: "1989-01-08",
            until: "2019-04-30",
            offset: 1,
            name: "",
            narrow: "",
            abbr: "H"
          },
          {
            since: "1926-12-25",
            until: "1989-01-07",
            offset: 1,
            name: "",
            narrow: "",
            abbr: "S"
          },
          {
            since: "1912-07-30",
            until: "1926-12-24",
            offset: 1,
            name: "",
            narrow: "",
            abbr: "T"
          },
          {
            since: "1873-01-01",
            until: "1912-07-29",
            offset: 6,
            name: "",
            narrow: "",
            abbr: "M"
          },
          {
            since: "0001-01-01",
            until: "1873-12-31",
            offset: 1,
            name: "",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        eraYearOrdinalRegex: /(|\d+)/,
        eraYearOrdinalParse: function(input, match) {
          return match[1] === "" ? 1 : parseInt(match[1] || input, 10);
        },
        months: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
        monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split(
          "_"
        ),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "YYYY/MM/DD",
          LL: "YYYYMD",
          LLL: "YYYYMD HH:mm",
          LLLL: "YYYYMD dddd HH:mm",
          l: "YYYY/MM/DD",
          ll: "YYYYMD",
          lll: "YYYYMD HH:mm",
          llll: "YYYYMD(ddd) HH:mm"
        },
        meridiemParse: /|/i,
        isPM: function(input) {
          return input === "";
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 12) {
            return "";
          } else {
            return "";
          }
        },
        calendar: {
          sameDay: "[] LT",
          nextDay: "[] LT",
          nextWeek: function(now2) {
            if (now2.week() !== this.week()) {
              return "[]dddd LT";
            } else {
              return "dddd LT";
            }
          },
          lastDay: "[] LT",
          lastWeek: function(now2) {
            if (this.week() !== now2.week()) {
              return "[]dddd LT";
            } else {
              return "dddd LT";
            }
          },
          sameElse: "L"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function(number2, period) {
          switch (period) {
            case "y":
              return number2 === 1 ? "" : number2 + "";
            case "d":
            case "D":
            case "DDD":
              return number2 + "";
            default:
              return number2;
          }
        },
        relativeTime: {
          future: "%s",
          past: "%s",
          s: "",
          ss: "%d",
          m: "1",
          mm: "%d",
          h: "1",
          hh: "%d",
          d: "1",
          dd: "%d",
          M: "1",
          MM: "%d",
          y: "1",
          yy: "%d"
        }
      });
      return ja2;
    }));
  })();
  return ja$2.exports;
}
requireJa();
var nl$2 = { exports: {} };
var nl$1 = nl$2.exports;
var hasRequiredNl;
function requireNl() {
  if (hasRequiredNl) return nl$2.exports;
  hasRequiredNl = 1;
  (function(module, exports) {
    (function(global2, factory) {
      typeof commonjsRequire === "function" ? factory(requireMoment()) : factory(global2.moment);
    })(nl$1, (function(moment2) {
      var monthsShortWithDots = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"), monthsShortWithoutDots = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"), monthsParse = [
        /^jan/i,
        /^feb/i,
        /^(maart|mrt\.?)$/i,
        /^apr/i,
        /^mei$/i,
        /^jun[i.]?$/i,
        /^jul[i.]?$/i,
        /^aug/i,
        /^sep/i,
        /^okt/i,
        /^nov/i,
        /^dec/i
      ], monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
      var nl2 = moment2.defineLocale("nl", {
        months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split(
          "_"
        ),
        monthsShort: function(m, format) {
          if (!m) {
            return monthsShortWithDots;
          } else if (/-MMM-/.test(format)) {
            return monthsShortWithoutDots[m.month()];
          } else {
            return monthsShortWithDots[m.month()];
          }
        },
        monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
        monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
        monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),
        weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"),
        weekdaysMin: "zo_ma_di_wo_do_vr_za".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD-MM-YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[vandaag om] LT",
          nextDay: "[morgen om] LT",
          nextWeek: "dddd [om] LT",
          lastDay: "[gisteren om] LT",
          lastWeek: "[afgelopen] dddd [om] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "over %s",
          past: "%s geleden",
          s: "een paar seconden",
          ss: "%d seconden",
          m: "n minuut",
          mm: "%d minuten",
          h: "n uur",
          hh: "%d uur",
          d: "n dag",
          dd: "%d dagen",
          w: "n week",
          ww: "%d weken",
          M: "n maand",
          MM: "%d maanden",
          y: "n jaar",
          yy: "%d jaar"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function(number2) {
          return number2 + (number2 === 1 || number2 === 8 || number2 >= 20 ? "ste" : "de");
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      return nl2;
    }));
  })();
  return nl$2.exports;
}
requireNl();
var pl$2 = { exports: {} };
var pl$1 = pl$2.exports;
var hasRequiredPl;
function requirePl() {
  if (hasRequiredPl) return pl$2.exports;
  hasRequiredPl = 1;
  (function(module, exports) {
    (function(global2, factory) {
      typeof commonjsRequire === "function" ? factory(requireMoment()) : factory(global2.moment);
    })(pl$1, (function(moment2) {
      var monthsNominative = "stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie".split(
        "_"
      ), monthsSubjective = "stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia".split(
        "_"
      ), monthsParse = [
        /^sty/i,
        /^lut/i,
        /^mar/i,
        /^kwi/i,
        /^maj/i,
        /^cze/i,
        /^lip/i,
        /^sie/i,
        /^wrz/i,
        /^pa/i,
        /^lis/i,
        /^gru/i
      ];
      function plural(n) {
        return n % 10 < 5 && n % 10 > 1 && ~~(n / 10) % 10 !== 1;
      }
      function translate(number2, withoutSuffix, key) {
        var result = number2 + " ";
        switch (key) {
          case "ss":
            return result + (plural(number2) ? "sekundy" : "sekund");
          case "m":
            return withoutSuffix ? "minuta" : "minut";
          case "mm":
            return result + (plural(number2) ? "minuty" : "minut");
          case "h":
            return withoutSuffix ? "godzina" : "godzin";
          case "hh":
            return result + (plural(number2) ? "godziny" : "godzin");
          case "ww":
            return result + (plural(number2) ? "tygodnie" : "tygodni");
          case "MM":
            return result + (plural(number2) ? "miesice" : "miesicy");
          case "yy":
            return result + (plural(number2) ? "lata" : "lat");
        }
      }
      var pl2 = moment2.defineLocale("pl", {
        months: function(momentToFormat, format) {
          if (!momentToFormat) {
            return monthsNominative;
          } else if (/D MMMM/.test(format)) {
            return monthsSubjective[momentToFormat.month()];
          } else {
            return monthsNominative[momentToFormat.month()];
          }
        },
        monthsShort: "sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru".split("_"),
        monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        weekdays: "niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota".split("_"),
        weekdaysShort: "ndz_pon_wt_r_czw_pt_sob".split("_"),
        weekdaysMin: "Nd_Pn_Wt_r_Cz_Pt_So".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[Dzi o] LT",
          nextDay: "[Jutro o] LT",
          nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[W niedziel o] LT";
              case 2:
                return "[We wtorek o] LT";
              case 3:
                return "[W rod o] LT";
              case 6:
                return "[W sobot o] LT";
              default:
                return "[W] dddd [o] LT";
            }
          },
          lastDay: "[Wczoraj o] LT",
          lastWeek: function() {
            switch (this.day()) {
              case 0:
                return "[W zesz niedziel o] LT";
              case 3:
                return "[W zesz rod o] LT";
              case 6:
                return "[W zesz sobot o] LT";
              default:
                return "[W zeszy] dddd [o] LT";
            }
          },
          sameElse: "L"
        },
        relativeTime: {
          future: "za %s",
          past: "%s temu",
          s: "kilka sekund",
          ss: translate,
          m: translate,
          mm: translate,
          h: translate,
          hh: translate,
          d: "1 dzie",
          dd: "%d dni",
          w: "tydzie",
          ww: translate,
          M: "miesic",
          MM: translate,
          y: "rok",
          yy: translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      return pl2;
    }));
  })();
  return pl$2.exports;
}
requirePl();
var ru$2 = { exports: {} };
var ru$1 = ru$2.exports;
var hasRequiredRu;
function requireRu() {
  if (hasRequiredRu) return ru$2.exports;
  hasRequiredRu = 1;
  (function(module, exports) {
    (function(global2, factory) {
      typeof commonjsRequire === "function" ? factory(requireMoment()) : factory(global2.moment);
    })(ru$1, (function(moment2) {
      function plural(word, num) {
        var forms = word.split("_");
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
      }
      function relativeTimeWithPlural(number2, withoutSuffix, key) {
        var format = {
          ss: withoutSuffix ? "__" : "__",
          mm: withoutSuffix ? "__" : "__",
          hh: "__",
          dd: "__",
          ww: "__",
          MM: "__",
          yy: "__"
        };
        if (key === "m") {
          return withoutSuffix ? "" : "";
        } else {
          return number2 + " " + plural(format[key], +number2);
        }
      }
      var monthsParse = [
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^[]/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i,
        /^/i
      ];
      var ru2 = moment2.defineLocale("ru", {
        months: {
          format: "___________".split(
            "_"
          ),
          standalone: "___________".split(
            "_"
          )
        },
        monthsShort: {
          //  CLDR  "."  ".",       ?
          format: "._._._.____._._._._.".split(
            "_"
          ),
          standalone: "._.__.____._._._._.".split(
            "_"
          )
        },
        weekdays: {
          standalone: "______".split(
            "_"
          ),
          format: "______".split(
            "_"
          ),
          isFormat: /\[ ?[] ?(?:||)? ?] ?dddd/
        },
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        //    ,   ,  ,  4 ,      
        monthsRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
        //  
        monthsShortRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
        //    
        monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,
        // ,     
        monthsShortStrictRegex: /^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i,
        longDateFormat: {
          LT: "H:mm",
          LTS: "H:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D MMMM YYYY .",
          LLL: "D MMMM YYYY ., H:mm",
          LLLL: "dddd, D MMMM YYYY ., H:mm"
        },
        calendar: {
          sameDay: "[, ] LT",
          nextDay: "[, ] LT",
          lastDay: "[, ] LT",
          nextWeek: function(now2) {
            if (now2.week() !== this.week()) {
              switch (this.day()) {
                case 0:
                  return "[ ] dddd, [] LT";
                case 1:
                case 2:
                case 4:
                  return "[ ] dddd, [] LT";
                case 3:
                case 5:
                case 6:
                  return "[ ] dddd, [] LT";
              }
            } else {
              if (this.day() === 2) {
                return "[] dddd, [] LT";
              } else {
                return "[] dddd, [] LT";
              }
            }
          },
          lastWeek: function(now2) {
            if (now2.week() !== this.week()) {
              switch (this.day()) {
                case 0:
                  return "[ ] dddd, [] LT";
                case 1:
                case 2:
                case 4:
                  return "[ ] dddd, [] LT";
                case 3:
                case 5:
                case 6:
                  return "[ ] dddd, [] LT";
              }
            } else {
              if (this.day() === 2) {
                return "[] dddd, [] LT";
              } else {
                return "[] dddd, [] LT";
              }
            }
          },
          sameElse: "L"
        },
        relativeTime: {
          future: " %s",
          past: "%s ",
          s: " ",
          ss: relativeTimeWithPlural,
          m: relativeTimeWithPlural,
          mm: relativeTimeWithPlural,
          h: "",
          hh: relativeTimeWithPlural,
          d: "",
          dd: relativeTimeWithPlural,
          w: "",
          ww: relativeTimeWithPlural,
          M: "",
          MM: relativeTimeWithPlural,
          y: "",
          yy: relativeTimeWithPlural
        },
        meridiemParse: /|||/i,
        isPM: function(input) {
          return /^(|)$/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 4) {
            return "";
          } else if (hour < 12) {
            return "";
          } else if (hour < 17) {
            return "";
          } else {
            return "";
          }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
        ordinal: function(number2, period) {
          switch (period) {
            case "M":
            case "d":
            case "DDD":
              return number2 + "-";
            case "D":
              return number2 + "-";
            case "w":
            case "W":
              return number2 + "-";
            default:
              return number2;
          }
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4
          // The week that contains Jan 4th is the first week of the year.
        }
      });
      return ru2;
    }));
  })();
  return ru$2.exports;
}
requireRu();
var tr$2 = { exports: {} };
var tr$1 = tr$2.exports;
var hasRequiredTr;
function requireTr() {
  if (hasRequiredTr) return tr$2.exports;
  hasRequiredTr = 1;
  (function(module, exports) {
    (function(global2, factory) {
      typeof commonjsRequire === "function" ? factory(requireMoment()) : factory(global2.moment);
    })(tr$1, (function(moment2) {
      var suffixes = {
        1: "'inci",
        5: "'inci",
        8: "'inci",
        70: "'inci",
        80: "'inci",
        2: "'nci",
        7: "'nci",
        20: "'nci",
        50: "'nci",
        3: "'nc",
        4: "'nc",
        100: "'nc",
        6: "'nc",
        9: "'uncu",
        10: "'uncu",
        30: "'uncu",
        60: "'nc",
        90: "'nc"
      };
      var tr2 = moment2.defineLocale("tr", {
        months: "Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk".split(
          "_"
        ),
        monthsShort: "Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara".split("_"),
        weekdays: "Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi".split(
          "_"
        ),
        weekdaysShort: "Paz_Pzt_Sal_ar_Per_Cum_Cmt".split("_"),
        weekdaysMin: "Pz_Pt_Sa_a_Pe_Cu_Ct".split("_"),
        meridiem: function(hours, minutes, isLower) {
          if (hours < 12) {
            return isLower ? "" : "";
          } else {
            return isLower ? "s" : "S";
          }
        },
        meridiemParse: /||s|S/,
        isPM: function(input) {
          return input === "s" || input === "S";
        },
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
          sameDay: "[bugn saat] LT",
          nextDay: "[yarn saat] LT",
          nextWeek: "[gelecek] dddd [saat] LT",
          lastDay: "[dn] LT",
          lastWeek: "[geen] dddd [saat] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "%s sonra",
          past: "%s nce",
          s: "birka saniye",
          ss: "%d saniye",
          m: "bir dakika",
          mm: "%d dakika",
          h: "bir saat",
          hh: "%d saat",
          d: "bir gn",
          dd: "%d gn",
          w: "bir hafta",
          ww: "%d hafta",
          M: "bir ay",
          MM: "%d ay",
          y: "bir yl",
          yy: "%d yl"
        },
        ordinal: function(number2, period) {
          switch (period) {
            case "d":
            case "D":
            case "Do":
            case "DD":
              return number2;
            default:
              if (number2 === 0) {
                return number2 + "'nc";
              }
              var a = number2 % 10, b = number2 % 100 - a, c = number2 >= 100 ? 100 : null;
              return number2 + (suffixes[a] || suffixes[b] || suffixes[c]);
          }
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 7th is the first week of the year.
        }
      });
      return tr2;
    }));
  })();
  return tr$2.exports;
}
requireTr();
var uk$2 = { exports: {} };
var uk$1 = uk$2.exports;
var hasRequiredUk;
function requireUk() {
  if (hasRequiredUk) return uk$2.exports;
  hasRequiredUk = 1;
  (function(module, exports) {
    (function(global2, factory) {
      typeof commonjsRequire === "function" ? factory(requireMoment()) : factory(global2.moment);
    })(uk$1, (function(moment2) {
      function plural(word, num) {
        var forms = word.split("_");
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
      }
      function relativeTimeWithPlural(number2, withoutSuffix, key) {
        var format = {
          ss: withoutSuffix ? "__" : "__",
          mm: withoutSuffix ? "__" : "__",
          hh: withoutSuffix ? "__" : "__",
          dd: "__",
          MM: "__",
          yy: "__"
        };
        if (key === "m") {
          return withoutSuffix ? "" : "";
        } else if (key === "h") {
          return withoutSuffix ? "" : "";
        } else {
          return number2 + " " + plural(format[key], +number2);
        }
      }
      function weekdaysCaseReplace(m, format) {
        var weekdays = {
          nominative: "______".split(
            "_"
          ),
          accusative: "______".split(
            "_"
          ),
          genitive: "______".split(
            "_"
          )
        }, nounCase;
        if (m === true) {
          return weekdays["nominative"].slice(1, 7).concat(weekdays["nominative"].slice(0, 1));
        }
        if (!m) {
          return weekdays["nominative"];
        }
        nounCase = /(\[[]\]) ?dddd/.test(format) ? "accusative" : /\[?(?:|)? ?\] ?dddd/.test(format) ? "genitive" : "nominative";
        return weekdays[nounCase][m.day()];
      }
      function processHoursFunction(str) {
        return function() {
          return str + "" + (this.hours() === 11 ? "" : "") + "] LT";
        };
      }
      var uk2 = moment2.defineLocale("uk", {
        months: {
          format: "___________".split(
            "_"
          ),
          standalone: "___________".split(
            "_"
          )
        },
        monthsShort: "___________".split(
          "_"
        ),
        weekdays: weekdaysCaseReplace,
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD.MM.YYYY",
          LL: "D MMMM YYYY .",
          LLL: "D MMMM YYYY ., HH:mm",
          LLLL: "dddd, D MMMM YYYY ., HH:mm"
        },
        calendar: {
          sameDay: processHoursFunction("[ "),
          nextDay: processHoursFunction("[ "),
          lastDay: processHoursFunction("[ "),
          nextWeek: processHoursFunction("[] dddd ["),
          lastWeek: function() {
            switch (this.day()) {
              case 0:
              case 3:
              case 5:
              case 6:
                return processHoursFunction("[] dddd [").call(this);
              case 1:
              case 2:
              case 4:
                return processHoursFunction("[] dddd [").call(this);
            }
          },
          sameElse: "L"
        },
        relativeTime: {
          future: " %s",
          past: "%s ",
          s: " ",
          ss: relativeTimeWithPlural,
          m: relativeTimeWithPlural,
          mm: relativeTimeWithPlural,
          h: "",
          hh: relativeTimeWithPlural,
          d: "",
          dd: relativeTimeWithPlural,
          M: "",
          MM: relativeTimeWithPlural,
          y: "",
          yy: relativeTimeWithPlural
        },
        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
        meridiemParse: /|||/,
        isPM: function(input) {
          return /^(|)$/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 4) {
            return "";
          } else if (hour < 12) {
            return "";
          } else if (hour < 17) {
            return "";
          } else {
            return "";
          }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
        ordinal: function(number2, period) {
          switch (period) {
            case "M":
            case "d":
            case "DDD":
            case "w":
            case "W":
              return number2 + "-";
            case "D":
              return number2 + "-";
            default:
              return number2;
          }
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7
          // The week that contains Jan 7th is the first week of the year.
        }
      });
      return uk2;
    }));
  })();
  return uk$2.exports;
}
requireUk();
var es_array_concat = {};
var globalThis_1;
var hasRequiredGlobalThis;
function requireGlobalThis() {
  if (hasRequiredGlobalThis) return globalThis_1;
  hasRequiredGlobalThis = 1;
  var check = function(it2) {
    return it2 && it2.Math === Math && it2;
  };
  globalThis_1 = // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || check(typeof globalThis_1 == "object" && globalThis_1) || // eslint-disable-next-line no-new-func -- fallback
  /* @__PURE__ */ (function() {
    return this;
  })() || Function("return this")();
  return globalThis_1;
}
var fails;
var hasRequiredFails;
function requireFails() {
  if (hasRequiredFails) return fails;
  hasRequiredFails = 1;
  fails = function(exec) {
    try {
      return !!exec();
    } catch (error) {
      return true;
    }
  };
  return fails;
}
var functionBindNative;
var hasRequiredFunctionBindNative;
function requireFunctionBindNative() {
  if (hasRequiredFunctionBindNative) return functionBindNative;
  hasRequiredFunctionBindNative = 1;
  var fails2 = requireFails();
  functionBindNative = !fails2(function() {
    var test = (function() {
    }).bind();
    return typeof test != "function" || test.hasOwnProperty("prototype");
  });
  return functionBindNative;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  var NATIVE_BIND = requireFunctionBindNative();
  var FunctionPrototype = Function.prototype;
  var apply = FunctionPrototype.apply;
  var call = FunctionPrototype.call;
  functionApply = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
    return call.apply(apply, arguments);
  });
  return functionApply;
}
var functionUncurryThis;
var hasRequiredFunctionUncurryThis;
function requireFunctionUncurryThis() {
  if (hasRequiredFunctionUncurryThis) return functionUncurryThis;
  hasRequiredFunctionUncurryThis = 1;
  var NATIVE_BIND = requireFunctionBindNative();
  var FunctionPrototype = Function.prototype;
  var call = FunctionPrototype.call;
  var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
  functionUncurryThis = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
    return function() {
      return call.apply(fn, arguments);
    };
  };
  return functionUncurryThis;
}
var classofRaw;
var hasRequiredClassofRaw;
function requireClassofRaw() {
  if (hasRequiredClassofRaw) return classofRaw;
  hasRequiredClassofRaw = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var toString2 = uncurryThis({}.toString);
  var stringSlice = uncurryThis("".slice);
  classofRaw = function(it2) {
    return stringSlice(toString2(it2), 8, -1);
  };
  return classofRaw;
}
var functionUncurryThisClause;
var hasRequiredFunctionUncurryThisClause;
function requireFunctionUncurryThisClause() {
  if (hasRequiredFunctionUncurryThisClause) return functionUncurryThisClause;
  hasRequiredFunctionUncurryThisClause = 1;
  var classofRaw2 = requireClassofRaw();
  var uncurryThis = requireFunctionUncurryThis();
  functionUncurryThisClause = function(fn) {
    if (classofRaw2(fn) === "Function") return uncurryThis(fn);
  };
  return functionUncurryThisClause;
}
var isCallable;
var hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable) return isCallable;
  hasRequiredIsCallable = 1;
  var documentAll = typeof document == "object" && document.all;
  isCallable = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
    return typeof argument == "function" || argument === documentAll;
  } : function(argument) {
    return typeof argument == "function";
  };
  return isCallable;
}
var objectGetOwnPropertyDescriptor = {};
var descriptors;
var hasRequiredDescriptors;
function requireDescriptors() {
  if (hasRequiredDescriptors) return descriptors;
  hasRequiredDescriptors = 1;
  var fails2 = requireFails();
  descriptors = !fails2(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] !== 7;
  });
  return descriptors;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  var NATIVE_BIND = requireFunctionBindNative();
  var call = Function.prototype.call;
  functionCall = NATIVE_BIND ? call.bind(call) : function() {
    return call.apply(call, arguments);
  };
  return functionCall;
}
var objectPropertyIsEnumerable = {};
var hasRequiredObjectPropertyIsEnumerable;
function requireObjectPropertyIsEnumerable() {
  if (hasRequiredObjectPropertyIsEnumerable) return objectPropertyIsEnumerable;
  hasRequiredObjectPropertyIsEnumerable = 1;
  var $propertyIsEnumerable = {}.propertyIsEnumerable;
  var getOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;
  var NASHORN_BUG = getOwnPropertyDescriptor2 && !$propertyIsEnumerable.call({ 1: 2 }, 1);
  objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
    var descriptor = getOwnPropertyDescriptor2(this, V);
    return !!descriptor && descriptor.enumerable;
  } : $propertyIsEnumerable;
  return objectPropertyIsEnumerable;
}
var createPropertyDescriptor;
var hasRequiredCreatePropertyDescriptor;
function requireCreatePropertyDescriptor() {
  if (hasRequiredCreatePropertyDescriptor) return createPropertyDescriptor;
  hasRequiredCreatePropertyDescriptor = 1;
  createPropertyDescriptor = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value
    };
  };
  return createPropertyDescriptor;
}
var indexedObject;
var hasRequiredIndexedObject;
function requireIndexedObject() {
  if (hasRequiredIndexedObject) return indexedObject;
  hasRequiredIndexedObject = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var fails2 = requireFails();
  var classof2 = requireClassofRaw();
  var $Object = Object;
  var split = uncurryThis("".split);
  indexedObject = fails2(function() {
    return !$Object("z").propertyIsEnumerable(0);
  }) ? function(it2) {
    return classof2(it2) === "String" ? split(it2, "") : $Object(it2);
  } : $Object;
  return indexedObject;
}
var isNullOrUndefined;
var hasRequiredIsNullOrUndefined;
function requireIsNullOrUndefined() {
  if (hasRequiredIsNullOrUndefined) return isNullOrUndefined;
  hasRequiredIsNullOrUndefined = 1;
  isNullOrUndefined = function(it2) {
    return it2 === null || it2 === void 0;
  };
  return isNullOrUndefined;
}
var requireObjectCoercible;
var hasRequiredRequireObjectCoercible;
function requireRequireObjectCoercible() {
  if (hasRequiredRequireObjectCoercible) return requireObjectCoercible;
  hasRequiredRequireObjectCoercible = 1;
  var isNullOrUndefined2 = requireIsNullOrUndefined();
  var $TypeError = TypeError;
  requireObjectCoercible = function(it2) {
    if (isNullOrUndefined2(it2)) throw new $TypeError("Can't call method on " + it2);
    return it2;
  };
  return requireObjectCoercible;
}
var toIndexedObject;
var hasRequiredToIndexedObject;
function requireToIndexedObject() {
  if (hasRequiredToIndexedObject) return toIndexedObject;
  hasRequiredToIndexedObject = 1;
  var IndexedObject = requireIndexedObject();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  toIndexedObject = function(it2) {
    return IndexedObject(requireObjectCoercible2(it2));
  };
  return toIndexedObject;
}
var isObject$1;
var hasRequiredIsObject;
function requireIsObject() {
  if (hasRequiredIsObject) return isObject$1;
  hasRequiredIsObject = 1;
  var isCallable2 = requireIsCallable();
  isObject$1 = function(it2) {
    return typeof it2 == "object" ? it2 !== null : isCallable2(it2);
  };
  return isObject$1;
}
var path;
var hasRequiredPath;
function requirePath() {
  if (hasRequiredPath) return path;
  hasRequiredPath = 1;
  path = {};
  return path;
}
var getBuiltIn;
var hasRequiredGetBuiltIn;
function requireGetBuiltIn() {
  if (hasRequiredGetBuiltIn) return getBuiltIn;
  hasRequiredGetBuiltIn = 1;
  var path2 = requirePath();
  var globalThis2 = requireGlobalThis();
  var isCallable2 = requireIsCallable();
  var aFunction = function(variable) {
    return isCallable2(variable) ? variable : void 0;
  };
  getBuiltIn = function(namespace, method) {
    return arguments.length < 2 ? aFunction(path2[namespace]) || aFunction(globalThis2[namespace]) : path2[namespace] && path2[namespace][method] || globalThis2[namespace] && globalThis2[namespace][method];
  };
  return getBuiltIn;
}
var objectIsPrototypeOf;
var hasRequiredObjectIsPrototypeOf;
function requireObjectIsPrototypeOf() {
  if (hasRequiredObjectIsPrototypeOf) return objectIsPrototypeOf;
  hasRequiredObjectIsPrototypeOf = 1;
  var uncurryThis = requireFunctionUncurryThis();
  objectIsPrototypeOf = uncurryThis({}.isPrototypeOf);
  return objectIsPrototypeOf;
}
var environmentUserAgent;
var hasRequiredEnvironmentUserAgent;
function requireEnvironmentUserAgent() {
  if (hasRequiredEnvironmentUserAgent) return environmentUserAgent;
  hasRequiredEnvironmentUserAgent = 1;
  var globalThis2 = requireGlobalThis();
  var navigator2 = globalThis2.navigator;
  var userAgent = navigator2 && navigator2.userAgent;
  environmentUserAgent = userAgent ? String(userAgent) : "";
  return environmentUserAgent;
}
var environmentV8Version;
var hasRequiredEnvironmentV8Version;
function requireEnvironmentV8Version() {
  if (hasRequiredEnvironmentV8Version) return environmentV8Version;
  hasRequiredEnvironmentV8Version = 1;
  var globalThis2 = requireGlobalThis();
  var userAgent = requireEnvironmentUserAgent();
  var process = globalThis2.process;
  var Deno2 = globalThis2.Deno;
  var versions = process && process.versions || Deno2 && Deno2.version;
  var v8 = versions && versions.v8;
  var match, version;
  if (v8) {
    match = v8.split(".");
    version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
  }
  if (!version && userAgent) {
    match = userAgent.match(/Edge\/(\d+)/);
    if (!match || match[1] >= 74) {
      match = userAgent.match(/Chrome\/(\d+)/);
      if (match) version = +match[1];
    }
  }
  environmentV8Version = version;
  return environmentV8Version;
}
var symbolConstructorDetection;
var hasRequiredSymbolConstructorDetection;
function requireSymbolConstructorDetection() {
  if (hasRequiredSymbolConstructorDetection) return symbolConstructorDetection;
  hasRequiredSymbolConstructorDetection = 1;
  var V8_VERSION = requireEnvironmentV8Version();
  var fails2 = requireFails();
  var globalThis2 = requireGlobalThis();
  var $String = globalThis2.String;
  symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails2(function() {
    var symbol2 = /* @__PURE__ */ Symbol("symbol detection");
    return !$String(symbol2) || !(Object(symbol2) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
  });
  return symbolConstructorDetection;
}
var useSymbolAsUid;
var hasRequiredUseSymbolAsUid;
function requireUseSymbolAsUid() {
  if (hasRequiredUseSymbolAsUid) return useSymbolAsUid;
  hasRequiredUseSymbolAsUid = 1;
  var NATIVE_SYMBOL = requireSymbolConstructorDetection();
  useSymbolAsUid = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
  return useSymbolAsUid;
}
var isSymbol;
var hasRequiredIsSymbol;
function requireIsSymbol() {
  if (hasRequiredIsSymbol) return isSymbol;
  hasRequiredIsSymbol = 1;
  var getBuiltIn2 = requireGetBuiltIn();
  var isCallable2 = requireIsCallable();
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var USE_SYMBOL_AS_UID = requireUseSymbolAsUid();
  var $Object = Object;
  isSymbol = USE_SYMBOL_AS_UID ? function(it2) {
    return typeof it2 == "symbol";
  } : function(it2) {
    var $Symbol = getBuiltIn2("Symbol");
    return isCallable2($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it2));
  };
  return isSymbol;
}
var tryToString;
var hasRequiredTryToString;
function requireTryToString() {
  if (hasRequiredTryToString) return tryToString;
  hasRequiredTryToString = 1;
  var $String = String;
  tryToString = function(argument) {
    try {
      return $String(argument);
    } catch (error) {
      return "Object";
    }
  };
  return tryToString;
}
var aCallable;
var hasRequiredACallable;
function requireACallable() {
  if (hasRequiredACallable) return aCallable;
  hasRequiredACallable = 1;
  var isCallable2 = requireIsCallable();
  var tryToString2 = requireTryToString();
  var $TypeError = TypeError;
  aCallable = function(argument) {
    if (isCallable2(argument)) return argument;
    throw new $TypeError(tryToString2(argument) + " is not a function");
  };
  return aCallable;
}
var getMethod;
var hasRequiredGetMethod;
function requireGetMethod() {
  if (hasRequiredGetMethod) return getMethod;
  hasRequiredGetMethod = 1;
  var aCallable2 = requireACallable();
  var isNullOrUndefined2 = requireIsNullOrUndefined();
  getMethod = function(V, P) {
    var func = V[P];
    return isNullOrUndefined2(func) ? void 0 : aCallable2(func);
  };
  return getMethod;
}
var ordinaryToPrimitive;
var hasRequiredOrdinaryToPrimitive;
function requireOrdinaryToPrimitive() {
  if (hasRequiredOrdinaryToPrimitive) return ordinaryToPrimitive;
  hasRequiredOrdinaryToPrimitive = 1;
  var call = requireFunctionCall();
  var isCallable2 = requireIsCallable();
  var isObject2 = requireIsObject();
  var $TypeError = TypeError;
  ordinaryToPrimitive = function(input, pref) {
    var fn, val;
    if (pref === "string" && isCallable2(fn = input.toString) && !isObject2(val = call(fn, input))) return val;
    if (isCallable2(fn = input.valueOf) && !isObject2(val = call(fn, input))) return val;
    if (pref !== "string" && isCallable2(fn = input.toString) && !isObject2(val = call(fn, input))) return val;
    throw new $TypeError("Can't convert object to primitive value");
  };
  return ordinaryToPrimitive;
}
var sharedStore = { exports: {} };
var isPure;
var hasRequiredIsPure;
function requireIsPure() {
  if (hasRequiredIsPure) return isPure;
  hasRequiredIsPure = 1;
  isPure = true;
  return isPure;
}
var defineGlobalProperty;
var hasRequiredDefineGlobalProperty;
function requireDefineGlobalProperty() {
  if (hasRequiredDefineGlobalProperty) return defineGlobalProperty;
  hasRequiredDefineGlobalProperty = 1;
  var globalThis2 = requireGlobalThis();
  var defineProperty2 = Object.defineProperty;
  defineGlobalProperty = function(key, value) {
    try {
      defineProperty2(globalThis2, key, { value, configurable: true, writable: true });
    } catch (error) {
      globalThis2[key] = value;
    }
    return value;
  };
  return defineGlobalProperty;
}
var hasRequiredSharedStore;
function requireSharedStore() {
  if (hasRequiredSharedStore) return sharedStore.exports;
  hasRequiredSharedStore = 1;
  var IS_PURE = requireIsPure();
  var globalThis2 = requireGlobalThis();
  var defineGlobalProperty2 = requireDefineGlobalProperty();
  var SHARED = "__core-js_shared__";
  var store = sharedStore.exports = globalThis2[SHARED] || defineGlobalProperty2(SHARED, {});
  (store.versions || (store.versions = [])).push({
    version: "3.44.0",
    mode: IS_PURE ? "pure" : "global",
    copyright: " 2014-2025 Denis Pushkarev (zloirock.ru)",
    license: "https://github.com/zloirock/core-js/blob/v3.44.0/LICENSE",
    source: "https://github.com/zloirock/core-js"
  });
  return sharedStore.exports;
}
var shared;
var hasRequiredShared;
function requireShared() {
  if (hasRequiredShared) return shared;
  hasRequiredShared = 1;
  var store = requireSharedStore();
  shared = function(key, value) {
    return store[key] || (store[key] = value || {});
  };
  return shared;
}
var toObject;
var hasRequiredToObject;
function requireToObject() {
  if (hasRequiredToObject) return toObject;
  hasRequiredToObject = 1;
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var $Object = Object;
  toObject = function(argument) {
    return $Object(requireObjectCoercible2(argument));
  };
  return toObject;
}
var hasOwnProperty_1;
var hasRequiredHasOwnProperty;
function requireHasOwnProperty() {
  if (hasRequiredHasOwnProperty) return hasOwnProperty_1;
  hasRequiredHasOwnProperty = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var toObject2 = requireToObject();
  var hasOwnProperty = uncurryThis({}.hasOwnProperty);
  hasOwnProperty_1 = Object.hasOwn || function hasOwn(it2, key) {
    return hasOwnProperty(toObject2(it2), key);
  };
  return hasOwnProperty_1;
}
var uid;
var hasRequiredUid;
function requireUid() {
  if (hasRequiredUid) return uid;
  hasRequiredUid = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var id = 0;
  var postfix = Math.random();
  var toString2 = uncurryThis(1.1.toString);
  uid = function(key) {
    return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString2(++id + postfix, 36);
  };
  return uid;
}
var wellKnownSymbol;
var hasRequiredWellKnownSymbol;
function requireWellKnownSymbol() {
  if (hasRequiredWellKnownSymbol) return wellKnownSymbol;
  hasRequiredWellKnownSymbol = 1;
  var globalThis2 = requireGlobalThis();
  var shared2 = requireShared();
  var hasOwn = requireHasOwnProperty();
  var uid2 = requireUid();
  var NATIVE_SYMBOL = requireSymbolConstructorDetection();
  var USE_SYMBOL_AS_UID = requireUseSymbolAsUid();
  var Symbol2 = globalThis2.Symbol;
  var WellKnownSymbolsStore = shared2("wks");
  var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid2;
  wellKnownSymbol = function(name) {
    if (!hasOwn(WellKnownSymbolsStore, name)) {
      WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol2, name) ? Symbol2[name] : createWellKnownSymbol("Symbol." + name);
    }
    return WellKnownSymbolsStore[name];
  };
  return wellKnownSymbol;
}
var toPrimitive$6;
var hasRequiredToPrimitive$5;
function requireToPrimitive$5() {
  if (hasRequiredToPrimitive$5) return toPrimitive$6;
  hasRequiredToPrimitive$5 = 1;
  var call = requireFunctionCall();
  var isObject2 = requireIsObject();
  var isSymbol2 = requireIsSymbol();
  var getMethod2 = requireGetMethod();
  var ordinaryToPrimitive2 = requireOrdinaryToPrimitive();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var $TypeError = TypeError;
  var TO_PRIMITIVE = wellKnownSymbol2("toPrimitive");
  toPrimitive$6 = function(input, pref) {
    if (!isObject2(input) || isSymbol2(input)) return input;
    var exoticToPrim = getMethod2(input, TO_PRIMITIVE);
    var result;
    if (exoticToPrim) {
      if (pref === void 0) pref = "default";
      result = call(exoticToPrim, input, pref);
      if (!isObject2(result) || isSymbol2(result)) return result;
      throw new $TypeError("Can't convert object to primitive value");
    }
    if (pref === void 0) pref = "number";
    return ordinaryToPrimitive2(input, pref);
  };
  return toPrimitive$6;
}
var toPropertyKey$1;
var hasRequiredToPropertyKey;
function requireToPropertyKey() {
  if (hasRequiredToPropertyKey) return toPropertyKey$1;
  hasRequiredToPropertyKey = 1;
  var toPrimitive2 = requireToPrimitive$5();
  var isSymbol2 = requireIsSymbol();
  toPropertyKey$1 = function(argument) {
    var key = toPrimitive2(argument, "string");
    return isSymbol2(key) ? key : key + "";
  };
  return toPropertyKey$1;
}
var documentCreateElement;
var hasRequiredDocumentCreateElement;
function requireDocumentCreateElement() {
  if (hasRequiredDocumentCreateElement) return documentCreateElement;
  hasRequiredDocumentCreateElement = 1;
  var globalThis2 = requireGlobalThis();
  var isObject2 = requireIsObject();
  var document2 = globalThis2.document;
  var EXISTS = isObject2(document2) && isObject2(document2.createElement);
  documentCreateElement = function(it2) {
    return EXISTS ? document2.createElement(it2) : {};
  };
  return documentCreateElement;
}
var ie8DomDefine;
var hasRequiredIe8DomDefine;
function requireIe8DomDefine() {
  if (hasRequiredIe8DomDefine) return ie8DomDefine;
  hasRequiredIe8DomDefine = 1;
  var DESCRIPTORS = requireDescriptors();
  var fails2 = requireFails();
  var createElement = requireDocumentCreateElement();
  ie8DomDefine = !DESCRIPTORS && !fails2(function() {
    return Object.defineProperty(createElement("div"), "a", {
      get: function() {
        return 7;
      }
    }).a !== 7;
  });
  return ie8DomDefine;
}
var hasRequiredObjectGetOwnPropertyDescriptor;
function requireObjectGetOwnPropertyDescriptor() {
  if (hasRequiredObjectGetOwnPropertyDescriptor) return objectGetOwnPropertyDescriptor;
  hasRequiredObjectGetOwnPropertyDescriptor = 1;
  var DESCRIPTORS = requireDescriptors();
  var call = requireFunctionCall();
  var propertyIsEnumerableModule = requireObjectPropertyIsEnumerable();
  var createPropertyDescriptor2 = requireCreatePropertyDescriptor();
  var toIndexedObject2 = requireToIndexedObject();
  var toPropertyKey2 = requireToPropertyKey();
  var hasOwn = requireHasOwnProperty();
  var IE8_DOM_DEFINE = requireIe8DomDefine();
  var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  objectGetOwnPropertyDescriptor.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor2(O, P) {
    O = toIndexedObject2(O);
    P = toPropertyKey2(P);
    if (IE8_DOM_DEFINE) try {
      return $getOwnPropertyDescriptor(O, P);
    } catch (error) {
    }
    if (hasOwn(O, P)) return createPropertyDescriptor2(!call(propertyIsEnumerableModule.f, O, P), O[P]);
  };
  return objectGetOwnPropertyDescriptor;
}
var isForced_1;
var hasRequiredIsForced;
function requireIsForced() {
  if (hasRequiredIsForced) return isForced_1;
  hasRequiredIsForced = 1;
  var fails2 = requireFails();
  var isCallable2 = requireIsCallable();
  var replacement = /#|\.prototype\./;
  var isForced = function(feature, detection) {
    var value = data[normalize(feature)];
    return value === POLYFILL ? true : value === NATIVE ? false : isCallable2(detection) ? fails2(detection) : !!detection;
  };
  var normalize = isForced.normalize = function(string2) {
    return String(string2).replace(replacement, ".").toLowerCase();
  };
  var data = isForced.data = {};
  var NATIVE = isForced.NATIVE = "N";
  var POLYFILL = isForced.POLYFILL = "P";
  isForced_1 = isForced;
  return isForced_1;
}
var functionBindContext;
var hasRequiredFunctionBindContext;
function requireFunctionBindContext() {
  if (hasRequiredFunctionBindContext) return functionBindContext;
  hasRequiredFunctionBindContext = 1;
  var uncurryThis = requireFunctionUncurryThisClause();
  var aCallable2 = requireACallable();
  var NATIVE_BIND = requireFunctionBindNative();
  var bind2 = uncurryThis(uncurryThis.bind);
  functionBindContext = function(fn, that) {
    aCallable2(fn);
    return that === void 0 ? fn : NATIVE_BIND ? bind2(fn, that) : function() {
      return fn.apply(that, arguments);
    };
  };
  return functionBindContext;
}
var objectDefineProperty = {};
var v8PrototypeDefineBug;
var hasRequiredV8PrototypeDefineBug;
function requireV8PrototypeDefineBug() {
  if (hasRequiredV8PrototypeDefineBug) return v8PrototypeDefineBug;
  hasRequiredV8PrototypeDefineBug = 1;
  var DESCRIPTORS = requireDescriptors();
  var fails2 = requireFails();
  v8PrototypeDefineBug = DESCRIPTORS && fails2(function() {
    return Object.defineProperty(function() {
    }, "prototype", {
      value: 42,
      writable: false
    }).prototype !== 42;
  });
  return v8PrototypeDefineBug;
}
var anObject;
var hasRequiredAnObject;
function requireAnObject() {
  if (hasRequiredAnObject) return anObject;
  hasRequiredAnObject = 1;
  var isObject2 = requireIsObject();
  var $String = String;
  var $TypeError = TypeError;
  anObject = function(argument) {
    if (isObject2(argument)) return argument;
    throw new $TypeError($String(argument) + " is not an object");
  };
  return anObject;
}
var hasRequiredObjectDefineProperty;
function requireObjectDefineProperty() {
  if (hasRequiredObjectDefineProperty) return objectDefineProperty;
  hasRequiredObjectDefineProperty = 1;
  var DESCRIPTORS = requireDescriptors();
  var IE8_DOM_DEFINE = requireIe8DomDefine();
  var V8_PROTOTYPE_DEFINE_BUG = requireV8PrototypeDefineBug();
  var anObject2 = requireAnObject();
  var toPropertyKey2 = requireToPropertyKey();
  var $TypeError = TypeError;
  var $defineProperty = Object.defineProperty;
  var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var ENUMERABLE = "enumerable";
  var CONFIGURABLE = "configurable";
  var WRITABLE = "writable";
  objectDefineProperty.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty2(O, P, Attributes) {
    anObject2(O);
    P = toPropertyKey2(P);
    anObject2(Attributes);
    if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
      var current = $getOwnPropertyDescriptor(O, P);
      if (current && current[WRITABLE]) {
        O[P] = Attributes.value;
        Attributes = {
          configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
          enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
          writable: false
        };
      }
    }
    return $defineProperty(O, P, Attributes);
  } : $defineProperty : function defineProperty2(O, P, Attributes) {
    anObject2(O);
    P = toPropertyKey2(P);
    anObject2(Attributes);
    if (IE8_DOM_DEFINE) try {
      return $defineProperty(O, P, Attributes);
    } catch (error) {
    }
    if ("get" in Attributes || "set" in Attributes) throw new $TypeError("Accessors not supported");
    if ("value" in Attributes) O[P] = Attributes.value;
    return O;
  };
  return objectDefineProperty;
}
var createNonEnumerableProperty;
var hasRequiredCreateNonEnumerableProperty;
function requireCreateNonEnumerableProperty() {
  if (hasRequiredCreateNonEnumerableProperty) return createNonEnumerableProperty;
  hasRequiredCreateNonEnumerableProperty = 1;
  var DESCRIPTORS = requireDescriptors();
  var definePropertyModule = requireObjectDefineProperty();
  var createPropertyDescriptor2 = requireCreatePropertyDescriptor();
  createNonEnumerableProperty = DESCRIPTORS ? function(object2, key, value) {
    return definePropertyModule.f(object2, key, createPropertyDescriptor2(1, value));
  } : function(object2, key, value) {
    object2[key] = value;
    return object2;
  };
  return createNonEnumerableProperty;
}
var _export;
var hasRequired_export;
function require_export() {
  if (hasRequired_export) return _export;
  hasRequired_export = 1;
  var globalThis2 = requireGlobalThis();
  var apply = requireFunctionApply();
  var uncurryThis = requireFunctionUncurryThisClause();
  var isCallable2 = requireIsCallable();
  var getOwnPropertyDescriptor2 = requireObjectGetOwnPropertyDescriptor().f;
  var isForced = requireIsForced();
  var path2 = requirePath();
  var bind2 = requireFunctionBindContext();
  var createNonEnumerableProperty2 = requireCreateNonEnumerableProperty();
  var hasOwn = requireHasOwnProperty();
  var wrapConstructor = function(NativeConstructor) {
    var Wrapper = function(a, b, c) {
      if (this instanceof Wrapper) {
        switch (arguments.length) {
          case 0:
            return new NativeConstructor();
          case 1:
            return new NativeConstructor(a);
          case 2:
            return new NativeConstructor(a, b);
        }
        return new NativeConstructor(a, b, c);
      }
      return apply(NativeConstructor, this, arguments);
    };
    Wrapper.prototype = NativeConstructor.prototype;
    return Wrapper;
  };
  _export = function(options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var PROTO = options.proto;
    var nativeSource = GLOBAL ? globalThis2 : STATIC ? globalThis2[TARGET] : globalThis2[TARGET] && globalThis2[TARGET].prototype;
    var target = GLOBAL ? path2 : path2[TARGET] || createNonEnumerableProperty2(path2, TARGET, {})[TARGET];
    var targetPrototype = target.prototype;
    var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
    var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;
    for (key in source) {
      FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
      USE_NATIVE = !FORCED && nativeSource && hasOwn(nativeSource, key);
      targetProperty = target[key];
      if (USE_NATIVE) if (options.dontCallGetSet) {
        descriptor = getOwnPropertyDescriptor2(nativeSource, key);
        nativeProperty = descriptor && descriptor.value;
      } else nativeProperty = nativeSource[key];
      sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source[key];
      if (!FORCED && !PROTO && typeof targetProperty == typeof sourceProperty) continue;
      if (options.bind && USE_NATIVE) resultProperty = bind2(sourceProperty, globalThis2);
      else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);
      else if (PROTO && isCallable2(sourceProperty)) resultProperty = uncurryThis(sourceProperty);
      else resultProperty = sourceProperty;
      if (options.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty2(resultProperty, "sham", true);
      }
      createNonEnumerableProperty2(target, key, resultProperty);
      if (PROTO) {
        VIRTUAL_PROTOTYPE = TARGET + "Prototype";
        if (!hasOwn(path2, VIRTUAL_PROTOTYPE)) {
          createNonEnumerableProperty2(path2, VIRTUAL_PROTOTYPE, {});
        }
        createNonEnumerableProperty2(path2[VIRTUAL_PROTOTYPE], key, sourceProperty);
        if (options.real && targetPrototype && (FORCED || !targetPrototype[key])) {
          createNonEnumerableProperty2(targetPrototype, key, sourceProperty);
        }
      }
    }
  };
  return _export;
}
var isArray$3;
var hasRequiredIsArray$3;
function requireIsArray$3() {
  if (hasRequiredIsArray$3) return isArray$3;
  hasRequiredIsArray$3 = 1;
  var classof2 = requireClassofRaw();
  isArray$3 = Array.isArray || function isArray2(argument) {
    return classof2(argument) === "Array";
  };
  return isArray$3;
}
var mathTrunc;
var hasRequiredMathTrunc;
function requireMathTrunc() {
  if (hasRequiredMathTrunc) return mathTrunc;
  hasRequiredMathTrunc = 1;
  var ceil = Math.ceil;
  var floor = Math.floor;
  mathTrunc = Math.trunc || function trunc(x) {
    var n = +x;
    return (n > 0 ? floor : ceil)(n);
  };
  return mathTrunc;
}
var toIntegerOrInfinity;
var hasRequiredToIntegerOrInfinity;
function requireToIntegerOrInfinity() {
  if (hasRequiredToIntegerOrInfinity) return toIntegerOrInfinity;
  hasRequiredToIntegerOrInfinity = 1;
  var trunc = requireMathTrunc();
  toIntegerOrInfinity = function(argument) {
    var number2 = +argument;
    return number2 !== number2 || number2 === 0 ? 0 : trunc(number2);
  };
  return toIntegerOrInfinity;
}
var toLength;
var hasRequiredToLength;
function requireToLength() {
  if (hasRequiredToLength) return toLength;
  hasRequiredToLength = 1;
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var min = Math.min;
  toLength = function(argument) {
    var len = toIntegerOrInfinity2(argument);
    return len > 0 ? min(len, 9007199254740991) : 0;
  };
  return toLength;
}
var lengthOfArrayLike;
var hasRequiredLengthOfArrayLike;
function requireLengthOfArrayLike() {
  if (hasRequiredLengthOfArrayLike) return lengthOfArrayLike;
  hasRequiredLengthOfArrayLike = 1;
  var toLength2 = requireToLength();
  lengthOfArrayLike = function(obj) {
    return toLength2(obj.length);
  };
  return lengthOfArrayLike;
}
var doesNotExceedSafeInteger;
var hasRequiredDoesNotExceedSafeInteger;
function requireDoesNotExceedSafeInteger() {
  if (hasRequiredDoesNotExceedSafeInteger) return doesNotExceedSafeInteger;
  hasRequiredDoesNotExceedSafeInteger = 1;
  var $TypeError = TypeError;
  var MAX_SAFE_INTEGER = 9007199254740991;
  doesNotExceedSafeInteger = function(it2) {
    if (it2 > MAX_SAFE_INTEGER) throw $TypeError("Maximum allowed index exceeded");
    return it2;
  };
  return doesNotExceedSafeInteger;
}
var createProperty;
var hasRequiredCreateProperty;
function requireCreateProperty() {
  if (hasRequiredCreateProperty) return createProperty;
  hasRequiredCreateProperty = 1;
  var DESCRIPTORS = requireDescriptors();
  var definePropertyModule = requireObjectDefineProperty();
  var createPropertyDescriptor2 = requireCreatePropertyDescriptor();
  createProperty = function(object2, key, value) {
    if (DESCRIPTORS) definePropertyModule.f(object2, key, createPropertyDescriptor2(0, value));
    else object2[key] = value;
  };
  return createProperty;
}
var toStringTagSupport;
var hasRequiredToStringTagSupport;
function requireToStringTagSupport() {
  if (hasRequiredToStringTagSupport) return toStringTagSupport;
  hasRequiredToStringTagSupport = 1;
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var TO_STRING_TAG = wellKnownSymbol2("toStringTag");
  var test = {};
  test[TO_STRING_TAG] = "z";
  toStringTagSupport = String(test) === "[object z]";
  return toStringTagSupport;
}
var classof;
var hasRequiredClassof;
function requireClassof() {
  if (hasRequiredClassof) return classof;
  hasRequiredClassof = 1;
  var TO_STRING_TAG_SUPPORT = requireToStringTagSupport();
  var isCallable2 = requireIsCallable();
  var classofRaw2 = requireClassofRaw();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var TO_STRING_TAG = wellKnownSymbol2("toStringTag");
  var $Object = Object;
  var CORRECT_ARGUMENTS = classofRaw2(/* @__PURE__ */ (function() {
    return arguments;
  })()) === "Arguments";
  var tryGet = function(it2, key) {
    try {
      return it2[key];
    } catch (error) {
    }
  };
  classof = TO_STRING_TAG_SUPPORT ? classofRaw2 : function(it2) {
    var O, tag, result;
    return it2 === void 0 ? "Undefined" : it2 === null ? "Null" : typeof (tag = tryGet(O = $Object(it2), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw2(O) : (result = classofRaw2(O)) === "Object" && isCallable2(O.callee) ? "Arguments" : result;
  };
  return classof;
}
var inspectSource;
var hasRequiredInspectSource;
function requireInspectSource() {
  if (hasRequiredInspectSource) return inspectSource;
  hasRequiredInspectSource = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var isCallable2 = requireIsCallable();
  var store = requireSharedStore();
  var functionToString = uncurryThis(Function.toString);
  if (!isCallable2(store.inspectSource)) {
    store.inspectSource = function(it2) {
      return functionToString(it2);
    };
  }
  inspectSource = store.inspectSource;
  return inspectSource;
}
var isConstructor;
var hasRequiredIsConstructor;
function requireIsConstructor() {
  if (hasRequiredIsConstructor) return isConstructor;
  hasRequiredIsConstructor = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var fails2 = requireFails();
  var isCallable2 = requireIsCallable();
  var classof2 = requireClassof();
  var getBuiltIn2 = requireGetBuiltIn();
  var inspectSource2 = requireInspectSource();
  var noop = function() {
  };
  var construct = getBuiltIn2("Reflect", "construct");
  var constructorRegExp = /^\s*(?:class|function)\b/;
  var exec = uncurryThis(constructorRegExp.exec);
  var INCORRECT_TO_STRING = !constructorRegExp.test(noop);
  var isConstructorModern = function isConstructor2(argument) {
    if (!isCallable2(argument)) return false;
    try {
      construct(noop, [], argument);
      return true;
    } catch (error) {
      return false;
    }
  };
  var isConstructorLegacy = function isConstructor2(argument) {
    if (!isCallable2(argument)) return false;
    switch (classof2(argument)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return false;
    }
    try {
      return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource2(argument));
    } catch (error) {
      return true;
    }
  };
  isConstructorLegacy.sham = true;
  isConstructor = !construct || fails2(function() {
    var called;
    return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
      called = true;
    }) || called;
  }) ? isConstructorLegacy : isConstructorModern;
  return isConstructor;
}
var arraySpeciesConstructor;
var hasRequiredArraySpeciesConstructor;
function requireArraySpeciesConstructor() {
  if (hasRequiredArraySpeciesConstructor) return arraySpeciesConstructor;
  hasRequiredArraySpeciesConstructor = 1;
  var isArray2 = requireIsArray$3();
  var isConstructor2 = requireIsConstructor();
  var isObject2 = requireIsObject();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var SPECIES = wellKnownSymbol2("species");
  var $Array = Array;
  arraySpeciesConstructor = function(originalArray) {
    var C;
    if (isArray2(originalArray)) {
      C = originalArray.constructor;
      if (isConstructor2(C) && (C === $Array || isArray2(C.prototype))) C = void 0;
      else if (isObject2(C)) {
        C = C[SPECIES];
        if (C === null) C = void 0;
      }
    }
    return C === void 0 ? $Array : C;
  };
  return arraySpeciesConstructor;
}
var arraySpeciesCreate;
var hasRequiredArraySpeciesCreate;
function requireArraySpeciesCreate() {
  if (hasRequiredArraySpeciesCreate) return arraySpeciesCreate;
  hasRequiredArraySpeciesCreate = 1;
  var arraySpeciesConstructor2 = requireArraySpeciesConstructor();
  arraySpeciesCreate = function(originalArray, length) {
    return new (arraySpeciesConstructor2(originalArray))(length === 0 ? 0 : length);
  };
  return arraySpeciesCreate;
}
var arrayMethodHasSpeciesSupport;
var hasRequiredArrayMethodHasSpeciesSupport;
function requireArrayMethodHasSpeciesSupport() {
  if (hasRequiredArrayMethodHasSpeciesSupport) return arrayMethodHasSpeciesSupport;
  hasRequiredArrayMethodHasSpeciesSupport = 1;
  var fails2 = requireFails();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var V8_VERSION = requireEnvironmentV8Version();
  var SPECIES = wellKnownSymbol2("species");
  arrayMethodHasSpeciesSupport = function(METHOD_NAME) {
    return V8_VERSION >= 51 || !fails2(function() {
      var array2 = [];
      var constructor = array2.constructor = {};
      constructor[SPECIES] = function() {
        return { foo: 1 };
      };
      return array2[METHOD_NAME](Boolean).foo !== 1;
    });
  };
  return arrayMethodHasSpeciesSupport;
}
var hasRequiredEs_array_concat;
function requireEs_array_concat() {
  if (hasRequiredEs_array_concat) return es_array_concat;
  hasRequiredEs_array_concat = 1;
  var $ = require_export();
  var fails2 = requireFails();
  var isArray2 = requireIsArray$3();
  var isObject2 = requireIsObject();
  var toObject2 = requireToObject();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var doesNotExceedSafeInteger2 = requireDoesNotExceedSafeInteger();
  var createProperty2 = requireCreateProperty();
  var arraySpeciesCreate2 = requireArraySpeciesCreate();
  var arrayMethodHasSpeciesSupport2 = requireArrayMethodHasSpeciesSupport();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var V8_VERSION = requireEnvironmentV8Version();
  var IS_CONCAT_SPREADABLE = wellKnownSymbol2("isConcatSpreadable");
  var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails2(function() {
    var array2 = [];
    array2[IS_CONCAT_SPREADABLE] = false;
    return array2.concat()[0] !== array2;
  });
  var isConcatSpreadable = function(O) {
    if (!isObject2(O)) return false;
    var spreadable = O[IS_CONCAT_SPREADABLE];
    return spreadable !== void 0 ? !!spreadable : isArray2(O);
  };
  var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport2("concat");
  $({ target: "Array", proto: true, arity: 1, forced: FORCED }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    concat: function concat2(arg) {
      var O = toObject2(this);
      var A = arraySpeciesCreate2(O, 0);
      var n = 0;
      var i, k, length, len, E;
      for (i = -1, length = arguments.length; i < length; i++) {
        E = i === -1 ? O : arguments[i];
        if (isConcatSpreadable(E)) {
          len = lengthOfArrayLike2(E);
          doesNotExceedSafeInteger2(n + len);
          for (k = 0; k < len; k++, n++) if (k in E) createProperty2(A, n, E[k]);
        } else {
          doesNotExceedSafeInteger2(n + 1);
          createProperty2(A, n++, E);
        }
      }
      A.length = n;
      return A;
    }
  });
  return es_array_concat;
}
var es_symbol = {};
var es_symbol_constructor = {};
var toString;
var hasRequiredToString;
function requireToString() {
  if (hasRequiredToString) return toString;
  hasRequiredToString = 1;
  var classof2 = requireClassof();
  var $String = String;
  toString = function(argument) {
    if (classof2(argument) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
    return $String(argument);
  };
  return toString;
}
var objectDefineProperties = {};
var toAbsoluteIndex;
var hasRequiredToAbsoluteIndex;
function requireToAbsoluteIndex() {
  if (hasRequiredToAbsoluteIndex) return toAbsoluteIndex;
  hasRequiredToAbsoluteIndex = 1;
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var max = Math.max;
  var min = Math.min;
  toAbsoluteIndex = function(index, length) {
    var integer = toIntegerOrInfinity2(index);
    return integer < 0 ? max(integer + length, 0) : min(integer, length);
  };
  return toAbsoluteIndex;
}
var arrayIncludes;
var hasRequiredArrayIncludes;
function requireArrayIncludes() {
  if (hasRequiredArrayIncludes) return arrayIncludes;
  hasRequiredArrayIncludes = 1;
  var toIndexedObject2 = requireToIndexedObject();
  var toAbsoluteIndex2 = requireToAbsoluteIndex();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var createMethod = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
      var O = toIndexedObject2($this);
      var length = lengthOfArrayLike2(O);
      if (length === 0) return !IS_INCLUDES && -1;
      var index = toAbsoluteIndex2(fromIndex, length);
      var value;
      if (IS_INCLUDES && el !== el) while (length > index) {
        value = O[index++];
        if (value !== value) return true;
      }
      else for (; length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
      }
      return !IS_INCLUDES && -1;
    };
  };
  arrayIncludes = {
    // `Array.prototype.includes` method
    // https://tc39.es/ecma262/#sec-array.prototype.includes
    includes: createMethod(true),
    // `Array.prototype.indexOf` method
    // https://tc39.es/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod(false)
  };
  return arrayIncludes;
}
var hiddenKeys;
var hasRequiredHiddenKeys;
function requireHiddenKeys() {
  if (hasRequiredHiddenKeys) return hiddenKeys;
  hasRequiredHiddenKeys = 1;
  hiddenKeys = {};
  return hiddenKeys;
}
var objectKeysInternal;
var hasRequiredObjectKeysInternal;
function requireObjectKeysInternal() {
  if (hasRequiredObjectKeysInternal) return objectKeysInternal;
  hasRequiredObjectKeysInternal = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var hasOwn = requireHasOwnProperty();
  var toIndexedObject2 = requireToIndexedObject();
  var indexOf2 = requireArrayIncludes().indexOf;
  var hiddenKeys2 = requireHiddenKeys();
  var push = uncurryThis([].push);
  objectKeysInternal = function(object2, names) {
    var O = toIndexedObject2(object2);
    var i = 0;
    var result = [];
    var key;
    for (key in O) !hasOwn(hiddenKeys2, key) && hasOwn(O, key) && push(result, key);
    while (names.length > i) if (hasOwn(O, key = names[i++])) {
      ~indexOf2(result, key) || push(result, key);
    }
    return result;
  };
  return objectKeysInternal;
}
var enumBugKeys;
var hasRequiredEnumBugKeys;
function requireEnumBugKeys() {
  if (hasRequiredEnumBugKeys) return enumBugKeys;
  hasRequiredEnumBugKeys = 1;
  enumBugKeys = [
    "constructor",
    "hasOwnProperty",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "toLocaleString",
    "toString",
    "valueOf"
  ];
  return enumBugKeys;
}
var objectKeys;
var hasRequiredObjectKeys;
function requireObjectKeys() {
  if (hasRequiredObjectKeys) return objectKeys;
  hasRequiredObjectKeys = 1;
  var internalObjectKeys = requireObjectKeysInternal();
  var enumBugKeys2 = requireEnumBugKeys();
  objectKeys = Object.keys || function keys2(O) {
    return internalObjectKeys(O, enumBugKeys2);
  };
  return objectKeys;
}
var hasRequiredObjectDefineProperties;
function requireObjectDefineProperties() {
  if (hasRequiredObjectDefineProperties) return objectDefineProperties;
  hasRequiredObjectDefineProperties = 1;
  var DESCRIPTORS = requireDescriptors();
  var V8_PROTOTYPE_DEFINE_BUG = requireV8PrototypeDefineBug();
  var definePropertyModule = requireObjectDefineProperty();
  var anObject2 = requireAnObject();
  var toIndexedObject2 = requireToIndexedObject();
  var objectKeys2 = requireObjectKeys();
  objectDefineProperties.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties2(O, Properties) {
    anObject2(O);
    var props = toIndexedObject2(Properties);
    var keys2 = objectKeys2(Properties);
    var length = keys2.length;
    var index = 0;
    var key;
    while (length > index) definePropertyModule.f(O, key = keys2[index++], props[key]);
    return O;
  };
  return objectDefineProperties;
}
var html;
var hasRequiredHtml;
function requireHtml() {
  if (hasRequiredHtml) return html;
  hasRequiredHtml = 1;
  var getBuiltIn2 = requireGetBuiltIn();
  html = getBuiltIn2("document", "documentElement");
  return html;
}
var sharedKey;
var hasRequiredSharedKey;
function requireSharedKey() {
  if (hasRequiredSharedKey) return sharedKey;
  hasRequiredSharedKey = 1;
  var shared2 = requireShared();
  var uid2 = requireUid();
  var keys2 = shared2("keys");
  sharedKey = function(key) {
    return keys2[key] || (keys2[key] = uid2(key));
  };
  return sharedKey;
}
var objectCreate;
var hasRequiredObjectCreate;
function requireObjectCreate() {
  if (hasRequiredObjectCreate) return objectCreate;
  hasRequiredObjectCreate = 1;
  var anObject2 = requireAnObject();
  var definePropertiesModule = requireObjectDefineProperties();
  var enumBugKeys2 = requireEnumBugKeys();
  var hiddenKeys2 = requireHiddenKeys();
  var html2 = requireHtml();
  var documentCreateElement2 = requireDocumentCreateElement();
  var sharedKey2 = requireSharedKey();
  var GT = ">";
  var LT = "<";
  var PROTOTYPE = "prototype";
  var SCRIPT = "script";
  var IE_PROTO = sharedKey2("IE_PROTO");
  var EmptyConstructor = function() {
  };
  var scriptTag = function(content) {
    return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
  };
  var NullProtoObjectViaActiveX = function(activeXDocument2) {
    activeXDocument2.write(scriptTag(""));
    activeXDocument2.close();
    var temp = activeXDocument2.parentWindow.Object;
    activeXDocument2 = null;
    return temp;
  };
  var NullProtoObjectViaIFrame = function() {
    var iframe = documentCreateElement2("iframe");
    var JS = "java" + SCRIPT + ":";
    var iframeDocument;
    iframe.style.display = "none";
    html2.appendChild(iframe);
    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag("document.F=Object"));
    iframeDocument.close();
    return iframeDocument.F;
  };
  var activeXDocument;
  var NullProtoObject = function() {
    try {
      activeXDocument = new ActiveXObject("htmlfile");
    } catch (error) {
    }
    NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
    var length = enumBugKeys2.length;
    while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys2[length]];
    return NullProtoObject();
  };
  hiddenKeys2[IE_PROTO] = true;
  objectCreate = Object.create || function create2(O, Properties) {
    var result;
    if (O !== null) {
      EmptyConstructor[PROTOTYPE] = anObject2(O);
      result = new EmptyConstructor();
      EmptyConstructor[PROTOTYPE] = null;
      result[IE_PROTO] = O;
    } else result = NullProtoObject();
    return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
  };
  return objectCreate;
}
var objectGetOwnPropertyNames = {};
var hasRequiredObjectGetOwnPropertyNames;
function requireObjectGetOwnPropertyNames() {
  if (hasRequiredObjectGetOwnPropertyNames) return objectGetOwnPropertyNames;
  hasRequiredObjectGetOwnPropertyNames = 1;
  var internalObjectKeys = requireObjectKeysInternal();
  var enumBugKeys2 = requireEnumBugKeys();
  var hiddenKeys2 = enumBugKeys2.concat("length", "prototype");
  objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return internalObjectKeys(O, hiddenKeys2);
  };
  return objectGetOwnPropertyNames;
}
var objectGetOwnPropertyNamesExternal = {};
var arraySlice;
var hasRequiredArraySlice;
function requireArraySlice() {
  if (hasRequiredArraySlice) return arraySlice;
  hasRequiredArraySlice = 1;
  var uncurryThis = requireFunctionUncurryThis();
  arraySlice = uncurryThis([].slice);
  return arraySlice;
}
var hasRequiredObjectGetOwnPropertyNamesExternal;
function requireObjectGetOwnPropertyNamesExternal() {
  if (hasRequiredObjectGetOwnPropertyNamesExternal) return objectGetOwnPropertyNamesExternal;
  hasRequiredObjectGetOwnPropertyNamesExternal = 1;
  var classof2 = requireClassofRaw();
  var toIndexedObject2 = requireToIndexedObject();
  var $getOwnPropertyNames = requireObjectGetOwnPropertyNames().f;
  var arraySlice2 = requireArraySlice();
  var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
  var getWindowNames = function(it2) {
    try {
      return $getOwnPropertyNames(it2);
    } catch (error) {
      return arraySlice2(windowNames);
    }
  };
  objectGetOwnPropertyNamesExternal.f = function getOwnPropertyNames(it2) {
    return windowNames && classof2(it2) === "Window" ? getWindowNames(it2) : $getOwnPropertyNames(toIndexedObject2(it2));
  };
  return objectGetOwnPropertyNamesExternal;
}
var objectGetOwnPropertySymbols = {};
var hasRequiredObjectGetOwnPropertySymbols;
function requireObjectGetOwnPropertySymbols() {
  if (hasRequiredObjectGetOwnPropertySymbols) return objectGetOwnPropertySymbols;
  hasRequiredObjectGetOwnPropertySymbols = 1;
  objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
  return objectGetOwnPropertySymbols;
}
var defineBuiltIn;
var hasRequiredDefineBuiltIn;
function requireDefineBuiltIn() {
  if (hasRequiredDefineBuiltIn) return defineBuiltIn;
  hasRequiredDefineBuiltIn = 1;
  var createNonEnumerableProperty2 = requireCreateNonEnumerableProperty();
  defineBuiltIn = function(target, key, value, options) {
    if (options && options.enumerable) target[key] = value;
    else createNonEnumerableProperty2(target, key, value);
    return target;
  };
  return defineBuiltIn;
}
var defineBuiltInAccessor;
var hasRequiredDefineBuiltInAccessor;
function requireDefineBuiltInAccessor() {
  if (hasRequiredDefineBuiltInAccessor) return defineBuiltInAccessor;
  hasRequiredDefineBuiltInAccessor = 1;
  var defineProperty2 = requireObjectDefineProperty();
  defineBuiltInAccessor = function(target, name, descriptor) {
    return defineProperty2.f(target, name, descriptor);
  };
  return defineBuiltInAccessor;
}
var wellKnownSymbolWrapped = {};
var hasRequiredWellKnownSymbolWrapped;
function requireWellKnownSymbolWrapped() {
  if (hasRequiredWellKnownSymbolWrapped) return wellKnownSymbolWrapped;
  hasRequiredWellKnownSymbolWrapped = 1;
  var wellKnownSymbol2 = requireWellKnownSymbol();
  wellKnownSymbolWrapped.f = wellKnownSymbol2;
  return wellKnownSymbolWrapped;
}
var wellKnownSymbolDefine;
var hasRequiredWellKnownSymbolDefine;
function requireWellKnownSymbolDefine() {
  if (hasRequiredWellKnownSymbolDefine) return wellKnownSymbolDefine;
  hasRequiredWellKnownSymbolDefine = 1;
  var path2 = requirePath();
  var hasOwn = requireHasOwnProperty();
  var wrappedWellKnownSymbolModule = requireWellKnownSymbolWrapped();
  var defineProperty2 = requireObjectDefineProperty().f;
  wellKnownSymbolDefine = function(NAME) {
    var Symbol2 = path2.Symbol || (path2.Symbol = {});
    if (!hasOwn(Symbol2, NAME)) defineProperty2(Symbol2, NAME, {
      value: wrappedWellKnownSymbolModule.f(NAME)
    });
  };
  return wellKnownSymbolDefine;
}
var symbolDefineToPrimitive;
var hasRequiredSymbolDefineToPrimitive;
function requireSymbolDefineToPrimitive() {
  if (hasRequiredSymbolDefineToPrimitive) return symbolDefineToPrimitive;
  hasRequiredSymbolDefineToPrimitive = 1;
  var call = requireFunctionCall();
  var getBuiltIn2 = requireGetBuiltIn();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var defineBuiltIn2 = requireDefineBuiltIn();
  symbolDefineToPrimitive = function() {
    var Symbol2 = getBuiltIn2("Symbol");
    var SymbolPrototype = Symbol2 && Symbol2.prototype;
    var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
    var TO_PRIMITIVE = wellKnownSymbol2("toPrimitive");
    if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {
      defineBuiltIn2(SymbolPrototype, TO_PRIMITIVE, function(hint) {
        return call(valueOf, this);
      }, { arity: 1 });
    }
  };
  return symbolDefineToPrimitive;
}
var objectToString;
var hasRequiredObjectToString;
function requireObjectToString() {
  if (hasRequiredObjectToString) return objectToString;
  hasRequiredObjectToString = 1;
  var TO_STRING_TAG_SUPPORT = requireToStringTagSupport();
  var classof2 = requireClassof();
  objectToString = TO_STRING_TAG_SUPPORT ? {}.toString : function toString2() {
    return "[object " + classof2(this) + "]";
  };
  return objectToString;
}
var setToStringTag;
var hasRequiredSetToStringTag;
function requireSetToStringTag() {
  if (hasRequiredSetToStringTag) return setToStringTag;
  hasRequiredSetToStringTag = 1;
  var TO_STRING_TAG_SUPPORT = requireToStringTagSupport();
  var defineProperty2 = requireObjectDefineProperty().f;
  var createNonEnumerableProperty2 = requireCreateNonEnumerableProperty();
  var hasOwn = requireHasOwnProperty();
  var toString2 = requireObjectToString();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var TO_STRING_TAG = wellKnownSymbol2("toStringTag");
  setToStringTag = function(it2, TAG, STATIC, SET_METHOD) {
    var target = STATIC ? it2 : it2 && it2.prototype;
    if (target) {
      if (!hasOwn(target, TO_STRING_TAG)) {
        defineProperty2(target, TO_STRING_TAG, { configurable: true, value: TAG });
      }
      if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {
        createNonEnumerableProperty2(target, "toString", toString2);
      }
    }
  };
  return setToStringTag;
}
var weakMapBasicDetection;
var hasRequiredWeakMapBasicDetection;
function requireWeakMapBasicDetection() {
  if (hasRequiredWeakMapBasicDetection) return weakMapBasicDetection;
  hasRequiredWeakMapBasicDetection = 1;
  var globalThis2 = requireGlobalThis();
  var isCallable2 = requireIsCallable();
  var WeakMap = globalThis2.WeakMap;
  weakMapBasicDetection = isCallable2(WeakMap) && /native code/.test(String(WeakMap));
  return weakMapBasicDetection;
}
var internalState;
var hasRequiredInternalState;
function requireInternalState() {
  if (hasRequiredInternalState) return internalState;
  hasRequiredInternalState = 1;
  var NATIVE_WEAK_MAP = requireWeakMapBasicDetection();
  var globalThis2 = requireGlobalThis();
  var isObject2 = requireIsObject();
  var createNonEnumerableProperty2 = requireCreateNonEnumerableProperty();
  var hasOwn = requireHasOwnProperty();
  var shared2 = requireSharedStore();
  var sharedKey2 = requireSharedKey();
  var hiddenKeys2 = requireHiddenKeys();
  var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
  var TypeError2 = globalThis2.TypeError;
  var WeakMap = globalThis2.WeakMap;
  var set2, get, has;
  var enforce = function(it2) {
    return has(it2) ? get(it2) : set2(it2, {});
  };
  var getterFor = function(TYPE) {
    return function(it2) {
      var state;
      if (!isObject2(it2) || (state = get(it2)).type !== TYPE) {
        throw new TypeError2("Incompatible receiver, " + TYPE + " required");
      }
      return state;
    };
  };
  if (NATIVE_WEAK_MAP || shared2.state) {
    var store = shared2.state || (shared2.state = new WeakMap());
    store.get = store.get;
    store.has = store.has;
    store.set = store.set;
    set2 = function(it2, metadata) {
      if (store.has(it2)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it2;
      store.set(it2, metadata);
      return metadata;
    };
    get = function(it2) {
      return store.get(it2) || {};
    };
    has = function(it2) {
      return store.has(it2);
    };
  } else {
    var STATE = sharedKey2("state");
    hiddenKeys2[STATE] = true;
    set2 = function(it2, metadata) {
      if (hasOwn(it2, STATE)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it2;
      createNonEnumerableProperty2(it2, STATE, metadata);
      return metadata;
    };
    get = function(it2) {
      return hasOwn(it2, STATE) ? it2[STATE] : {};
    };
    has = function(it2) {
      return hasOwn(it2, STATE);
    };
  }
  internalState = {
    set: set2,
    get,
    has,
    enforce,
    getterFor
  };
  return internalState;
}
var arrayIteration;
var hasRequiredArrayIteration;
function requireArrayIteration() {
  if (hasRequiredArrayIteration) return arrayIteration;
  hasRequiredArrayIteration = 1;
  var bind2 = requireFunctionBindContext();
  var uncurryThis = requireFunctionUncurryThis();
  var IndexedObject = requireIndexedObject();
  var toObject2 = requireToObject();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var arraySpeciesCreate2 = requireArraySpeciesCreate();
  var push = uncurryThis([].push);
  var createMethod = function(TYPE) {
    var IS_MAP = TYPE === 1;
    var IS_FILTER = TYPE === 2;
    var IS_SOME = TYPE === 3;
    var IS_EVERY = TYPE === 4;
    var IS_FIND_INDEX = TYPE === 6;
    var IS_FILTER_REJECT = TYPE === 7;
    var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;
    return function($this, callbackfn, that, specificCreate) {
      var O = toObject2($this);
      var self2 = IndexedObject(O);
      var length = lengthOfArrayLike2(self2);
      var boundFunction = bind2(callbackfn, that);
      var index = 0;
      var create2 = specificCreate || arraySpeciesCreate2;
      var target = IS_MAP ? create2($this, length) : IS_FILTER || IS_FILTER_REJECT ? create2($this, 0) : void 0;
      var value, result;
      for (; length > index; index++) if (NO_HOLES || index in self2) {
        value = self2[index];
        result = boundFunction(value, index, O);
        if (TYPE) {
          if (IS_MAP) target[index] = result;
          else if (result) switch (TYPE) {
            case 3:
              return true;
            // some
            case 5:
              return value;
            // find
            case 6:
              return index;
            // findIndex
            case 2:
              push(target, value);
          }
          else switch (TYPE) {
            case 4:
              return false;
            // every
            case 7:
              push(target, value);
          }
        }
      }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
    };
  };
  arrayIteration = {
    // `Array.prototype.forEach` method
    // https://tc39.es/ecma262/#sec-array.prototype.foreach
    forEach: createMethod(0),
    // `Array.prototype.map` method
    // https://tc39.es/ecma262/#sec-array.prototype.map
    map: createMethod(1),
    // `Array.prototype.filter` method
    // https://tc39.es/ecma262/#sec-array.prototype.filter
    filter: createMethod(2),
    // `Array.prototype.some` method
    // https://tc39.es/ecma262/#sec-array.prototype.some
    some: createMethod(3),
    // `Array.prototype.every` method
    // https://tc39.es/ecma262/#sec-array.prototype.every
    every: createMethod(4),
    // `Array.prototype.find` method
    // https://tc39.es/ecma262/#sec-array.prototype.find
    find: createMethod(5),
    // `Array.prototype.findIndex` method
    // https://tc39.es/ecma262/#sec-array.prototype.findIndex
    findIndex: createMethod(6),
    // `Array.prototype.filterReject` method
    // https://github.com/tc39/proposal-array-filtering
    filterReject: createMethod(7)
  };
  return arrayIteration;
}
var hasRequiredEs_symbol_constructor;
function requireEs_symbol_constructor() {
  if (hasRequiredEs_symbol_constructor) return es_symbol_constructor;
  hasRequiredEs_symbol_constructor = 1;
  var $ = require_export();
  var globalThis2 = requireGlobalThis();
  var call = requireFunctionCall();
  var uncurryThis = requireFunctionUncurryThis();
  var IS_PURE = requireIsPure();
  var DESCRIPTORS = requireDescriptors();
  var NATIVE_SYMBOL = requireSymbolConstructorDetection();
  var fails2 = requireFails();
  var hasOwn = requireHasOwnProperty();
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var anObject2 = requireAnObject();
  var toIndexedObject2 = requireToIndexedObject();
  var toPropertyKey2 = requireToPropertyKey();
  var $toString = requireToString();
  var createPropertyDescriptor2 = requireCreatePropertyDescriptor();
  var nativeObjectCreate = requireObjectCreate();
  var objectKeys2 = requireObjectKeys();
  var getOwnPropertyNamesModule = requireObjectGetOwnPropertyNames();
  var getOwnPropertyNamesExternal = requireObjectGetOwnPropertyNamesExternal();
  var getOwnPropertySymbolsModule = requireObjectGetOwnPropertySymbols();
  var getOwnPropertyDescriptorModule = requireObjectGetOwnPropertyDescriptor();
  var definePropertyModule = requireObjectDefineProperty();
  var definePropertiesModule = requireObjectDefineProperties();
  var propertyIsEnumerableModule = requireObjectPropertyIsEnumerable();
  var defineBuiltIn2 = requireDefineBuiltIn();
  var defineBuiltInAccessor2 = requireDefineBuiltInAccessor();
  var shared2 = requireShared();
  var sharedKey2 = requireSharedKey();
  var hiddenKeys2 = requireHiddenKeys();
  var uid2 = requireUid();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var wrappedWellKnownSymbolModule = requireWellKnownSymbolWrapped();
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  var defineSymbolToPrimitive = requireSymbolDefineToPrimitive();
  var setToStringTag2 = requireSetToStringTag();
  var InternalStateModule = requireInternalState();
  var $forEach = requireArrayIteration().forEach;
  var HIDDEN = sharedKey2("hidden");
  var SYMBOL = "Symbol";
  var PROTOTYPE = "prototype";
  var setInternalState = InternalStateModule.set;
  var getInternalState = InternalStateModule.getterFor(SYMBOL);
  var ObjectPrototype = Object[PROTOTYPE];
  var $Symbol = globalThis2.Symbol;
  var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
  var RangeError2 = globalThis2.RangeError;
  var TypeError2 = globalThis2.TypeError;
  var QObject = globalThis2.QObject;
  var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  var nativeDefineProperty = definePropertyModule.f;
  var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
  var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
  var push = uncurryThis([].push);
  var AllSymbols = shared2("symbols");
  var ObjectPrototypeSymbols = shared2("op-symbols");
  var WellKnownSymbolsStore = shared2("wks");
  var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
  var fallbackDefineProperty = function(O, P, Attributes) {
    var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
    if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
    nativeDefineProperty(O, P, Attributes);
    if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
      nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
    }
  };
  var setSymbolDescriptor = DESCRIPTORS && fails2(function() {
    return nativeObjectCreate(nativeDefineProperty({}, "a", {
      get: function() {
        return nativeDefineProperty(this, "a", { value: 7 }).a;
      }
    })).a !== 7;
  }) ? fallbackDefineProperty : nativeDefineProperty;
  var wrap = function(tag, description) {
    var symbol2 = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
    setInternalState(symbol2, {
      type: SYMBOL,
      tag,
      description
    });
    if (!DESCRIPTORS) symbol2.description = description;
    return symbol2;
  };
  var $defineProperty = function defineProperty2(O, P, Attributes) {
    if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
    anObject2(O);
    var key = toPropertyKey2(P);
    anObject2(Attributes);
    if (hasOwn(AllSymbols, key)) {
      if (!Attributes.enumerable) {
        if (!hasOwn(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor2(1, nativeObjectCreate(null)));
        O[HIDDEN][key] = true;
      } else {
        if (hasOwn(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
        Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor2(0, false) });
      }
      return setSymbolDescriptor(O, key, Attributes);
    }
    return nativeDefineProperty(O, key, Attributes);
  };
  var $defineProperties = function defineProperties2(O, Properties) {
    anObject2(O);
    var properties = toIndexedObject2(Properties);
    var keys2 = objectKeys2(properties).concat($getOwnPropertySymbols(properties));
    $forEach(keys2, function(key) {
      if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key)) $defineProperty(O, key, properties[key]);
    });
    return O;
  };
  var $create = function create2(O, Properties) {
    return Properties === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
  };
  var $propertyIsEnumerable = function propertyIsEnumerable(V) {
    var P = toPropertyKey2(V);
    var enumerable = call(nativePropertyIsEnumerable, this, P);
    if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P)) return false;
    return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
  };
  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor2(O, P) {
    var it2 = toIndexedObject2(O);
    var key = toPropertyKey2(P);
    if (it2 === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key)) return;
    var descriptor = nativeGetOwnPropertyDescriptor(it2, key);
    if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it2, HIDDEN) && it2[HIDDEN][key])) {
      descriptor.enumerable = true;
    }
    return descriptor;
  };
  var $getOwnPropertyNames = function getOwnPropertyNames(O) {
    var names = nativeGetOwnPropertyNames(toIndexedObject2(O));
    var result = [];
    $forEach(names, function(key) {
      if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys2, key)) push(result, key);
    });
    return result;
  };
  var $getOwnPropertySymbols = function(O) {
    var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
    var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject2(O));
    var result = [];
    $forEach(names, function(key) {
      if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
        push(result, AllSymbols[key]);
      }
    });
    return result;
  };
  if (!NATIVE_SYMBOL) {
    $Symbol = function Symbol2() {
      if (isPrototypeOf(SymbolPrototype, this)) throw new TypeError2("Symbol is not a constructor");
      var description = !arguments.length || arguments[0] === void 0 ? void 0 : $toString(arguments[0]);
      var tag = uid2(description);
      var setter = function(value) {
        var $this = this === void 0 ? globalThis2 : this;
        if ($this === ObjectPrototype) call(setter, ObjectPrototypeSymbols, value);
        if (hasOwn($this, HIDDEN) && hasOwn($this[HIDDEN], tag)) $this[HIDDEN][tag] = false;
        var descriptor = createPropertyDescriptor2(1, value);
        try {
          setSymbolDescriptor($this, tag, descriptor);
        } catch (error) {
          if (!(error instanceof RangeError2)) throw error;
          fallbackDefineProperty($this, tag, descriptor);
        }
      };
      if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
      return wrap(tag, description);
    };
    SymbolPrototype = $Symbol[PROTOTYPE];
    defineBuiltIn2(SymbolPrototype, "toString", function toString2() {
      return getInternalState(this).tag;
    });
    defineBuiltIn2($Symbol, "withoutSetter", function(description) {
      return wrap(uid2(description), description);
    });
    propertyIsEnumerableModule.f = $propertyIsEnumerable;
    definePropertyModule.f = $defineProperty;
    definePropertiesModule.f = $defineProperties;
    getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
    getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
    getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
    wrappedWellKnownSymbolModule.f = function(name) {
      return wrap(wellKnownSymbol2(name), name);
    };
    if (DESCRIPTORS) {
      defineBuiltInAccessor2(SymbolPrototype, "description", {
        configurable: true,
        get: function description() {
          return getInternalState(this).description;
        }
      });
      if (!IS_PURE) {
        defineBuiltIn2(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
      }
    }
  }
  $({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
    Symbol: $Symbol
  });
  $forEach(objectKeys2(WellKnownSymbolsStore), function(name) {
    defineWellKnownSymbol(name);
  });
  $({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
    useSetter: function() {
      USE_SETTER = true;
    },
    useSimple: function() {
      USE_SETTER = false;
    }
  });
  $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
    // `Object.create` method
    // https://tc39.es/ecma262/#sec-object.create
    create: $create,
    // `Object.defineProperty` method
    // https://tc39.es/ecma262/#sec-object.defineproperty
    defineProperty: $defineProperty,
    // `Object.defineProperties` method
    // https://tc39.es/ecma262/#sec-object.defineproperties
    defineProperties: $defineProperties,
    // `Object.getOwnPropertyDescriptor` method
    // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor
  });
  $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL }, {
    // `Object.getOwnPropertyNames` method
    // https://tc39.es/ecma262/#sec-object.getownpropertynames
    getOwnPropertyNames: $getOwnPropertyNames
  });
  defineSymbolToPrimitive();
  setToStringTag2($Symbol, SYMBOL);
  hiddenKeys2[HIDDEN] = true;
  return es_symbol_constructor;
}
var es_symbol_for = {};
var symbolRegistryDetection;
var hasRequiredSymbolRegistryDetection;
function requireSymbolRegistryDetection() {
  if (hasRequiredSymbolRegistryDetection) return symbolRegistryDetection;
  hasRequiredSymbolRegistryDetection = 1;
  var NATIVE_SYMBOL = requireSymbolConstructorDetection();
  symbolRegistryDetection = NATIVE_SYMBOL && !!Symbol["for"] && !!Symbol.keyFor;
  return symbolRegistryDetection;
}
var hasRequiredEs_symbol_for;
function requireEs_symbol_for() {
  if (hasRequiredEs_symbol_for) return es_symbol_for;
  hasRequiredEs_symbol_for = 1;
  var $ = require_export();
  var getBuiltIn2 = requireGetBuiltIn();
  var hasOwn = requireHasOwnProperty();
  var toString2 = requireToString();
  var shared2 = requireShared();
  var NATIVE_SYMBOL_REGISTRY = requireSymbolRegistryDetection();
  var StringToSymbolRegistry = shared2("string-to-symbol-registry");
  var SymbolToStringRegistry = shared2("symbol-to-string-registry");
  $({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
    "for": function(key) {
      var string2 = toString2(key);
      if (hasOwn(StringToSymbolRegistry, string2)) return StringToSymbolRegistry[string2];
      var symbol2 = getBuiltIn2("Symbol")(string2);
      StringToSymbolRegistry[string2] = symbol2;
      SymbolToStringRegistry[symbol2] = string2;
      return symbol2;
    }
  });
  return es_symbol_for;
}
var es_symbol_keyFor = {};
var hasRequiredEs_symbol_keyFor;
function requireEs_symbol_keyFor() {
  if (hasRequiredEs_symbol_keyFor) return es_symbol_keyFor;
  hasRequiredEs_symbol_keyFor = 1;
  var $ = require_export();
  var hasOwn = requireHasOwnProperty();
  var isSymbol2 = requireIsSymbol();
  var tryToString2 = requireTryToString();
  var shared2 = requireShared();
  var NATIVE_SYMBOL_REGISTRY = requireSymbolRegistryDetection();
  var SymbolToStringRegistry = shared2("symbol-to-string-registry");
  $({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
    keyFor: function keyFor(sym) {
      if (!isSymbol2(sym)) throw new TypeError(tryToString2(sym) + " is not a symbol");
      if (hasOwn(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
    }
  });
  return es_symbol_keyFor;
}
var es_json_stringify = {};
var getJsonReplacerFunction;
var hasRequiredGetJsonReplacerFunction;
function requireGetJsonReplacerFunction() {
  if (hasRequiredGetJsonReplacerFunction) return getJsonReplacerFunction;
  hasRequiredGetJsonReplacerFunction = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var isArray2 = requireIsArray$3();
  var isCallable2 = requireIsCallable();
  var classof2 = requireClassofRaw();
  var toString2 = requireToString();
  var push = uncurryThis([].push);
  getJsonReplacerFunction = function(replacer) {
    if (isCallable2(replacer)) return replacer;
    if (!isArray2(replacer)) return;
    var rawLength = replacer.length;
    var keys2 = [];
    for (var i = 0; i < rawLength; i++) {
      var element = replacer[i];
      if (typeof element == "string") push(keys2, element);
      else if (typeof element == "number" || classof2(element) === "Number" || classof2(element) === "String") push(keys2, toString2(element));
    }
    var keysLength = keys2.length;
    var root = true;
    return function(key, value) {
      if (root) {
        root = false;
        return value;
      }
      if (isArray2(this)) return value;
      for (var j = 0; j < keysLength; j++) if (keys2[j] === key) return value;
    };
  };
  return getJsonReplacerFunction;
}
var hasRequiredEs_json_stringify;
function requireEs_json_stringify() {
  if (hasRequiredEs_json_stringify) return es_json_stringify;
  hasRequiredEs_json_stringify = 1;
  var $ = require_export();
  var getBuiltIn2 = requireGetBuiltIn();
  var apply = requireFunctionApply();
  var call = requireFunctionCall();
  var uncurryThis = requireFunctionUncurryThis();
  var fails2 = requireFails();
  var isCallable2 = requireIsCallable();
  var isSymbol2 = requireIsSymbol();
  var arraySlice2 = requireArraySlice();
  var getReplacerFunction = requireGetJsonReplacerFunction();
  var NATIVE_SYMBOL = requireSymbolConstructorDetection();
  var $String = String;
  var $stringify = getBuiltIn2("JSON", "stringify");
  var exec = uncurryThis(/./.exec);
  var charAt = uncurryThis("".charAt);
  var charCodeAt = uncurryThis("".charCodeAt);
  var replace = uncurryThis("".replace);
  var numberToString = uncurryThis(1.1.toString);
  var tester = /[\uD800-\uDFFF]/g;
  var low = /^[\uD800-\uDBFF]$/;
  var hi = /^[\uDC00-\uDFFF]$/;
  var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails2(function() {
    var symbol2 = getBuiltIn2("Symbol")("stringify detection");
    return $stringify([symbol2]) !== "[null]" || $stringify({ a: symbol2 }) !== "{}" || $stringify(Object(symbol2)) !== "{}";
  });
  var ILL_FORMED_UNICODE = fails2(function() {
    return $stringify("\uDF06\uD834") !== '"\\udf06\\ud834"' || $stringify("\uDEAD") !== '"\\udead"';
  });
  var stringifyWithSymbolsFix = function(it2, replacer) {
    var args = arraySlice2(arguments);
    var $replacer = getReplacerFunction(replacer);
    if (!isCallable2($replacer) && (it2 === void 0 || isSymbol2(it2))) return;
    args[1] = function(key, value) {
      if (isCallable2($replacer)) value = call($replacer, this, $String(key), value);
      if (!isSymbol2(value)) return value;
    };
    return apply($stringify, null, args);
  };
  var fixIllFormed = function(match, offset, string2) {
    var prev = charAt(string2, offset - 1);
    var next = charAt(string2, offset + 1);
    if (exec(low, match) && !exec(hi, next) || exec(hi, match) && !exec(low, prev)) {
      return "\\u" + numberToString(charCodeAt(match, 0), 16);
    }
    return match;
  };
  if ($stringify) {
    $({ target: "JSON", stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      stringify: function stringify2(it2, replacer, space) {
        var args = arraySlice2(arguments);
        var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
        return ILL_FORMED_UNICODE && typeof result == "string" ? replace(result, tester, fixIllFormed) : result;
      }
    });
  }
  return es_json_stringify;
}
var es_object_getOwnPropertySymbols = {};
var hasRequiredEs_object_getOwnPropertySymbols;
function requireEs_object_getOwnPropertySymbols() {
  if (hasRequiredEs_object_getOwnPropertySymbols) return es_object_getOwnPropertySymbols;
  hasRequiredEs_object_getOwnPropertySymbols = 1;
  var $ = require_export();
  var NATIVE_SYMBOL = requireSymbolConstructorDetection();
  var fails2 = requireFails();
  var getOwnPropertySymbolsModule = requireObjectGetOwnPropertySymbols();
  var toObject2 = requireToObject();
  var FORCED = !NATIVE_SYMBOL || fails2(function() {
    getOwnPropertySymbolsModule.f(1);
  });
  $({ target: "Object", stat: true, forced: FORCED }, {
    getOwnPropertySymbols: function getOwnPropertySymbols2(it2) {
      var $getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
      return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject2(it2)) : [];
    }
  });
  return es_object_getOwnPropertySymbols;
}
var hasRequiredEs_symbol;
function requireEs_symbol() {
  if (hasRequiredEs_symbol) return es_symbol;
  hasRequiredEs_symbol = 1;
  requireEs_symbol_constructor();
  requireEs_symbol_for();
  requireEs_symbol_keyFor();
  requireEs_json_stringify();
  requireEs_object_getOwnPropertySymbols();
  return es_symbol;
}
var es_symbol_asyncDispose = {};
var hasRequiredEs_symbol_asyncDispose;
function requireEs_symbol_asyncDispose() {
  if (hasRequiredEs_symbol_asyncDispose) return es_symbol_asyncDispose;
  hasRequiredEs_symbol_asyncDispose = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("asyncDispose");
  return es_symbol_asyncDispose;
}
var es_symbol_asyncIterator = {};
var hasRequiredEs_symbol_asyncIterator;
function requireEs_symbol_asyncIterator() {
  if (hasRequiredEs_symbol_asyncIterator) return es_symbol_asyncIterator;
  hasRequiredEs_symbol_asyncIterator = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("asyncIterator");
  return es_symbol_asyncIterator;
}
var es_symbol_dispose = {};
var hasRequiredEs_symbol_dispose;
function requireEs_symbol_dispose() {
  if (hasRequiredEs_symbol_dispose) return es_symbol_dispose;
  hasRequiredEs_symbol_dispose = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("dispose");
  return es_symbol_dispose;
}
var es_symbol_hasInstance = {};
var hasRequiredEs_symbol_hasInstance;
function requireEs_symbol_hasInstance() {
  if (hasRequiredEs_symbol_hasInstance) return es_symbol_hasInstance;
  hasRequiredEs_symbol_hasInstance = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("hasInstance");
  return es_symbol_hasInstance;
}
var es_symbol_isConcatSpreadable = {};
var hasRequiredEs_symbol_isConcatSpreadable;
function requireEs_symbol_isConcatSpreadable() {
  if (hasRequiredEs_symbol_isConcatSpreadable) return es_symbol_isConcatSpreadable;
  hasRequiredEs_symbol_isConcatSpreadable = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("isConcatSpreadable");
  return es_symbol_isConcatSpreadable;
}
var es_symbol_iterator = {};
var hasRequiredEs_symbol_iterator;
function requireEs_symbol_iterator() {
  if (hasRequiredEs_symbol_iterator) return es_symbol_iterator;
  hasRequiredEs_symbol_iterator = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("iterator");
  return es_symbol_iterator;
}
var es_symbol_match = {};
var hasRequiredEs_symbol_match;
function requireEs_symbol_match() {
  if (hasRequiredEs_symbol_match) return es_symbol_match;
  hasRequiredEs_symbol_match = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("match");
  return es_symbol_match;
}
var es_symbol_matchAll = {};
var hasRequiredEs_symbol_matchAll;
function requireEs_symbol_matchAll() {
  if (hasRequiredEs_symbol_matchAll) return es_symbol_matchAll;
  hasRequiredEs_symbol_matchAll = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("matchAll");
  return es_symbol_matchAll;
}
var es_symbol_replace = {};
var hasRequiredEs_symbol_replace;
function requireEs_symbol_replace() {
  if (hasRequiredEs_symbol_replace) return es_symbol_replace;
  hasRequiredEs_symbol_replace = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("replace");
  return es_symbol_replace;
}
var es_symbol_search = {};
var hasRequiredEs_symbol_search;
function requireEs_symbol_search() {
  if (hasRequiredEs_symbol_search) return es_symbol_search;
  hasRequiredEs_symbol_search = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("search");
  return es_symbol_search;
}
var es_symbol_species = {};
var hasRequiredEs_symbol_species;
function requireEs_symbol_species() {
  if (hasRequiredEs_symbol_species) return es_symbol_species;
  hasRequiredEs_symbol_species = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("species");
  return es_symbol_species;
}
var es_symbol_split = {};
var hasRequiredEs_symbol_split;
function requireEs_symbol_split() {
  if (hasRequiredEs_symbol_split) return es_symbol_split;
  hasRequiredEs_symbol_split = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("split");
  return es_symbol_split;
}
var es_symbol_toPrimitive = {};
var hasRequiredEs_symbol_toPrimitive;
function requireEs_symbol_toPrimitive() {
  if (hasRequiredEs_symbol_toPrimitive) return es_symbol_toPrimitive;
  hasRequiredEs_symbol_toPrimitive = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  var defineSymbolToPrimitive = requireSymbolDefineToPrimitive();
  defineWellKnownSymbol("toPrimitive");
  defineSymbolToPrimitive();
  return es_symbol_toPrimitive;
}
var es_symbol_toStringTag = {};
var hasRequiredEs_symbol_toStringTag;
function requireEs_symbol_toStringTag() {
  if (hasRequiredEs_symbol_toStringTag) return es_symbol_toStringTag;
  hasRequiredEs_symbol_toStringTag = 1;
  var getBuiltIn2 = requireGetBuiltIn();
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  var setToStringTag2 = requireSetToStringTag();
  defineWellKnownSymbol("toStringTag");
  setToStringTag2(getBuiltIn2("Symbol"), "Symbol");
  return es_symbol_toStringTag;
}
var es_symbol_unscopables = {};
var hasRequiredEs_symbol_unscopables;
function requireEs_symbol_unscopables() {
  if (hasRequiredEs_symbol_unscopables) return es_symbol_unscopables;
  hasRequiredEs_symbol_unscopables = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("unscopables");
  return es_symbol_unscopables;
}
var es_json_toStringTag = {};
var hasRequiredEs_json_toStringTag;
function requireEs_json_toStringTag() {
  if (hasRequiredEs_json_toStringTag) return es_json_toStringTag;
  hasRequiredEs_json_toStringTag = 1;
  var globalThis2 = requireGlobalThis();
  var setToStringTag2 = requireSetToStringTag();
  setToStringTag2(globalThis2.JSON, "JSON", true);
  return es_json_toStringTag;
}
var symbol$5;
var hasRequiredSymbol$5;
function requireSymbol$5() {
  if (hasRequiredSymbol$5) return symbol$5;
  hasRequiredSymbol$5 = 1;
  requireEs_array_concat();
  requireEs_symbol();
  requireEs_symbol_asyncDispose();
  requireEs_symbol_asyncIterator();
  requireEs_symbol_dispose();
  requireEs_symbol_hasInstance();
  requireEs_symbol_isConcatSpreadable();
  requireEs_symbol_iterator();
  requireEs_symbol_match();
  requireEs_symbol_matchAll();
  requireEs_symbol_replace();
  requireEs_symbol_search();
  requireEs_symbol_species();
  requireEs_symbol_split();
  requireEs_symbol_toPrimitive();
  requireEs_symbol_toStringTag();
  requireEs_symbol_unscopables();
  requireEs_json_toStringTag();
  var path2 = requirePath();
  symbol$5 = path2.Symbol;
  return symbol$5;
}
var web_domCollections_iterator = {};
var addToUnscopables;
var hasRequiredAddToUnscopables;
function requireAddToUnscopables() {
  if (hasRequiredAddToUnscopables) return addToUnscopables;
  hasRequiredAddToUnscopables = 1;
  addToUnscopables = function() {
  };
  return addToUnscopables;
}
var iterators;
var hasRequiredIterators;
function requireIterators() {
  if (hasRequiredIterators) return iterators;
  hasRequiredIterators = 1;
  iterators = {};
  return iterators;
}
var functionName;
var hasRequiredFunctionName;
function requireFunctionName() {
  if (hasRequiredFunctionName) return functionName;
  hasRequiredFunctionName = 1;
  var DESCRIPTORS = requireDescriptors();
  var hasOwn = requireHasOwnProperty();
  var FunctionPrototype = Function.prototype;
  var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
  var EXISTS = hasOwn(FunctionPrototype, "name");
  var PROPER = EXISTS && (function something() {
  }).name === "something";
  var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
  functionName = {
    EXISTS,
    PROPER,
    CONFIGURABLE
  };
  return functionName;
}
var correctPrototypeGetter;
var hasRequiredCorrectPrototypeGetter;
function requireCorrectPrototypeGetter() {
  if (hasRequiredCorrectPrototypeGetter) return correctPrototypeGetter;
  hasRequiredCorrectPrototypeGetter = 1;
  var fails2 = requireFails();
  correctPrototypeGetter = !fails2(function() {
    function F() {
    }
    F.prototype.constructor = null;
    return Object.getPrototypeOf(new F()) !== F.prototype;
  });
  return correctPrototypeGetter;
}
var objectGetPrototypeOf;
var hasRequiredObjectGetPrototypeOf;
function requireObjectGetPrototypeOf() {
  if (hasRequiredObjectGetPrototypeOf) return objectGetPrototypeOf;
  hasRequiredObjectGetPrototypeOf = 1;
  var hasOwn = requireHasOwnProperty();
  var isCallable2 = requireIsCallable();
  var toObject2 = requireToObject();
  var sharedKey2 = requireSharedKey();
  var CORRECT_PROTOTYPE_GETTER = requireCorrectPrototypeGetter();
  var IE_PROTO = sharedKey2("IE_PROTO");
  var $Object = Object;
  var ObjectPrototype = $Object.prototype;
  objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {
    var object2 = toObject2(O);
    if (hasOwn(object2, IE_PROTO)) return object2[IE_PROTO];
    var constructor = object2.constructor;
    if (isCallable2(constructor) && object2 instanceof constructor) {
      return constructor.prototype;
    }
    return object2 instanceof $Object ? ObjectPrototype : null;
  };
  return objectGetPrototypeOf;
}
var iteratorsCore;
var hasRequiredIteratorsCore;
function requireIteratorsCore() {
  if (hasRequiredIteratorsCore) return iteratorsCore;
  hasRequiredIteratorsCore = 1;
  var fails2 = requireFails();
  var isCallable2 = requireIsCallable();
  var isObject2 = requireIsObject();
  var create2 = requireObjectCreate();
  var getPrototypeOf2 = requireObjectGetPrototypeOf();
  var defineBuiltIn2 = requireDefineBuiltIn();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var IS_PURE = requireIsPure();
  var ITERATOR = wellKnownSymbol2("iterator");
  var BUGGY_SAFARI_ITERATORS = false;
  var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
  if ([].keys) {
    arrayIterator = [].keys();
    if (!("next" in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
    else {
      PrototypeOfArrayIteratorPrototype = getPrototypeOf2(getPrototypeOf2(arrayIterator));
      if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
    }
  }
  var NEW_ITERATOR_PROTOTYPE = !isObject2(IteratorPrototype) || fails2(function() {
    var test = {};
    return IteratorPrototype[ITERATOR].call(test) !== test;
  });
  if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
  else if (IS_PURE) IteratorPrototype = create2(IteratorPrototype);
  if (!isCallable2(IteratorPrototype[ITERATOR])) {
    defineBuiltIn2(IteratorPrototype, ITERATOR, function() {
      return this;
    });
  }
  iteratorsCore = {
    IteratorPrototype,
    BUGGY_SAFARI_ITERATORS
  };
  return iteratorsCore;
}
var iteratorCreateConstructor;
var hasRequiredIteratorCreateConstructor;
function requireIteratorCreateConstructor() {
  if (hasRequiredIteratorCreateConstructor) return iteratorCreateConstructor;
  hasRequiredIteratorCreateConstructor = 1;
  var IteratorPrototype = requireIteratorsCore().IteratorPrototype;
  var create2 = requireObjectCreate();
  var createPropertyDescriptor2 = requireCreatePropertyDescriptor();
  var setToStringTag2 = requireSetToStringTag();
  var Iterators = requireIterators();
  var returnThis = function() {
    return this;
  };
  iteratorCreateConstructor = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
    var TO_STRING_TAG = NAME + " Iterator";
    IteratorConstructor.prototype = create2(IteratorPrototype, { next: createPropertyDescriptor2(+!ENUMERABLE_NEXT, next) });
    setToStringTag2(IteratorConstructor, TO_STRING_TAG, false, true);
    Iterators[TO_STRING_TAG] = returnThis;
    return IteratorConstructor;
  };
  return iteratorCreateConstructor;
}
var functionUncurryThisAccessor;
var hasRequiredFunctionUncurryThisAccessor;
function requireFunctionUncurryThisAccessor() {
  if (hasRequiredFunctionUncurryThisAccessor) return functionUncurryThisAccessor;
  hasRequiredFunctionUncurryThisAccessor = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var aCallable2 = requireACallable();
  functionUncurryThisAccessor = function(object2, key, method) {
    try {
      return uncurryThis(aCallable2(Object.getOwnPropertyDescriptor(object2, key)[method]));
    } catch (error) {
    }
  };
  return functionUncurryThisAccessor;
}
var isPossiblePrototype;
var hasRequiredIsPossiblePrototype;
function requireIsPossiblePrototype() {
  if (hasRequiredIsPossiblePrototype) return isPossiblePrototype;
  hasRequiredIsPossiblePrototype = 1;
  var isObject2 = requireIsObject();
  isPossiblePrototype = function(argument) {
    return isObject2(argument) || argument === null;
  };
  return isPossiblePrototype;
}
var aPossiblePrototype;
var hasRequiredAPossiblePrototype;
function requireAPossiblePrototype() {
  if (hasRequiredAPossiblePrototype) return aPossiblePrototype;
  hasRequiredAPossiblePrototype = 1;
  var isPossiblePrototype2 = requireIsPossiblePrototype();
  var $String = String;
  var $TypeError = TypeError;
  aPossiblePrototype = function(argument) {
    if (isPossiblePrototype2(argument)) return argument;
    throw new $TypeError("Can't set " + $String(argument) + " as a prototype");
  };
  return aPossiblePrototype;
}
var objectSetPrototypeOf;
var hasRequiredObjectSetPrototypeOf;
function requireObjectSetPrototypeOf() {
  if (hasRequiredObjectSetPrototypeOf) return objectSetPrototypeOf;
  hasRequiredObjectSetPrototypeOf = 1;
  var uncurryThisAccessor = requireFunctionUncurryThisAccessor();
  var isObject2 = requireIsObject();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var aPossiblePrototype2 = requireAPossiblePrototype();
  objectSetPrototypeOf = Object.setPrototypeOf || ("__proto__" in {} ? (function() {
    var CORRECT_SETTER = false;
    var test = {};
    var setter;
    try {
      setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
      setter(test, []);
      CORRECT_SETTER = test instanceof Array;
    } catch (error) {
    }
    return function setPrototypeOf(O, proto) {
      requireObjectCoercible2(O);
      aPossiblePrototype2(proto);
      if (!isObject2(O)) return O;
      if (CORRECT_SETTER) setter(O, proto);
      else O.__proto__ = proto;
      return O;
    };
  })() : void 0);
  return objectSetPrototypeOf;
}
var iteratorDefine;
var hasRequiredIteratorDefine;
function requireIteratorDefine() {
  if (hasRequiredIteratorDefine) return iteratorDefine;
  hasRequiredIteratorDefine = 1;
  var $ = require_export();
  var call = requireFunctionCall();
  var IS_PURE = requireIsPure();
  var FunctionName = requireFunctionName();
  var isCallable2 = requireIsCallable();
  var createIteratorConstructor = requireIteratorCreateConstructor();
  var getPrototypeOf2 = requireObjectGetPrototypeOf();
  var setPrototypeOf = requireObjectSetPrototypeOf();
  var setToStringTag2 = requireSetToStringTag();
  var createNonEnumerableProperty2 = requireCreateNonEnumerableProperty();
  var defineBuiltIn2 = requireDefineBuiltIn();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var Iterators = requireIterators();
  var IteratorsCore = requireIteratorsCore();
  var PROPER_FUNCTION_NAME = FunctionName.PROPER;
  var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
  var IteratorPrototype = IteratorsCore.IteratorPrototype;
  var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
  var ITERATOR = wellKnownSymbol2("iterator");
  var KEYS = "keys";
  var VALUES = "values";
  var ENTRIES = "entries";
  var returnThis = function() {
    return this;
  };
  iteratorDefine = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
    createIteratorConstructor(IteratorConstructor, NAME, next);
    var getIterationMethod = function(KIND) {
      if (KIND === DEFAULT && defaultIterator) return defaultIterator;
      if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype) return IterablePrototype[KIND];
      switch (KIND) {
        case KEYS:
          return function keys2() {
            return new IteratorConstructor(this, KIND);
          };
        case VALUES:
          return function values2() {
            return new IteratorConstructor(this, KIND);
          };
        case ENTRIES:
          return function entries2() {
            return new IteratorConstructor(this, KIND);
          };
      }
      return function() {
        return new IteratorConstructor(this);
      };
    };
    var TO_STRING_TAG = NAME + " Iterator";
    var INCORRECT_VALUES_NAME = false;
    var IterablePrototype = Iterable.prototype;
    var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
    var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
    var anyNativeIterator = NAME === "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
    var CurrentIteratorPrototype, methods, KEY;
    if (anyNativeIterator) {
      CurrentIteratorPrototype = getPrototypeOf2(anyNativeIterator.call(new Iterable()));
      if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
        if (!IS_PURE && getPrototypeOf2(CurrentIteratorPrototype) !== IteratorPrototype) {
          if (setPrototypeOf) {
            setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
          } else if (!isCallable2(CurrentIteratorPrototype[ITERATOR])) {
            defineBuiltIn2(CurrentIteratorPrototype, ITERATOR, returnThis);
          }
        }
        setToStringTag2(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
        if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
      }
    }
    if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
      if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
        createNonEnumerableProperty2(IterablePrototype, "name", VALUES);
      } else {
        INCORRECT_VALUES_NAME = true;
        defaultIterator = function values2() {
          return call(nativeIterator, this);
        };
      }
    }
    if (DEFAULT) {
      methods = {
        values: getIterationMethod(VALUES),
        keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
        entries: getIterationMethod(ENTRIES)
      };
      if (FORCED) for (KEY in methods) {
        if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
          defineBuiltIn2(IterablePrototype, KEY, methods[KEY]);
        }
      }
      else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
    }
    if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
      defineBuiltIn2(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
    }
    Iterators[NAME] = defaultIterator;
    return methods;
  };
  return iteratorDefine;
}
var createIterResultObject;
var hasRequiredCreateIterResultObject;
function requireCreateIterResultObject() {
  if (hasRequiredCreateIterResultObject) return createIterResultObject;
  hasRequiredCreateIterResultObject = 1;
  createIterResultObject = function(value, done) {
    return { value, done };
  };
  return createIterResultObject;
}
var es_array_iterator;
var hasRequiredEs_array_iterator;
function requireEs_array_iterator() {
  if (hasRequiredEs_array_iterator) return es_array_iterator;
  hasRequiredEs_array_iterator = 1;
  var toIndexedObject2 = requireToIndexedObject();
  var addToUnscopables2 = requireAddToUnscopables();
  var Iterators = requireIterators();
  var InternalStateModule = requireInternalState();
  var defineProperty2 = requireObjectDefineProperty().f;
  var defineIterator = requireIteratorDefine();
  var createIterResultObject2 = requireCreateIterResultObject();
  var IS_PURE = requireIsPure();
  var DESCRIPTORS = requireDescriptors();
  var ARRAY_ITERATOR = "Array Iterator";
  var setInternalState = InternalStateModule.set;
  var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
  es_array_iterator = defineIterator(Array, "Array", function(iterated, kind) {
    setInternalState(this, {
      type: ARRAY_ITERATOR,
      target: toIndexedObject2(iterated),
      // target
      index: 0,
      // next index
      kind
      // kind
    });
  }, function() {
    var state = getInternalState(this);
    var target = state.target;
    var index = state.index++;
    if (!target || index >= target.length) {
      state.target = null;
      return createIterResultObject2(void 0, true);
    }
    switch (state.kind) {
      case "keys":
        return createIterResultObject2(index, false);
      case "values":
        return createIterResultObject2(target[index], false);
    }
    return createIterResultObject2([index, target[index]], false);
  }, "values");
  var values2 = Iterators.Arguments = Iterators.Array;
  addToUnscopables2("keys");
  addToUnscopables2("values");
  addToUnscopables2("entries");
  if (!IS_PURE && DESCRIPTORS && values2.name !== "values") try {
    defineProperty2(values2, "name", { value: "values" });
  } catch (error) {
  }
  return es_array_iterator;
}
var domIterables;
var hasRequiredDomIterables;
function requireDomIterables() {
  if (hasRequiredDomIterables) return domIterables;
  hasRequiredDomIterables = 1;
  domIterables = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
  };
  return domIterables;
}
var hasRequiredWeb_domCollections_iterator;
function requireWeb_domCollections_iterator() {
  if (hasRequiredWeb_domCollections_iterator) return web_domCollections_iterator;
  hasRequiredWeb_domCollections_iterator = 1;
  requireEs_array_iterator();
  var DOMIterables = requireDomIterables();
  var globalThis2 = requireGlobalThis();
  var setToStringTag2 = requireSetToStringTag();
  var Iterators = requireIterators();
  for (var COLLECTION_NAME in DOMIterables) {
    setToStringTag2(globalThis2[COLLECTION_NAME], COLLECTION_NAME);
    Iterators[COLLECTION_NAME] = Iterators.Array;
  }
  return web_domCollections_iterator;
}
var symbol$4;
var hasRequiredSymbol$4;
function requireSymbol$4() {
  if (hasRequiredSymbol$4) return symbol$4;
  hasRequiredSymbol$4 = 1;
  var parent = requireSymbol$5();
  requireWeb_domCollections_iterator();
  symbol$4 = parent;
  return symbol$4;
}
var symbol$3;
var hasRequiredSymbol$3;
function requireSymbol$3() {
  if (hasRequiredSymbol$3) return symbol$3;
  hasRequiredSymbol$3 = 1;
  symbol$3 = requireSymbol$4();
  return symbol$3;
}
var symbolExports$1 = requireSymbol$3();
var _Symbol$1 = getDefaultExportFromCjs(symbolExports$1);
var es_array_slice = {};
var hasRequiredEs_array_slice;
function requireEs_array_slice() {
  if (hasRequiredEs_array_slice) return es_array_slice;
  hasRequiredEs_array_slice = 1;
  var $ = require_export();
  var isArray2 = requireIsArray$3();
  var isConstructor2 = requireIsConstructor();
  var isObject2 = requireIsObject();
  var toAbsoluteIndex2 = requireToAbsoluteIndex();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var toIndexedObject2 = requireToIndexedObject();
  var createProperty2 = requireCreateProperty();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var arrayMethodHasSpeciesSupport2 = requireArrayMethodHasSpeciesSupport();
  var nativeSlice = requireArraySlice();
  var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport2("slice");
  var SPECIES = wellKnownSymbol2("species");
  var $Array = Array;
  var max = Math.max;
  $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
    slice: function slice2(start, end) {
      var O = toIndexedObject2(this);
      var length = lengthOfArrayLike2(O);
      var k = toAbsoluteIndex2(start, length);
      var fin = toAbsoluteIndex2(end === void 0 ? length : end, length);
      var Constructor, result, n;
      if (isArray2(O)) {
        Constructor = O.constructor;
        if (isConstructor2(Constructor) && (Constructor === $Array || isArray2(Constructor.prototype))) {
          Constructor = void 0;
        } else if (isObject2(Constructor)) {
          Constructor = Constructor[SPECIES];
          if (Constructor === null) Constructor = void 0;
        }
        if (Constructor === $Array || Constructor === void 0) {
          return nativeSlice(O, k, fin);
        }
      }
      result = new (Constructor === void 0 ? $Array : Constructor)(max(fin - k, 0));
      for (n = 0; k < fin; k++, n++) if (k in O) createProperty2(result, n, O[k]);
      result.length = n;
      return result;
    }
  });
  return es_array_slice;
}
var getBuiltInPrototypeMethod;
var hasRequiredGetBuiltInPrototypeMethod;
function requireGetBuiltInPrototypeMethod() {
  if (hasRequiredGetBuiltInPrototypeMethod) return getBuiltInPrototypeMethod;
  hasRequiredGetBuiltInPrototypeMethod = 1;
  var globalThis2 = requireGlobalThis();
  var path2 = requirePath();
  getBuiltInPrototypeMethod = function(CONSTRUCTOR, METHOD) {
    var Namespace = path2[CONSTRUCTOR + "Prototype"];
    var pureMethod = Namespace && Namespace[METHOD];
    if (pureMethod) return pureMethod;
    var NativeConstructor = globalThis2[CONSTRUCTOR];
    var NativePrototype = NativeConstructor && NativeConstructor.prototype;
    return NativePrototype && NativePrototype[METHOD];
  };
  return getBuiltInPrototypeMethod;
}
var slice$3;
var hasRequiredSlice$3;
function requireSlice$3() {
  if (hasRequiredSlice$3) return slice$3;
  hasRequiredSlice$3 = 1;
  requireEs_array_slice();
  var getBuiltInPrototypeMethod2 = requireGetBuiltInPrototypeMethod();
  slice$3 = getBuiltInPrototypeMethod2("Array", "slice");
  return slice$3;
}
var slice$2;
var hasRequiredSlice$2;
function requireSlice$2() {
  if (hasRequiredSlice$2) return slice$2;
  hasRequiredSlice$2 = 1;
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var method = requireSlice$3();
  var ArrayPrototype = Array.prototype;
  slice$2 = function(it2) {
    var own = it2.slice;
    return it2 === ArrayPrototype || isPrototypeOf(ArrayPrototype, it2) && own === ArrayPrototype.slice ? method : own;
  };
  return slice$2;
}
var slice$1;
var hasRequiredSlice$1;
function requireSlice$1() {
  if (hasRequiredSlice$1) return slice$1;
  hasRequiredSlice$1 = 1;
  var parent = requireSlice$2();
  slice$1 = parent;
  return slice$1;
}
var slice;
var hasRequiredSlice;
function requireSlice() {
  if (hasRequiredSlice) return slice;
  hasRequiredSlice = 1;
  slice = requireSlice$1();
  return slice;
}
var sliceExports = requireSlice();
var _sliceInstanceProperty = getDefaultExportFromCjs(sliceExports);
var es_reflect_ownKeys = {};
var ownKeys$5;
var hasRequiredOwnKeys$3;
function requireOwnKeys$3() {
  if (hasRequiredOwnKeys$3) return ownKeys$5;
  hasRequiredOwnKeys$3 = 1;
  var getBuiltIn2 = requireGetBuiltIn();
  var uncurryThis = requireFunctionUncurryThis();
  var getOwnPropertyNamesModule = requireObjectGetOwnPropertyNames();
  var getOwnPropertySymbolsModule = requireObjectGetOwnPropertySymbols();
  var anObject2 = requireAnObject();
  var concat2 = uncurryThis([].concat);
  ownKeys$5 = getBuiltIn2("Reflect", "ownKeys") || function ownKeys2(it2) {
    var keys2 = getOwnPropertyNamesModule.f(anObject2(it2));
    var getOwnPropertySymbols2 = getOwnPropertySymbolsModule.f;
    return getOwnPropertySymbols2 ? concat2(keys2, getOwnPropertySymbols2(it2)) : keys2;
  };
  return ownKeys$5;
}
var hasRequiredEs_reflect_ownKeys;
function requireEs_reflect_ownKeys() {
  if (hasRequiredEs_reflect_ownKeys) return es_reflect_ownKeys;
  hasRequiredEs_reflect_ownKeys = 1;
  var $ = require_export();
  var ownKeys2 = requireOwnKeys$3();
  $({ target: "Reflect", stat: true }, {
    ownKeys: ownKeys2
  });
  return es_reflect_ownKeys;
}
var ownKeys$4;
var hasRequiredOwnKeys$2;
function requireOwnKeys$2() {
  if (hasRequiredOwnKeys$2) return ownKeys$4;
  hasRequiredOwnKeys$2 = 1;
  requireEs_reflect_ownKeys();
  var path2 = requirePath();
  ownKeys$4 = path2.Reflect.ownKeys;
  return ownKeys$4;
}
var ownKeys$3;
var hasRequiredOwnKeys$1;
function requireOwnKeys$1() {
  if (hasRequiredOwnKeys$1) return ownKeys$3;
  hasRequiredOwnKeys$1 = 1;
  var parent = requireOwnKeys$2();
  ownKeys$3 = parent;
  return ownKeys$3;
}
var ownKeys$2;
var hasRequiredOwnKeys;
function requireOwnKeys() {
  if (hasRequiredOwnKeys) return ownKeys$2;
  hasRequiredOwnKeys = 1;
  ownKeys$2 = requireOwnKeys$1();
  return ownKeys$2;
}
var ownKeysExports = requireOwnKeys();
var _Reflect$ownKeys = getDefaultExportFromCjs(ownKeysExports);
var es_array_isArray = {};
var hasRequiredEs_array_isArray;
function requireEs_array_isArray() {
  if (hasRequiredEs_array_isArray) return es_array_isArray;
  hasRequiredEs_array_isArray = 1;
  var $ = require_export();
  var isArray2 = requireIsArray$3();
  $({ target: "Array", stat: true }, {
    isArray: isArray2
  });
  return es_array_isArray;
}
var isArray$2;
var hasRequiredIsArray$2;
function requireIsArray$2() {
  if (hasRequiredIsArray$2) return isArray$2;
  hasRequiredIsArray$2 = 1;
  requireEs_array_isArray();
  var path2 = requirePath();
  isArray$2 = path2.Array.isArray;
  return isArray$2;
}
var isArray$1;
var hasRequiredIsArray$1;
function requireIsArray$1() {
  if (hasRequiredIsArray$1) return isArray$1;
  hasRequiredIsArray$1 = 1;
  var parent = requireIsArray$2();
  isArray$1 = parent;
  return isArray$1;
}
var isArray;
var hasRequiredIsArray;
function requireIsArray() {
  if (hasRequiredIsArray) return isArray;
  hasRequiredIsArray = 1;
  isArray = requireIsArray$1();
  return isArray;
}
var isArrayExports = requireIsArray();
var _Array$isArray = getDefaultExportFromCjs(isArrayExports);
var es_array_map = {};
var hasRequiredEs_array_map;
function requireEs_array_map() {
  if (hasRequiredEs_array_map) return es_array_map;
  hasRequiredEs_array_map = 1;
  var $ = require_export();
  var $map = requireArrayIteration().map;
  var arrayMethodHasSpeciesSupport2 = requireArrayMethodHasSpeciesSupport();
  var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport2("map");
  $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
    map: function map2(callbackfn) {
      return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    }
  });
  return es_array_map;
}
var map$6;
var hasRequiredMap$6;
function requireMap$6() {
  if (hasRequiredMap$6) return map$6;
  hasRequiredMap$6 = 1;
  requireEs_array_map();
  var getBuiltInPrototypeMethod2 = requireGetBuiltInPrototypeMethod();
  map$6 = getBuiltInPrototypeMethod2("Array", "map");
  return map$6;
}
var map$5;
var hasRequiredMap$5;
function requireMap$5() {
  if (hasRequiredMap$5) return map$5;
  hasRequiredMap$5 = 1;
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var method = requireMap$6();
  var ArrayPrototype = Array.prototype;
  map$5 = function(it2) {
    var own = it2.map;
    return it2 === ArrayPrototype || isPrototypeOf(ArrayPrototype, it2) && own === ArrayPrototype.map ? method : own;
  };
  return map$5;
}
var map$4;
var hasRequiredMap$4;
function requireMap$4() {
  if (hasRequiredMap$4) return map$4;
  hasRequiredMap$4 = 1;
  var parent = requireMap$5();
  map$4 = parent;
  return map$4;
}
var map$3;
var hasRequiredMap$3;
function requireMap$3() {
  if (hasRequiredMap$3) return map$3;
  hasRequiredMap$3 = 1;
  map$3 = requireMap$4();
  return map$3;
}
var mapExports$1 = requireMap$3();
var _mapInstanceProperty = getDefaultExportFromCjs(mapExports$1);
var es_object_keys = {};
var hasRequiredEs_object_keys;
function requireEs_object_keys() {
  if (hasRequiredEs_object_keys) return es_object_keys;
  hasRequiredEs_object_keys = 1;
  var $ = require_export();
  var toObject2 = requireToObject();
  var nativeKeys = requireObjectKeys();
  var fails2 = requireFails();
  var FAILS_ON_PRIMITIVES = fails2(function() {
    nativeKeys(1);
  });
  $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
    keys: function keys2(it2) {
      return nativeKeys(toObject2(it2));
    }
  });
  return es_object_keys;
}
var keys$6;
var hasRequiredKeys$6;
function requireKeys$6() {
  if (hasRequiredKeys$6) return keys$6;
  hasRequiredKeys$6 = 1;
  requireEs_object_keys();
  var path2 = requirePath();
  keys$6 = path2.Object.keys;
  return keys$6;
}
var keys$5;
var hasRequiredKeys$5;
function requireKeys$5() {
  if (hasRequiredKeys$5) return keys$5;
  hasRequiredKeys$5 = 1;
  var parent = requireKeys$6();
  keys$5 = parent;
  return keys$5;
}
var keys$4;
var hasRequiredKeys$4;
function requireKeys$4() {
  if (hasRequiredKeys$4) return keys$4;
  hasRequiredKeys$4 = 1;
  keys$4 = requireKeys$5();
  return keys$4;
}
var keysExports$1 = requireKeys$4();
var _Object$keys = getDefaultExportFromCjs(keysExports$1);
var es_date_now = {};
var hasRequiredEs_date_now;
function requireEs_date_now() {
  if (hasRequiredEs_date_now) return es_date_now;
  hasRequiredEs_date_now = 1;
  var $ = require_export();
  var uncurryThis = requireFunctionUncurryThis();
  var $Date = Date;
  var thisTimeValue = uncurryThis($Date.prototype.getTime);
  $({ target: "Date", stat: true }, {
    now: function now2() {
      return thisTimeValue(new $Date());
    }
  });
  return es_date_now;
}
var now$3;
var hasRequiredNow$2;
function requireNow$2() {
  if (hasRequiredNow$2) return now$3;
  hasRequiredNow$2 = 1;
  requireEs_date_now();
  var path2 = requirePath();
  now$3 = path2.Date.now;
  return now$3;
}
var now$2;
var hasRequiredNow$1;
function requireNow$1() {
  if (hasRequiredNow$1) return now$2;
  hasRequiredNow$1 = 1;
  var parent = requireNow$2();
  now$2 = parent;
  return now$2;
}
var now$1;
var hasRequiredNow;
function requireNow() {
  if (hasRequiredNow) return now$1;
  hasRequiredNow = 1;
  now$1 = requireNow$1();
  return now$1;
}
var nowExports = requireNow();
var _Date$now = getDefaultExportFromCjs(nowExports);
var es_function_bind = {};
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var aCallable2 = requireACallable();
  var isObject2 = requireIsObject();
  var hasOwn = requireHasOwnProperty();
  var arraySlice2 = requireArraySlice();
  var NATIVE_BIND = requireFunctionBindNative();
  var $Function = Function;
  var concat2 = uncurryThis([].concat);
  var join = uncurryThis([].join);
  var factories = {};
  var construct = function(C, argsLength, args) {
    if (!hasOwn(factories, argsLength)) {
      var list = [];
      var i = 0;
      for (; i < argsLength; i++) list[i] = "a[" + i + "]";
      factories[argsLength] = $Function("C,a", "return new C(" + join(list, ",") + ")");
    }
    return factories[argsLength](C, args);
  };
  functionBind = NATIVE_BIND ? $Function.bind : function bind2(that) {
    var F = aCallable2(this);
    var Prototype = F.prototype;
    var partArgs = arraySlice2(arguments, 1);
    var boundFunction = function bound() {
      var args = concat2(partArgs, arraySlice2(arguments));
      return this instanceof boundFunction ? construct(F, args.length, args) : F.apply(that, args);
    };
    if (isObject2(Prototype)) boundFunction.prototype = Prototype;
    return boundFunction;
  };
  return functionBind;
}
var hasRequiredEs_function_bind;
function requireEs_function_bind() {
  if (hasRequiredEs_function_bind) return es_function_bind;
  hasRequiredEs_function_bind = 1;
  var $ = require_export();
  var bind2 = requireFunctionBind();
  $({ target: "Function", proto: true, forced: Function.bind !== bind2 }, {
    bind: bind2
  });
  return es_function_bind;
}
var bind$3;
var hasRequiredBind$3;
function requireBind$3() {
  if (hasRequiredBind$3) return bind$3;
  hasRequiredBind$3 = 1;
  requireEs_function_bind();
  var getBuiltInPrototypeMethod2 = requireGetBuiltInPrototypeMethod();
  bind$3 = getBuiltInPrototypeMethod2("Function", "bind");
  return bind$3;
}
var bind$2;
var hasRequiredBind$2;
function requireBind$2() {
  if (hasRequiredBind$2) return bind$2;
  hasRequiredBind$2 = 1;
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var method = requireBind$3();
  var FunctionPrototype = Function.prototype;
  bind$2 = function(it2) {
    var own = it2.bind;
    return it2 === FunctionPrototype || isPrototypeOf(FunctionPrototype, it2) && own === FunctionPrototype.bind ? method : own;
  };
  return bind$2;
}
var bind$1;
var hasRequiredBind$1;
function requireBind$1() {
  if (hasRequiredBind$1) return bind$1;
  hasRequiredBind$1 = 1;
  var parent = requireBind$2();
  bind$1 = parent;
  return bind$1;
}
var bind;
var hasRequiredBind;
function requireBind() {
  if (hasRequiredBind) return bind;
  hasRequiredBind = 1;
  bind = requireBind$1();
  return bind;
}
var bindExports = requireBind();
var _bindInstanceProperty = getDefaultExportFromCjs(bindExports);
var es_array_forEach = {};
var arrayMethodIsStrict;
var hasRequiredArrayMethodIsStrict;
function requireArrayMethodIsStrict() {
  if (hasRequiredArrayMethodIsStrict) return arrayMethodIsStrict;
  hasRequiredArrayMethodIsStrict = 1;
  var fails2 = requireFails();
  arrayMethodIsStrict = function(METHOD_NAME, argument) {
    var method = [][METHOD_NAME];
    return !!method && fails2(function() {
      method.call(null, argument || function() {
        return 1;
      }, 1);
    });
  };
  return arrayMethodIsStrict;
}
var arrayForEach;
var hasRequiredArrayForEach;
function requireArrayForEach() {
  if (hasRequiredArrayForEach) return arrayForEach;
  hasRequiredArrayForEach = 1;
  var $forEach = requireArrayIteration().forEach;
  var arrayMethodIsStrict2 = requireArrayMethodIsStrict();
  var STRICT_METHOD = arrayMethodIsStrict2("forEach");
  arrayForEach = !STRICT_METHOD ? function forEach2(callbackfn) {
    return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  } : [].forEach;
  return arrayForEach;
}
var hasRequiredEs_array_forEach;
function requireEs_array_forEach() {
  if (hasRequiredEs_array_forEach) return es_array_forEach;
  hasRequiredEs_array_forEach = 1;
  var $ = require_export();
  var forEach2 = requireArrayForEach();
  $({ target: "Array", proto: true, forced: [].forEach !== forEach2 }, {
    forEach: forEach2
  });
  return es_array_forEach;
}
var forEach$4;
var hasRequiredForEach$3;
function requireForEach$3() {
  if (hasRequiredForEach$3) return forEach$4;
  hasRequiredForEach$3 = 1;
  requireEs_array_forEach();
  var getBuiltInPrototypeMethod2 = requireGetBuiltInPrototypeMethod();
  forEach$4 = getBuiltInPrototypeMethod2("Array", "forEach");
  return forEach$4;
}
var forEach$3;
var hasRequiredForEach$2;
function requireForEach$2() {
  if (hasRequiredForEach$2) return forEach$3;
  hasRequiredForEach$2 = 1;
  var parent = requireForEach$3();
  forEach$3 = parent;
  return forEach$3;
}
var forEach$2;
var hasRequiredForEach$1;
function requireForEach$1() {
  if (hasRequiredForEach$1) return forEach$2;
  hasRequiredForEach$1 = 1;
  var classof2 = requireClassof();
  var hasOwn = requireHasOwnProperty();
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var method = requireForEach$2();
  var ArrayPrototype = Array.prototype;
  var DOMIterables = {
    DOMTokenList: true,
    NodeList: true
  };
  forEach$2 = function(it2) {
    var own = it2.forEach;
    return it2 === ArrayPrototype || isPrototypeOf(ArrayPrototype, it2) && own === ArrayPrototype.forEach || hasOwn(DOMIterables, classof2(it2)) ? method : own;
  };
  return forEach$2;
}
var forEach$1;
var hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach) return forEach$1;
  hasRequiredForEach = 1;
  forEach$1 = requireForEach$1();
  return forEach$1;
}
var forEachExports = requireForEach();
var _forEachInstanceProperty = getDefaultExportFromCjs(forEachExports);
var es_array_reverse = {};
var hasRequiredEs_array_reverse;
function requireEs_array_reverse() {
  if (hasRequiredEs_array_reverse) return es_array_reverse;
  hasRequiredEs_array_reverse = 1;
  var $ = require_export();
  var uncurryThis = requireFunctionUncurryThis();
  var isArray2 = requireIsArray$3();
  var nativeReverse = uncurryThis([].reverse);
  var test = [1, 2];
  $({ target: "Array", proto: true, forced: String(test) === String(test.reverse()) }, {
    reverse: function reverse2() {
      if (isArray2(this)) this.length = this.length;
      return nativeReverse(this);
    }
  });
  return es_array_reverse;
}
var reverse$3;
var hasRequiredReverse$3;
function requireReverse$3() {
  if (hasRequiredReverse$3) return reverse$3;
  hasRequiredReverse$3 = 1;
  requireEs_array_reverse();
  var getBuiltInPrototypeMethod2 = requireGetBuiltInPrototypeMethod();
  reverse$3 = getBuiltInPrototypeMethod2("Array", "reverse");
  return reverse$3;
}
var reverse$2;
var hasRequiredReverse$2;
function requireReverse$2() {
  if (hasRequiredReverse$2) return reverse$2;
  hasRequiredReverse$2 = 1;
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var method = requireReverse$3();
  var ArrayPrototype = Array.prototype;
  reverse$2 = function(it2) {
    var own = it2.reverse;
    return it2 === ArrayPrototype || isPrototypeOf(ArrayPrototype, it2) && own === ArrayPrototype.reverse ? method : own;
  };
  return reverse$2;
}
var reverse$1;
var hasRequiredReverse$1;
function requireReverse$1() {
  if (hasRequiredReverse$1) return reverse$1;
  hasRequiredReverse$1 = 1;
  var parent = requireReverse$2();
  reverse$1 = parent;
  return reverse$1;
}
var reverse;
var hasRequiredReverse;
function requireReverse() {
  if (hasRequiredReverse) return reverse;
  hasRequiredReverse = 1;
  reverse = requireReverse$1();
  return reverse;
}
var reverseExports = requireReverse();
var _reverseInstanceProperty = getDefaultExportFromCjs(reverseExports);
var es_array_splice = {};
var arraySetLength;
var hasRequiredArraySetLength;
function requireArraySetLength() {
  if (hasRequiredArraySetLength) return arraySetLength;
  hasRequiredArraySetLength = 1;
  var DESCRIPTORS = requireDescriptors();
  var isArray2 = requireIsArray$3();
  var $TypeError = TypeError;
  var getOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;
  var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !(function() {
    if (this !== void 0) return true;
    try {
      Object.defineProperty([], "length", { writable: false }).length = 1;
    } catch (error) {
      return error instanceof TypeError;
    }
  })();
  arraySetLength = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function(O, length) {
    if (isArray2(O) && !getOwnPropertyDescriptor2(O, "length").writable) {
      throw new $TypeError("Cannot set read only .length");
    }
    return O.length = length;
  } : function(O, length) {
    return O.length = length;
  };
  return arraySetLength;
}
var deletePropertyOrThrow;
var hasRequiredDeletePropertyOrThrow;
function requireDeletePropertyOrThrow() {
  if (hasRequiredDeletePropertyOrThrow) return deletePropertyOrThrow;
  hasRequiredDeletePropertyOrThrow = 1;
  var tryToString2 = requireTryToString();
  var $TypeError = TypeError;
  deletePropertyOrThrow = function(O, P) {
    if (!delete O[P]) throw new $TypeError("Cannot delete property " + tryToString2(P) + " of " + tryToString2(O));
  };
  return deletePropertyOrThrow;
}
var hasRequiredEs_array_splice;
function requireEs_array_splice() {
  if (hasRequiredEs_array_splice) return es_array_splice;
  hasRequiredEs_array_splice = 1;
  var $ = require_export();
  var toObject2 = requireToObject();
  var toAbsoluteIndex2 = requireToAbsoluteIndex();
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var setArrayLength = requireArraySetLength();
  var doesNotExceedSafeInteger2 = requireDoesNotExceedSafeInteger();
  var arraySpeciesCreate2 = requireArraySpeciesCreate();
  var createProperty2 = requireCreateProperty();
  var deletePropertyOrThrow2 = requireDeletePropertyOrThrow();
  var arrayMethodHasSpeciesSupport2 = requireArrayMethodHasSpeciesSupport();
  var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport2("splice");
  var max = Math.max;
  var min = Math.min;
  $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
    splice: function splice2(start, deleteCount) {
      var O = toObject2(this);
      var len = lengthOfArrayLike2(O);
      var actualStart = toAbsoluteIndex2(start, len);
      var argumentsLength = arguments.length;
      var insertCount, actualDeleteCount, A, k, from, to;
      if (argumentsLength === 0) {
        insertCount = actualDeleteCount = 0;
      } else if (argumentsLength === 1) {
        insertCount = 0;
        actualDeleteCount = len - actualStart;
      } else {
        insertCount = argumentsLength - 2;
        actualDeleteCount = min(max(toIntegerOrInfinity2(deleteCount), 0), len - actualStart);
      }
      doesNotExceedSafeInteger2(len + insertCount - actualDeleteCount);
      A = arraySpeciesCreate2(O, actualDeleteCount);
      for (k = 0; k < actualDeleteCount; k++) {
        from = actualStart + k;
        if (from in O) createProperty2(A, k, O[from]);
      }
      A.length = actualDeleteCount;
      if (insertCount < actualDeleteCount) {
        for (k = actualStart; k < len - actualDeleteCount; k++) {
          from = k + actualDeleteCount;
          to = k + insertCount;
          if (from in O) O[to] = O[from];
          else deletePropertyOrThrow2(O, to);
        }
        for (k = len; k > len - actualDeleteCount + insertCount; k--) deletePropertyOrThrow2(O, k - 1);
      } else if (insertCount > actualDeleteCount) {
        for (k = len - actualDeleteCount; k > actualStart; k--) {
          from = k + actualDeleteCount - 1;
          to = k + insertCount - 1;
          if (from in O) O[to] = O[from];
          else deletePropertyOrThrow2(O, to);
        }
      }
      for (k = 0; k < insertCount; k++) {
        O[k + actualStart] = arguments[k + 2];
      }
      setArrayLength(O, len - actualDeleteCount + insertCount);
      return A;
    }
  });
  return es_array_splice;
}
var splice$3;
var hasRequiredSplice$3;
function requireSplice$3() {
  if (hasRequiredSplice$3) return splice$3;
  hasRequiredSplice$3 = 1;
  requireEs_array_splice();
  var getBuiltInPrototypeMethod2 = requireGetBuiltInPrototypeMethod();
  splice$3 = getBuiltInPrototypeMethod2("Array", "splice");
  return splice$3;
}
var splice$2;
var hasRequiredSplice$2;
function requireSplice$2() {
  if (hasRequiredSplice$2) return splice$2;
  hasRequiredSplice$2 = 1;
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var method = requireSplice$3();
  var ArrayPrototype = Array.prototype;
  splice$2 = function(it2) {
    var own = it2.splice;
    return it2 === ArrayPrototype || isPrototypeOf(ArrayPrototype, it2) && own === ArrayPrototype.splice ? method : own;
  };
  return splice$2;
}
var splice$1;
var hasRequiredSplice$1;
function requireSplice$1() {
  if (hasRequiredSplice$1) return splice$1;
  hasRequiredSplice$1 = 1;
  var parent = requireSplice$2();
  splice$1 = parent;
  return splice$1;
}
var splice;
var hasRequiredSplice;
function requireSplice() {
  if (hasRequiredSplice) return splice;
  hasRequiredSplice = 1;
  splice = requireSplice$1();
  return splice;
}
var spliceExports = requireSplice();
var _spliceInstanceProperty = getDefaultExportFromCjs(spliceExports);
var es_object_assign = {};
var objectAssign;
var hasRequiredObjectAssign;
function requireObjectAssign() {
  if (hasRequiredObjectAssign) return objectAssign;
  hasRequiredObjectAssign = 1;
  var DESCRIPTORS = requireDescriptors();
  var uncurryThis = requireFunctionUncurryThis();
  var call = requireFunctionCall();
  var fails2 = requireFails();
  var objectKeys2 = requireObjectKeys();
  var getOwnPropertySymbolsModule = requireObjectGetOwnPropertySymbols();
  var propertyIsEnumerableModule = requireObjectPropertyIsEnumerable();
  var toObject2 = requireToObject();
  var IndexedObject = requireIndexedObject();
  var $assign = Object.assign;
  var defineProperty2 = Object.defineProperty;
  var concat2 = uncurryThis([].concat);
  objectAssign = !$assign || fails2(function() {
    if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty2({}, "a", {
      enumerable: true,
      get: function() {
        defineProperty2(this, "b", {
          value: 3,
          enumerable: false
        });
      }
    }), { b: 2 })).b !== 1) return true;
    var A = {};
    var B = {};
    var symbol2 = /* @__PURE__ */ Symbol("assign detection");
    var alphabet = "abcdefghijklmnopqrst";
    A[symbol2] = 7;
    alphabet.split("").forEach(function(chr) {
      B[chr] = chr;
    });
    return $assign({}, A)[symbol2] !== 7 || objectKeys2($assign({}, B)).join("") !== alphabet;
  }) ? function assign2(target, source) {
    var T = toObject2(target);
    var argumentsLength = arguments.length;
    var index = 1;
    var getOwnPropertySymbols2 = getOwnPropertySymbolsModule.f;
    var propertyIsEnumerable = propertyIsEnumerableModule.f;
    while (argumentsLength > index) {
      var S = IndexedObject(arguments[index++]);
      var keys2 = getOwnPropertySymbols2 ? concat2(objectKeys2(S), getOwnPropertySymbols2(S)) : objectKeys2(S);
      var length = keys2.length;
      var j = 0;
      var key;
      while (length > j) {
        key = keys2[j++];
        if (!DESCRIPTORS || call(propertyIsEnumerable, S, key)) T[key] = S[key];
      }
    }
    return T;
  } : $assign;
  return objectAssign;
}
var hasRequiredEs_object_assign;
function requireEs_object_assign() {
  if (hasRequiredEs_object_assign) return es_object_assign;
  hasRequiredEs_object_assign = 1;
  var $ = require_export();
  var assign2 = requireObjectAssign();
  $({ target: "Object", stat: true, arity: 2, forced: Object.assign !== assign2 }, {
    assign: assign2
  });
  return es_object_assign;
}
var assign$4;
var hasRequiredAssign$2;
function requireAssign$2() {
  if (hasRequiredAssign$2) return assign$4;
  hasRequiredAssign$2 = 1;
  requireEs_object_assign();
  var path2 = requirePath();
  assign$4 = path2.Object.assign;
  return assign$4;
}
var assign$3;
var hasRequiredAssign$1;
function requireAssign$1() {
  if (hasRequiredAssign$1) return assign$3;
  hasRequiredAssign$1 = 1;
  var parent = requireAssign$2();
  assign$3 = parent;
  return assign$3;
}
var assign$2;
var hasRequiredAssign;
function requireAssign() {
  if (hasRequiredAssign) return assign$2;
  hasRequiredAssign = 1;
  assign$2 = requireAssign$1();
  return assign$2;
}
var assignExports = requireAssign();
var _Object$assign = getDefaultExportFromCjs(assignExports);
var es_array_includes = {};
var hasRequiredEs_array_includes;
function requireEs_array_includes() {
  if (hasRequiredEs_array_includes) return es_array_includes;
  hasRequiredEs_array_includes = 1;
  var $ = require_export();
  var $includes = requireArrayIncludes().includes;
  var fails2 = requireFails();
  var addToUnscopables2 = requireAddToUnscopables();
  var BROKEN_ON_SPARSE = fails2(function() {
    return !Array(1).includes();
  });
  $({ target: "Array", proto: true, forced: BROKEN_ON_SPARSE }, {
    includes: function includes2(el) {
      return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
    }
  });
  addToUnscopables2("includes");
  return es_array_includes;
}
var includes$4;
var hasRequiredIncludes$4;
function requireIncludes$4() {
  if (hasRequiredIncludes$4) return includes$4;
  hasRequiredIncludes$4 = 1;
  requireEs_array_includes();
  var getBuiltInPrototypeMethod2 = requireGetBuiltInPrototypeMethod();
  includes$4 = getBuiltInPrototypeMethod2("Array", "includes");
  return includes$4;
}
var es_string_includes = {};
var isRegexp;
var hasRequiredIsRegexp;
function requireIsRegexp() {
  if (hasRequiredIsRegexp) return isRegexp;
  hasRequiredIsRegexp = 1;
  var isObject2 = requireIsObject();
  var classof2 = requireClassofRaw();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var MATCH = wellKnownSymbol2("match");
  isRegexp = function(it2) {
    var isRegExp;
    return isObject2(it2) && ((isRegExp = it2[MATCH]) !== void 0 ? !!isRegExp : classof2(it2) === "RegExp");
  };
  return isRegexp;
}
var notARegexp;
var hasRequiredNotARegexp;
function requireNotARegexp() {
  if (hasRequiredNotARegexp) return notARegexp;
  hasRequiredNotARegexp = 1;
  var isRegExp = requireIsRegexp();
  var $TypeError = TypeError;
  notARegexp = function(it2) {
    if (isRegExp(it2)) {
      throw new $TypeError("The method doesn't accept regular expressions");
    }
    return it2;
  };
  return notARegexp;
}
var correctIsRegexpLogic;
var hasRequiredCorrectIsRegexpLogic;
function requireCorrectIsRegexpLogic() {
  if (hasRequiredCorrectIsRegexpLogic) return correctIsRegexpLogic;
  hasRequiredCorrectIsRegexpLogic = 1;
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var MATCH = wellKnownSymbol2("match");
  correctIsRegexpLogic = function(METHOD_NAME) {
    var regexp = /./;
    try {
      "/./"[METHOD_NAME](regexp);
    } catch (error1) {
      try {
        regexp[MATCH] = false;
        return "/./"[METHOD_NAME](regexp);
      } catch (error2) {
      }
    }
    return false;
  };
  return correctIsRegexpLogic;
}
var hasRequiredEs_string_includes;
function requireEs_string_includes() {
  if (hasRequiredEs_string_includes) return es_string_includes;
  hasRequiredEs_string_includes = 1;
  var $ = require_export();
  var uncurryThis = requireFunctionUncurryThis();
  var notARegExp = requireNotARegexp();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var toString2 = requireToString();
  var correctIsRegExpLogic = requireCorrectIsRegexpLogic();
  var stringIndexOf = uncurryThis("".indexOf);
  $({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
    includes: function includes2(searchString) {
      return !!~stringIndexOf(
        toString2(requireObjectCoercible2(this)),
        toString2(notARegExp(searchString)),
        arguments.length > 1 ? arguments[1] : void 0
      );
    }
  });
  return es_string_includes;
}
var includes$3;
var hasRequiredIncludes$3;
function requireIncludes$3() {
  if (hasRequiredIncludes$3) return includes$3;
  hasRequiredIncludes$3 = 1;
  requireEs_string_includes();
  var getBuiltInPrototypeMethod2 = requireGetBuiltInPrototypeMethod();
  includes$3 = getBuiltInPrototypeMethod2("String", "includes");
  return includes$3;
}
var includes$2;
var hasRequiredIncludes$2;
function requireIncludes$2() {
  if (hasRequiredIncludes$2) return includes$2;
  hasRequiredIncludes$2 = 1;
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var arrayMethod = requireIncludes$4();
  var stringMethod = requireIncludes$3();
  var ArrayPrototype = Array.prototype;
  var StringPrototype = String.prototype;
  includes$2 = function(it2) {
    var own = it2.includes;
    if (it2 === ArrayPrototype || isPrototypeOf(ArrayPrototype, it2) && own === ArrayPrototype.includes) return arrayMethod;
    if (typeof it2 == "string" || it2 === StringPrototype || isPrototypeOf(StringPrototype, it2) && own === StringPrototype.includes) {
      return stringMethod;
    }
    return own;
  };
  return includes$2;
}
var includes$1;
var hasRequiredIncludes$1;
function requireIncludes$1() {
  if (hasRequiredIncludes$1) return includes$1;
  hasRequiredIncludes$1 = 1;
  var parent = requireIncludes$2();
  includes$1 = parent;
  return includes$1;
}
var includes;
var hasRequiredIncludes;
function requireIncludes() {
  if (hasRequiredIncludes) return includes;
  hasRequiredIncludes = 1;
  includes = requireIncludes$1();
  return includes;
}
var includesExports = requireIncludes();
var _includesInstanceProperty = getDefaultExportFromCjs(includesExports);
var es_object_getPrototypeOf = {};
var hasRequiredEs_object_getPrototypeOf;
function requireEs_object_getPrototypeOf() {
  if (hasRequiredEs_object_getPrototypeOf) return es_object_getPrototypeOf;
  hasRequiredEs_object_getPrototypeOf = 1;
  var $ = require_export();
  var fails2 = requireFails();
  var toObject2 = requireToObject();
  var nativeGetPrototypeOf = requireObjectGetPrototypeOf();
  var CORRECT_PROTOTYPE_GETTER = requireCorrectPrototypeGetter();
  var FAILS_ON_PRIMITIVES = fails2(function() {
    nativeGetPrototypeOf(1);
  });
  $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
    getPrototypeOf: function getPrototypeOf2(it2) {
      return nativeGetPrototypeOf(toObject2(it2));
    }
  });
  return es_object_getPrototypeOf;
}
var getPrototypeOf$2;
var hasRequiredGetPrototypeOf$2;
function requireGetPrototypeOf$2() {
  if (hasRequiredGetPrototypeOf$2) return getPrototypeOf$2;
  hasRequiredGetPrototypeOf$2 = 1;
  requireEs_object_getPrototypeOf();
  var path2 = requirePath();
  getPrototypeOf$2 = path2.Object.getPrototypeOf;
  return getPrototypeOf$2;
}
var getPrototypeOf$1;
var hasRequiredGetPrototypeOf$1;
function requireGetPrototypeOf$1() {
  if (hasRequiredGetPrototypeOf$1) return getPrototypeOf$1;
  hasRequiredGetPrototypeOf$1 = 1;
  var parent = requireGetPrototypeOf$2();
  getPrototypeOf$1 = parent;
  return getPrototypeOf$1;
}
var getPrototypeOf;
var hasRequiredGetPrototypeOf;
function requireGetPrototypeOf() {
  if (hasRequiredGetPrototypeOf) return getPrototypeOf;
  hasRequiredGetPrototypeOf = 1;
  getPrototypeOf = requireGetPrototypeOf$1();
  return getPrototypeOf;
}
var getPrototypeOfExports = requireGetPrototypeOf();
var _Object$getPrototypeOf = getDefaultExportFromCjs(getPrototypeOfExports);
var concat$3;
var hasRequiredConcat$3;
function requireConcat$3() {
  if (hasRequiredConcat$3) return concat$3;
  hasRequiredConcat$3 = 1;
  requireEs_array_concat();
  var getBuiltInPrototypeMethod2 = requireGetBuiltInPrototypeMethod();
  concat$3 = getBuiltInPrototypeMethod2("Array", "concat");
  return concat$3;
}
var concat$2;
var hasRequiredConcat$2;
function requireConcat$2() {
  if (hasRequiredConcat$2) return concat$2;
  hasRequiredConcat$2 = 1;
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var method = requireConcat$3();
  var ArrayPrototype = Array.prototype;
  concat$2 = function(it2) {
    var own = it2.concat;
    return it2 === ArrayPrototype || isPrototypeOf(ArrayPrototype, it2) && own === ArrayPrototype.concat ? method : own;
  };
  return concat$2;
}
var concat$1;
var hasRequiredConcat$1;
function requireConcat$1() {
  if (hasRequiredConcat$1) return concat$1;
  hasRequiredConcat$1 = 1;
  var parent = requireConcat$2();
  concat$1 = parent;
  return concat$1;
}
var concat;
var hasRequiredConcat;
function requireConcat() {
  if (hasRequiredConcat) return concat;
  hasRequiredConcat = 1;
  concat = requireConcat$1();
  return concat;
}
var concatExports = requireConcat();
var _concatInstanceProperty = getDefaultExportFromCjs(concatExports);
var es_array_filter = {};
var hasRequiredEs_array_filter;
function requireEs_array_filter() {
  if (hasRequiredEs_array_filter) return es_array_filter;
  hasRequiredEs_array_filter = 1;
  var $ = require_export();
  var $filter = requireArrayIteration().filter;
  var arrayMethodHasSpeciesSupport2 = requireArrayMethodHasSpeciesSupport();
  var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport2("filter");
  $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
    filter: function filter2(callbackfn) {
      return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    }
  });
  return es_array_filter;
}
var filter$3;
var hasRequiredFilter$3;
function requireFilter$3() {
  if (hasRequiredFilter$3) return filter$3;
  hasRequiredFilter$3 = 1;
  requireEs_array_filter();
  var getBuiltInPrototypeMethod2 = requireGetBuiltInPrototypeMethod();
  filter$3 = getBuiltInPrototypeMethod2("Array", "filter");
  return filter$3;
}
var filter$2;
var hasRequiredFilter$2;
function requireFilter$2() {
  if (hasRequiredFilter$2) return filter$2;
  hasRequiredFilter$2 = 1;
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var method = requireFilter$3();
  var ArrayPrototype = Array.prototype;
  filter$2 = function(it2) {
    var own = it2.filter;
    return it2 === ArrayPrototype || isPrototypeOf(ArrayPrototype, it2) && own === ArrayPrototype.filter ? method : own;
  };
  return filter$2;
}
var filter$1;
var hasRequiredFilter$1;
function requireFilter$1() {
  if (hasRequiredFilter$1) return filter$1;
  hasRequiredFilter$1 = 1;
  var parent = requireFilter$2();
  filter$1 = parent;
  return filter$1;
}
var filter;
var hasRequiredFilter;
function requireFilter() {
  if (hasRequiredFilter) return filter;
  hasRequiredFilter = 1;
  filter = requireFilter$1();
  return filter;
}
var filterExports = requireFilter();
var _filterInstanceProperty = getDefaultExportFromCjs(filterExports);
var es_object_values = {};
var objectToArray;
var hasRequiredObjectToArray;
function requireObjectToArray() {
  if (hasRequiredObjectToArray) return objectToArray;
  hasRequiredObjectToArray = 1;
  var DESCRIPTORS = requireDescriptors();
  var fails2 = requireFails();
  var uncurryThis = requireFunctionUncurryThis();
  var objectGetPrototypeOf2 = requireObjectGetPrototypeOf();
  var objectKeys2 = requireObjectKeys();
  var toIndexedObject2 = requireToIndexedObject();
  var $propertyIsEnumerable = requireObjectPropertyIsEnumerable().f;
  var propertyIsEnumerable = uncurryThis($propertyIsEnumerable);
  var push = uncurryThis([].push);
  var IE_BUG = DESCRIPTORS && fails2(function() {
    var O = /* @__PURE__ */ Object.create(null);
    O[2] = 2;
    return !propertyIsEnumerable(O, 2);
  });
  var createMethod = function(TO_ENTRIES) {
    return function(it2) {
      var O = toIndexedObject2(it2);
      var keys2 = objectKeys2(O);
      var IE_WORKAROUND = IE_BUG && objectGetPrototypeOf2(O) === null;
      var length = keys2.length;
      var i = 0;
      var result = [];
      var key;
      while (length > i) {
        key = keys2[i++];
        if (!DESCRIPTORS || (IE_WORKAROUND ? key in O : propertyIsEnumerable(O, key))) {
          push(result, TO_ENTRIES ? [key, O[key]] : O[key]);
        }
      }
      return result;
    };
  };
  objectToArray = {
    // `Object.entries` method
    // https://tc39.es/ecma262/#sec-object.entries
    entries: createMethod(true),
    // `Object.values` method
    // https://tc39.es/ecma262/#sec-object.values
    values: createMethod(false)
  };
  return objectToArray;
}
var hasRequiredEs_object_values;
function requireEs_object_values() {
  if (hasRequiredEs_object_values) return es_object_values;
  hasRequiredEs_object_values = 1;
  var $ = require_export();
  var $values = requireObjectToArray().values;
  $({ target: "Object", stat: true }, {
    values: function values2(O) {
      return $values(O);
    }
  });
  return es_object_values;
}
var values$6;
var hasRequiredValues$6;
function requireValues$6() {
  if (hasRequiredValues$6) return values$6;
  hasRequiredValues$6 = 1;
  requireEs_object_values();
  var path2 = requirePath();
  values$6 = path2.Object.values;
  return values$6;
}
var values$5;
var hasRequiredValues$5;
function requireValues$5() {
  if (hasRequiredValues$5) return values$5;
  hasRequiredValues$5 = 1;
  var parent = requireValues$6();
  values$5 = parent;
  return values$5;
}
var values$4;
var hasRequiredValues$4;
function requireValues$4() {
  if (hasRequiredValues$4) return values$4;
  hasRequiredValues$4 = 1;
  values$4 = requireValues$5();
  return values$4;
}
var valuesExports$1 = requireValues$4();
var _Object$values = getDefaultExportFromCjs(valuesExports$1);
var es_parseInt = {};
var whitespaces;
var hasRequiredWhitespaces;
function requireWhitespaces() {
  if (hasRequiredWhitespaces) return whitespaces;
  hasRequiredWhitespaces = 1;
  whitespaces = "	\n\v\f\r \u2028\u2029\uFEFF";
  return whitespaces;
}
var stringTrim;
var hasRequiredStringTrim;
function requireStringTrim() {
  if (hasRequiredStringTrim) return stringTrim;
  hasRequiredStringTrim = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var toString2 = requireToString();
  var whitespaces2 = requireWhitespaces();
  var replace = uncurryThis("".replace);
  var ltrim = RegExp("^[" + whitespaces2 + "]+");
  var rtrim = RegExp("(^|[^" + whitespaces2 + "])[" + whitespaces2 + "]+$");
  var createMethod = function(TYPE) {
    return function($this) {
      var string2 = toString2(requireObjectCoercible2($this));
      if (TYPE & 1) string2 = replace(string2, ltrim, "");
      if (TYPE & 2) string2 = replace(string2, rtrim, "$1");
      return string2;
    };
  };
  stringTrim = {
    // `String.prototype.{ trimLeft, trimStart }` methods
    // https://tc39.es/ecma262/#sec-string.prototype.trimstart
    start: createMethod(1),
    // `String.prototype.{ trimRight, trimEnd }` methods
    // https://tc39.es/ecma262/#sec-string.prototype.trimend
    end: createMethod(2),
    // `String.prototype.trim` method
    // https://tc39.es/ecma262/#sec-string.prototype.trim
    trim: createMethod(3)
  };
  return stringTrim;
}
var numberParseInt;
var hasRequiredNumberParseInt;
function requireNumberParseInt() {
  if (hasRequiredNumberParseInt) return numberParseInt;
  hasRequiredNumberParseInt = 1;
  var globalThis2 = requireGlobalThis();
  var fails2 = requireFails();
  var uncurryThis = requireFunctionUncurryThis();
  var toString2 = requireToString();
  var trim = requireStringTrim().trim;
  var whitespaces2 = requireWhitespaces();
  var $parseInt = globalThis2.parseInt;
  var Symbol2 = globalThis2.Symbol;
  var ITERATOR = Symbol2 && Symbol2.iterator;
  var hex = /^[+-]?0x/i;
  var exec = uncurryThis(hex.exec);
  var FORCED = $parseInt(whitespaces2 + "08") !== 8 || $parseInt(whitespaces2 + "0x16") !== 22 || ITERATOR && !fails2(function() {
    $parseInt(Object(ITERATOR));
  });
  numberParseInt = FORCED ? function parseInt2(string2, radix) {
    var S = trim(toString2(string2));
    return $parseInt(S, radix >>> 0 || (exec(hex, S) ? 16 : 10));
  } : $parseInt;
  return numberParseInt;
}
var hasRequiredEs_parseInt;
function requireEs_parseInt() {
  if (hasRequiredEs_parseInt) return es_parseInt;
  hasRequiredEs_parseInt = 1;
  var $ = require_export();
  var $parseInt = requireNumberParseInt();
  $({ global: true, forced: parseInt !== $parseInt }, {
    parseInt: $parseInt
  });
  return es_parseInt;
}
var _parseInt$3;
var hasRequired_parseInt$2;
function require_parseInt$2() {
  if (hasRequired_parseInt$2) return _parseInt$3;
  hasRequired_parseInt$2 = 1;
  requireEs_parseInt();
  var path2 = requirePath();
  _parseInt$3 = path2.parseInt;
  return _parseInt$3;
}
var _parseInt$2;
var hasRequired_parseInt$1;
function require_parseInt$1() {
  if (hasRequired_parseInt$1) return _parseInt$2;
  hasRequired_parseInt$1 = 1;
  var parent = require_parseInt$2();
  _parseInt$2 = parent;
  return _parseInt$2;
}
var _parseInt$1;
var hasRequired_parseInt;
function require_parseInt() {
  if (hasRequired_parseInt) return _parseInt$1;
  hasRequired_parseInt = 1;
  _parseInt$1 = require_parseInt$1();
  return _parseInt$1;
}
var _parseIntExports = require_parseInt();
var _parseInt = getDefaultExportFromCjs(_parseIntExports);
var es_array_indexOf = {};
var hasRequiredEs_array_indexOf;
function requireEs_array_indexOf() {
  if (hasRequiredEs_array_indexOf) return es_array_indexOf;
  hasRequiredEs_array_indexOf = 1;
  var $ = require_export();
  var uncurryThis = requireFunctionUncurryThisClause();
  var $indexOf = requireArrayIncludes().indexOf;
  var arrayMethodIsStrict2 = requireArrayMethodIsStrict();
  var nativeIndexOf = uncurryThis([].indexOf);
  var NEGATIVE_ZERO = !!nativeIndexOf && 1 / nativeIndexOf([1], 1, -0) < 0;
  var FORCED = NEGATIVE_ZERO || !arrayMethodIsStrict2("indexOf");
  $({ target: "Array", proto: true, forced: FORCED }, {
    indexOf: function indexOf2(searchElement) {
      var fromIndex = arguments.length > 1 ? arguments[1] : void 0;
      return NEGATIVE_ZERO ? nativeIndexOf(this, searchElement, fromIndex) || 0 : $indexOf(this, searchElement, fromIndex);
    }
  });
  return es_array_indexOf;
}
var indexOf$3;
var hasRequiredIndexOf$3;
function requireIndexOf$3() {
  if (hasRequiredIndexOf$3) return indexOf$3;
  hasRequiredIndexOf$3 = 1;
  requireEs_array_indexOf();
  var getBuiltInPrototypeMethod2 = requireGetBuiltInPrototypeMethod();
  indexOf$3 = getBuiltInPrototypeMethod2("Array", "indexOf");
  return indexOf$3;
}
var indexOf$2;
var hasRequiredIndexOf$2;
function requireIndexOf$2() {
  if (hasRequiredIndexOf$2) return indexOf$2;
  hasRequiredIndexOf$2 = 1;
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var method = requireIndexOf$3();
  var ArrayPrototype = Array.prototype;
  indexOf$2 = function(it2) {
    var own = it2.indexOf;
    return it2 === ArrayPrototype || isPrototypeOf(ArrayPrototype, it2) && own === ArrayPrototype.indexOf ? method : own;
  };
  return indexOf$2;
}
var indexOf$1;
var hasRequiredIndexOf$1;
function requireIndexOf$1() {
  if (hasRequiredIndexOf$1) return indexOf$1;
  hasRequiredIndexOf$1 = 1;
  var parent = requireIndexOf$2();
  indexOf$1 = parent;
  return indexOf$1;
}
var indexOf;
var hasRequiredIndexOf;
function requireIndexOf() {
  if (hasRequiredIndexOf) return indexOf;
  hasRequiredIndexOf = 1;
  indexOf = requireIndexOf$1();
  return indexOf;
}
var indexOfExports = requireIndexOf();
var _indexOfInstanceProperty = getDefaultExportFromCjs(indexOfExports);
var es_object_entries = {};
var hasRequiredEs_object_entries;
function requireEs_object_entries() {
  if (hasRequiredEs_object_entries) return es_object_entries;
  hasRequiredEs_object_entries = 1;
  var $ = require_export();
  var $entries = requireObjectToArray().entries;
  $({ target: "Object", stat: true }, {
    entries: function entries2(O) {
      return $entries(O);
    }
  });
  return es_object_entries;
}
var entries$6;
var hasRequiredEntries$6;
function requireEntries$6() {
  if (hasRequiredEntries$6) return entries$6;
  hasRequiredEntries$6 = 1;
  requireEs_object_entries();
  var path2 = requirePath();
  entries$6 = path2.Object.entries;
  return entries$6;
}
var entries$5;
var hasRequiredEntries$5;
function requireEntries$5() {
  if (hasRequiredEntries$5) return entries$5;
  hasRequiredEntries$5 = 1;
  var parent = requireEntries$6();
  entries$5 = parent;
  return entries$5;
}
var entries$4;
var hasRequiredEntries$4;
function requireEntries$4() {
  if (hasRequiredEntries$4) return entries$4;
  hasRequiredEntries$4 = 1;
  entries$4 = requireEntries$5();
  return entries$4;
}
var entriesExports$1 = requireEntries$4();
var _Object$entries = getDefaultExportFromCjs(entriesExports$1);
var es_object_create = {};
var hasRequiredEs_object_create;
function requireEs_object_create() {
  if (hasRequiredEs_object_create) return es_object_create;
  hasRequiredEs_object_create = 1;
  var $ = require_export();
  var DESCRIPTORS = requireDescriptors();
  var create2 = requireObjectCreate();
  $({ target: "Object", stat: true, sham: !DESCRIPTORS }, {
    create: create2
  });
  return es_object_create;
}
var create$2;
var hasRequiredCreate$2;
function requireCreate$2() {
  if (hasRequiredCreate$2) return create$2;
  hasRequiredCreate$2 = 1;
  requireEs_object_create();
  var path2 = requirePath();
  var Object2 = path2.Object;
  create$2 = function create2(P, D) {
    return Object2.create(P, D);
  };
  return create$2;
}
var create$1;
var hasRequiredCreate$1;
function requireCreate$1() {
  if (hasRequiredCreate$1) return create$1;
  hasRequiredCreate$1 = 1;
  var parent = requireCreate$2();
  create$1 = parent;
  return create$1;
}
var create;
var hasRequiredCreate;
function requireCreate() {
  if (hasRequiredCreate) return create;
  hasRequiredCreate = 1;
  create = requireCreate$1();
  return create;
}
var createExports = requireCreate();
var _Object$create = getDefaultExportFromCjs(createExports);
var es_date_toJson = {};
var stringRepeat;
var hasRequiredStringRepeat;
function requireStringRepeat() {
  if (hasRequiredStringRepeat) return stringRepeat;
  hasRequiredStringRepeat = 1;
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var toString2 = requireToString();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var $RangeError = RangeError;
  stringRepeat = function repeat2(count) {
    var str = toString2(requireObjectCoercible2(this));
    var result = "";
    var n = toIntegerOrInfinity2(count);
    if (n < 0 || n === Infinity) throw new $RangeError("Wrong number of repetitions");
    for (; n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
    return result;
  };
  return stringRepeat;
}
var stringPad;
var hasRequiredStringPad;
function requireStringPad() {
  if (hasRequiredStringPad) return stringPad;
  hasRequiredStringPad = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var toLength2 = requireToLength();
  var toString2 = requireToString();
  var $repeat = requireStringRepeat();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var repeat2 = uncurryThis($repeat);
  var stringSlice = uncurryThis("".slice);
  var ceil = Math.ceil;
  var createMethod = function(IS_END) {
    return function($this, maxLength, fillString) {
      var S = toString2(requireObjectCoercible2($this));
      var intMaxLength = toLength2(maxLength);
      var stringLength = S.length;
      var fillStr = fillString === void 0 ? " " : toString2(fillString);
      var fillLen, stringFiller;
      if (intMaxLength <= stringLength || fillStr === "") return S;
      fillLen = intMaxLength - stringLength;
      stringFiller = repeat2(fillStr, ceil(fillLen / fillStr.length));
      if (stringFiller.length > fillLen) stringFiller = stringSlice(stringFiller, 0, fillLen);
      return IS_END ? S + stringFiller : stringFiller + S;
    };
  };
  stringPad = {
    // `String.prototype.padStart` method
    // https://tc39.es/ecma262/#sec-string.prototype.padstart
    start: createMethod(false),
    // `String.prototype.padEnd` method
    // https://tc39.es/ecma262/#sec-string.prototype.padend
    end: createMethod(true)
  };
  return stringPad;
}
var dateToIsoString;
var hasRequiredDateToIsoString;
function requireDateToIsoString() {
  if (hasRequiredDateToIsoString) return dateToIsoString;
  hasRequiredDateToIsoString = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var fails2 = requireFails();
  var padStart = requireStringPad().start;
  var $RangeError = RangeError;
  var $isFinite = isFinite;
  var abs2 = Math.abs;
  var DatePrototype = Date.prototype;
  var nativeDateToISOString = DatePrototype.toISOString;
  var thisTimeValue = uncurryThis(DatePrototype.getTime);
  var getUTCDate = uncurryThis(DatePrototype.getUTCDate);
  var getUTCFullYear = uncurryThis(DatePrototype.getUTCFullYear);
  var getUTCHours = uncurryThis(DatePrototype.getUTCHours);
  var getUTCMilliseconds = uncurryThis(DatePrototype.getUTCMilliseconds);
  var getUTCMinutes = uncurryThis(DatePrototype.getUTCMinutes);
  var getUTCMonth = uncurryThis(DatePrototype.getUTCMonth);
  var getUTCSeconds = uncurryThis(DatePrototype.getUTCSeconds);
  dateToIsoString = fails2(function() {
    return nativeDateToISOString.call(new Date(-5e13 - 1)) !== "0385-07-25T07:06:39.999Z";
  }) || !fails2(function() {
    nativeDateToISOString.call(/* @__PURE__ */ new Date(NaN));
  }) ? function toISOString() {
    if (!$isFinite(thisTimeValue(this))) throw new $RangeError("Invalid time value");
    var date2 = this;
    var year = getUTCFullYear(date2);
    var milliseconds = getUTCMilliseconds(date2);
    var sign = year < 0 ? "-" : year > 9999 ? "+" : "";
    return sign + padStart(abs2(year), sign ? 6 : 4, 0) + "-" + padStart(getUTCMonth(date2) + 1, 2, 0) + "-" + padStart(getUTCDate(date2), 2, 0) + "T" + padStart(getUTCHours(date2), 2, 0) + ":" + padStart(getUTCMinutes(date2), 2, 0) + ":" + padStart(getUTCSeconds(date2), 2, 0) + "." + padStart(milliseconds, 3, 0) + "Z";
  } : nativeDateToISOString;
  return dateToIsoString;
}
var hasRequiredEs_date_toJson;
function requireEs_date_toJson() {
  if (hasRequiredEs_date_toJson) return es_date_toJson;
  hasRequiredEs_date_toJson = 1;
  var $ = require_export();
  var call = requireFunctionCall();
  var toObject2 = requireToObject();
  var toPrimitive2 = requireToPrimitive$5();
  var toISOString = requireDateToIsoString();
  var classof2 = requireClassofRaw();
  var fails2 = requireFails();
  var FORCED = fails2(function() {
    return (/* @__PURE__ */ new Date(NaN)).toJSON() !== null || call(Date.prototype.toJSON, { toISOString: function() {
      return 1;
    } }) !== 1;
  });
  $({ target: "Date", proto: true, forced: FORCED }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    toJSON: function toJSON(key) {
      var O = toObject2(this);
      var pv = toPrimitive2(O, "number");
      return typeof pv == "number" && !isFinite(pv) ? null : !("toISOString" in O) && classof2(O) === "Date" ? call(toISOString, O) : O.toISOString();
    }
  });
  return es_date_toJson;
}
var stringify$2;
var hasRequiredStringify$2;
function requireStringify$2() {
  if (hasRequiredStringify$2) return stringify$2;
  hasRequiredStringify$2 = 1;
  requireEs_date_toJson();
  requireEs_json_stringify();
  var path2 = requirePath();
  var apply = requireFunctionApply();
  if (!path2.JSON) path2.JSON = { stringify: JSON.stringify };
  stringify$2 = function stringify2(it2, replacer, space) {
    return apply(path2.JSON.stringify, null, arguments);
  };
  return stringify$2;
}
var stringify$1;
var hasRequiredStringify$1;
function requireStringify$1() {
  if (hasRequiredStringify$1) return stringify$1;
  hasRequiredStringify$1 = 1;
  var parent = requireStringify$2();
  stringify$1 = parent;
  return stringify$1;
}
var stringify;
var hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify) return stringify;
  hasRequiredStringify = 1;
  stringify = requireStringify$1();
  return stringify;
}
var stringifyExports = requireStringify();
var _JSON$stringify = getDefaultExportFromCjs(stringifyExports);
var web_timers = {};
var web_setInterval = {};
var environment;
var hasRequiredEnvironment;
function requireEnvironment() {
  if (hasRequiredEnvironment) return environment;
  hasRequiredEnvironment = 1;
  var globalThis2 = requireGlobalThis();
  var userAgent = requireEnvironmentUserAgent();
  var classof2 = requireClassofRaw();
  var userAgentStartsWith = function(string2) {
    return userAgent.slice(0, string2.length) === string2;
  };
  environment = (function() {
    if (userAgentStartsWith("Bun/")) return "BUN";
    if (userAgentStartsWith("Cloudflare-Workers")) return "CLOUDFLARE";
    if (userAgentStartsWith("Deno/")) return "DENO";
    if (userAgentStartsWith("Node.js/")) return "NODE";
    if (globalThis2.Bun && typeof Bun.version == "string") return "BUN";
    if (globalThis2.Deno && typeof Deno.version == "object") return "DENO";
    if (classof2(globalThis2.process) === "process") return "NODE";
    if (globalThis2.window && globalThis2.document) return "BROWSER";
    return "REST";
  })();
  return environment;
}
var validateArgumentsLength;
var hasRequiredValidateArgumentsLength;
function requireValidateArgumentsLength() {
  if (hasRequiredValidateArgumentsLength) return validateArgumentsLength;
  hasRequiredValidateArgumentsLength = 1;
  var $TypeError = TypeError;
  validateArgumentsLength = function(passed, required) {
    if (passed < required) throw new $TypeError("Not enough arguments");
    return passed;
  };
  return validateArgumentsLength;
}
var schedulersFix;
var hasRequiredSchedulersFix;
function requireSchedulersFix() {
  if (hasRequiredSchedulersFix) return schedulersFix;
  hasRequiredSchedulersFix = 1;
  var globalThis2 = requireGlobalThis();
  var apply = requireFunctionApply();
  var isCallable2 = requireIsCallable();
  var ENVIRONMENT = requireEnvironment();
  var USER_AGENT = requireEnvironmentUserAgent();
  var arraySlice2 = requireArraySlice();
  var validateArgumentsLength2 = requireValidateArgumentsLength();
  var Function2 = globalThis2.Function;
  var WRAP = /MSIE .\./.test(USER_AGENT) || ENVIRONMENT === "BUN" && (function() {
    var version = globalThis2.Bun.version.split(".");
    return version.length < 3 || version[0] === "0" && (version[1] < 3 || version[1] === "3" && version[2] === "0");
  })();
  schedulersFix = function(scheduler, hasTimeArg) {
    var firstParamIndex = hasTimeArg ? 2 : 1;
    return WRAP ? function(handler, timeout) {
      var boundArgs = validateArgumentsLength2(arguments.length, 1) > firstParamIndex;
      var fn = isCallable2(handler) ? handler : Function2(handler);
      var params = boundArgs ? arraySlice2(arguments, firstParamIndex) : [];
      var callback = boundArgs ? function() {
        apply(fn, this, params);
      } : fn;
      return hasTimeArg ? scheduler(callback, timeout) : scheduler(callback);
    } : scheduler;
  };
  return schedulersFix;
}
var hasRequiredWeb_setInterval;
function requireWeb_setInterval() {
  if (hasRequiredWeb_setInterval) return web_setInterval;
  hasRequiredWeb_setInterval = 1;
  var $ = require_export();
  var globalThis2 = requireGlobalThis();
  var schedulersFix2 = requireSchedulersFix();
  var setInterval2 = schedulersFix2(globalThis2.setInterval, true);
  $({ global: true, bind: true, forced: globalThis2.setInterval !== setInterval2 }, {
    setInterval: setInterval2
  });
  return web_setInterval;
}
var web_setTimeout = {};
var hasRequiredWeb_setTimeout;
function requireWeb_setTimeout() {
  if (hasRequiredWeb_setTimeout) return web_setTimeout;
  hasRequiredWeb_setTimeout = 1;
  var $ = require_export();
  var globalThis2 = requireGlobalThis();
  var schedulersFix2 = requireSchedulersFix();
  var setTimeout2 = schedulersFix2(globalThis2.setTimeout, true);
  $({ global: true, bind: true, forced: globalThis2.setTimeout !== setTimeout2 }, {
    setTimeout: setTimeout2
  });
  return web_setTimeout;
}
var hasRequiredWeb_timers;
function requireWeb_timers() {
  if (hasRequiredWeb_timers) return web_timers;
  hasRequiredWeb_timers = 1;
  requireWeb_setInterval();
  requireWeb_setTimeout();
  return web_timers;
}
var setTimeout$2;
var hasRequiredSetTimeout$1;
function requireSetTimeout$1() {
  if (hasRequiredSetTimeout$1) return setTimeout$2;
  hasRequiredSetTimeout$1 = 1;
  requireWeb_timers();
  var path2 = requirePath();
  setTimeout$2 = path2.setTimeout;
  return setTimeout$2;
}
var setTimeout$1;
var hasRequiredSetTimeout;
function requireSetTimeout() {
  if (hasRequiredSetTimeout) return setTimeout$1;
  hasRequiredSetTimeout = 1;
  setTimeout$1 = requireSetTimeout$1();
  return setTimeout$1;
}
var setTimeoutExports = requireSetTimeout();
var _setTimeout = getDefaultExportFromCjs(setTimeoutExports);
var es_array_fill = {};
var arrayFill;
var hasRequiredArrayFill;
function requireArrayFill() {
  if (hasRequiredArrayFill) return arrayFill;
  hasRequiredArrayFill = 1;
  var toObject2 = requireToObject();
  var toAbsoluteIndex2 = requireToAbsoluteIndex();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  arrayFill = function fill2(value) {
    var O = toObject2(this);
    var length = lengthOfArrayLike2(O);
    var argumentsLength = arguments.length;
    var index = toAbsoluteIndex2(argumentsLength > 1 ? arguments[1] : void 0, length);
    var end = argumentsLength > 2 ? arguments[2] : void 0;
    var endPos = end === void 0 ? length : toAbsoluteIndex2(end, length);
    while (endPos > index) O[index++] = value;
    return O;
  };
  return arrayFill;
}
var hasRequiredEs_array_fill;
function requireEs_array_fill() {
  if (hasRequiredEs_array_fill) return es_array_fill;
  hasRequiredEs_array_fill = 1;
  var $ = require_export();
  var fill2 = requireArrayFill();
  var addToUnscopables2 = requireAddToUnscopables();
  $({ target: "Array", proto: true }, {
    fill: fill2
  });
  addToUnscopables2("fill");
  return es_array_fill;
}
var fill$3;
var hasRequiredFill$3;
function requireFill$3() {
  if (hasRequiredFill$3) return fill$3;
  hasRequiredFill$3 = 1;
  requireEs_array_fill();
  var getBuiltInPrototypeMethod2 = requireGetBuiltInPrototypeMethod();
  fill$3 = getBuiltInPrototypeMethod2("Array", "fill");
  return fill$3;
}
var fill$2;
var hasRequiredFill$2;
function requireFill$2() {
  if (hasRequiredFill$2) return fill$2;
  hasRequiredFill$2 = 1;
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var method = requireFill$3();
  var ArrayPrototype = Array.prototype;
  fill$2 = function(it2) {
    var own = it2.fill;
    return it2 === ArrayPrototype || isPrototypeOf(ArrayPrototype, it2) && own === ArrayPrototype.fill ? method : own;
  };
  return fill$2;
}
var fill$1;
var hasRequiredFill$1;
function requireFill$1() {
  if (hasRequiredFill$1) return fill$1;
  hasRequiredFill$1 = 1;
  var parent = requireFill$2();
  fill$1 = parent;
  return fill$1;
}
var fill;
var hasRequiredFill;
function requireFill() {
  if (hasRequiredFill) return fill;
  hasRequiredFill = 1;
  fill = requireFill$1();
  return fill;
}
var fillExports = requireFill();
var _fillInstanceProperty = getDefaultExportFromCjs(fillExports);
var componentEmitter = { exports: {} };
var hasRequiredComponentEmitter;
function requireComponentEmitter() {
  if (hasRequiredComponentEmitter) return componentEmitter.exports;
  hasRequiredComponentEmitter = 1;
  (function(module) {
    {
      module.exports = Emitter2;
    }
    function Emitter2(obj) {
      if (obj) return mixin(obj);
    }
    function mixin(obj) {
      for (var key in Emitter2.prototype) {
        obj[key] = Emitter2.prototype[key];
      }
      return obj;
    }
    Emitter2.prototype.on = Emitter2.prototype.addEventListener = function(event2, fn) {
      this._callbacks = this._callbacks || {};
      (this._callbacks["$" + event2] = this._callbacks["$" + event2] || []).push(fn);
      return this;
    };
    Emitter2.prototype.once = function(event2, fn) {
      function on() {
        this.off(event2, on);
        fn.apply(this, arguments);
      }
      on.fn = fn;
      this.on(event2, on);
      return this;
    };
    Emitter2.prototype.off = Emitter2.prototype.removeListener = Emitter2.prototype.removeAllListeners = Emitter2.prototype.removeEventListener = function(event2, fn) {
      this._callbacks = this._callbacks || {};
      if (0 == arguments.length) {
        this._callbacks = {};
        return this;
      }
      var callbacks = this._callbacks["$" + event2];
      if (!callbacks) return this;
      if (1 == arguments.length) {
        delete this._callbacks["$" + event2];
        return this;
      }
      var cb;
      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }
      if (callbacks.length === 0) {
        delete this._callbacks["$" + event2];
      }
      return this;
    };
    Emitter2.prototype.emit = function(event2) {
      this._callbacks = this._callbacks || {};
      var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event2];
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }
      return this;
    };
    Emitter2.prototype.listeners = function(event2) {
      this._callbacks = this._callbacks || {};
      return this._callbacks["$" + event2] || [];
    };
    Emitter2.prototype.hasListeners = function(event2) {
      return !!this.listeners(event2).length;
    };
  })(componentEmitter);
  return componentEmitter.exports;
}
var componentEmitterExports = requireComponentEmitter();
var Emitter = getDefaultExportFromCjs(componentEmitterExports);
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var assign;
if (typeof Object.assign !== "function") {
  assign = function assign2(target) {
    if (target === void 0 || target === null) {
      throw new TypeError("Cannot convert undefined or null to object");
    }
    var output = Object(target);
    for (var index = 1; index < arguments.length; index++) {
      var source = arguments[index];
      if (source !== void 0 && source !== null) {
        for (var nextKey in source) {
          if (source.hasOwnProperty(nextKey)) {
            output[nextKey] = source[nextKey];
          }
        }
      }
    }
    return output;
  };
} else {
  assign = Object.assign;
}
var assign$1 = assign;
var VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
var TEST_ELEMENT = typeof document === "undefined" ? {
  style: {}
} : document.createElement("div");
var TYPE_FUNCTION = "function";
var round = Math.round;
var abs = Math.abs;
var now = Date.now;
function prefixed(obj, property) {
  var prefix;
  var prop;
  var camelProp = property[0].toUpperCase() + property.slice(1);
  var i = 0;
  while (i < VENDOR_PREFIXES.length) {
    prefix = VENDOR_PREFIXES[i];
    prop = prefix ? prefix + camelProp : property;
    if (prop in obj) {
      return prop;
    }
    i++;
  }
  return void 0;
}
var win;
if (typeof window === "undefined") {
  win = {};
} else {
  win = window;
}
var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== void 0;
function getTouchActionProps() {
  if (!NATIVE_TOUCH_ACTION) {
    return false;
  }
  var touchMap = {};
  var cssSupports = win.CSS && win.CSS.supports;
  ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(val) {
    return touchMap[val] = cssSupports ? win.CSS.supports("touch-action", val) : true;
  });
  return touchMap;
}
var TOUCH_ACTION_COMPUTE = "compute";
var TOUCH_ACTION_AUTO = "auto";
var TOUCH_ACTION_MANIPULATION = "manipulation";
var TOUCH_ACTION_NONE = "none";
var TOUCH_ACTION_PAN_X = "pan-x";
var TOUCH_ACTION_PAN_Y = "pan-y";
var TOUCH_ACTION_MAP = getTouchActionProps();
var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
var SUPPORT_TOUCH = "ontouchstart" in win;
var SUPPORT_POINTER_EVENTS = prefixed(win, "PointerEvent") !== void 0;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
var INPUT_TYPE_TOUCH = "touch";
var INPUT_TYPE_PEN = "pen";
var INPUT_TYPE_MOUSE = "mouse";
var INPUT_TYPE_KINECT = "kinect";
var COMPUTE_INTERVAL = 25;
var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;
var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;
var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
var PROPS_XY = ["x", "y"];
var PROPS_CLIENT_XY = ["clientX", "clientY"];
function each(obj, iterator2, context) {
  var i;
  if (!obj) {
    return;
  }
  if (obj.forEach) {
    obj.forEach(iterator2, context);
  } else if (obj.length !== void 0) {
    i = 0;
    while (i < obj.length) {
      iterator2.call(context, obj[i], i, obj);
      i++;
    }
  } else {
    for (i in obj) {
      obj.hasOwnProperty(i) && iterator2.call(context, obj[i], i, obj);
    }
  }
}
function boolOrFn(val, args) {
  if (typeof val === TYPE_FUNCTION) {
    return val.apply(args ? args[0] || void 0 : void 0, args);
  }
  return val;
}
function inStr(str, find2) {
  return str.indexOf(find2) > -1;
}
function cleanTouchActions(actions) {
  if (inStr(actions, TOUCH_ACTION_NONE)) {
    return TOUCH_ACTION_NONE;
  }
  var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
  var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
  if (hasPanX && hasPanY) {
    return TOUCH_ACTION_NONE;
  }
  if (hasPanX || hasPanY) {
    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
  }
  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
    return TOUCH_ACTION_MANIPULATION;
  }
  return TOUCH_ACTION_AUTO;
}
var TouchAction = (function() {
  function TouchAction2(manager, value) {
    this.manager = manager;
    this.set(value);
  }
  var _proto = TouchAction2.prototype;
  _proto.set = function set2(value) {
    if (value === TOUCH_ACTION_COMPUTE) {
      value = this.compute();
    }
    if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
      this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
    }
    this.actions = value.toLowerCase().trim();
  };
  _proto.update = function update() {
    this.set(this.manager.options.touchAction);
  };
  _proto.compute = function compute() {
    var actions = [];
    each(this.manager.recognizers, function(recognizer) {
      if (boolOrFn(recognizer.options.enable, [recognizer])) {
        actions = actions.concat(recognizer.getTouchAction());
      }
    });
    return cleanTouchActions(actions.join(" "));
  };
  _proto.preventDefaults = function preventDefaults(input) {
    var srcEvent = input.srcEvent;
    var direction = input.offsetDirection;
    if (this.manager.session.prevented) {
      srcEvent.preventDefault();
      return;
    }
    var actions = this.actions;
    var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
    if (hasNone) {
      var isTapPointer = input.pointers.length === 1;
      var isTapMovement = input.distance < 2;
      var isTapTouchTime = input.deltaTime < 250;
      if (isTapPointer && isTapMovement && isTapTouchTime) {
        return;
      }
    }
    if (hasPanX && hasPanY) {
      return;
    }
    if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
      return this.preventSrc(srcEvent);
    }
  };
  _proto.preventSrc = function preventSrc(srcEvent) {
    this.manager.session.prevented = true;
    srcEvent.preventDefault();
  };
  return TouchAction2;
})();
function hasParent$1(node, parent) {
  while (node) {
    if (node === parent) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
}
function getCenter(pointers) {
  var pointersLength = pointers.length;
  if (pointersLength === 1) {
    return {
      x: round(pointers[0].clientX),
      y: round(pointers[0].clientY)
    };
  }
  var x = 0;
  var y = 0;
  var i = 0;
  while (i < pointersLength) {
    x += pointers[i].clientX;
    y += pointers[i].clientY;
    i++;
  }
  return {
    x: round(x / pointersLength),
    y: round(y / pointersLength)
  };
}
function simpleCloneInputData(input) {
  var pointers = [];
  var i = 0;
  while (i < input.pointers.length) {
    pointers[i] = {
      clientX: round(input.pointers[i].clientX),
      clientY: round(input.pointers[i].clientY)
    };
    i++;
  }
  return {
    timeStamp: now(),
    pointers,
    center: getCenter(pointers),
    deltaX: input.deltaX,
    deltaY: input.deltaY
  };
}
function getDistance(p1, p2, props) {
  if (!props) {
    props = PROPS_XY;
  }
  var x = p2[props[0]] - p1[props[0]];
  var y = p2[props[1]] - p1[props[1]];
  return Math.sqrt(x * x + y * y);
}
function getAngle(p1, p2, props) {
  if (!props) {
    props = PROPS_XY;
  }
  var x = p2[props[0]] - p1[props[0]];
  var y = p2[props[1]] - p1[props[1]];
  return Math.atan2(y, x) * 180 / Math.PI;
}
function getDirection(x, y) {
  if (x === y) {
    return DIRECTION_NONE;
  }
  if (abs(x) >= abs(y)) {
    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
  }
  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}
function computeDeltaXY(session, input) {
  var center = input.center;
  var offset = session.offsetDelta || {};
  var prevDelta = session.prevDelta || {};
  var prevInput = session.prevInput || {};
  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
    prevDelta = session.prevDelta = {
      x: prevInput.deltaX || 0,
      y: prevInput.deltaY || 0
    };
    offset = session.offsetDelta = {
      x: center.x,
      y: center.y
    };
  }
  input.deltaX = prevDelta.x + (center.x - offset.x);
  input.deltaY = prevDelta.y + (center.y - offset.y);
}
function getVelocity(deltaTime, x, y) {
  return {
    x: x / deltaTime || 0,
    y: y / deltaTime || 0
  };
}
function getScale(start, end) {
  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}
function getRotation(start, end) {
  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}
function computeIntervalInputData(session, input) {
  var last = session.lastInterval || input;
  var deltaTime = input.timeStamp - last.timeStamp;
  var velocity;
  var velocityX;
  var velocityY;
  var direction;
  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === void 0)) {
    var deltaX = input.deltaX - last.deltaX;
    var deltaY = input.deltaY - last.deltaY;
    var v = getVelocity(deltaTime, deltaX, deltaY);
    velocityX = v.x;
    velocityY = v.y;
    velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
    direction = getDirection(deltaX, deltaY);
    session.lastInterval = input;
  } else {
    velocity = last.velocity;
    velocityX = last.velocityX;
    velocityY = last.velocityY;
    direction = last.direction;
  }
  input.velocity = velocity;
  input.velocityX = velocityX;
  input.velocityY = velocityY;
  input.direction = direction;
}
function computeInputData(manager, input) {
  var session = manager.session;
  var pointers = input.pointers;
  var pointersLength = pointers.length;
  if (!session.firstInput) {
    session.firstInput = simpleCloneInputData(input);
  }
  if (pointersLength > 1 && !session.firstMultiple) {
    session.firstMultiple = simpleCloneInputData(input);
  } else if (pointersLength === 1) {
    session.firstMultiple = false;
  }
  var firstInput = session.firstInput, firstMultiple = session.firstMultiple;
  var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
  var center = input.center = getCenter(pointers);
  input.timeStamp = now();
  input.deltaTime = input.timeStamp - firstInput.timeStamp;
  input.angle = getAngle(offsetCenter, center);
  input.distance = getDistance(offsetCenter, center);
  computeDeltaXY(session, input);
  input.offsetDirection = getDirection(input.deltaX, input.deltaY);
  var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
  input.overallVelocityX = overallVelocity.x;
  input.overallVelocityY = overallVelocity.y;
  input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
  computeIntervalInputData(session, input);
  var target = manager.element;
  var srcEvent = input.srcEvent;
  var srcEventTarget;
  if (srcEvent.composedPath) {
    srcEventTarget = srcEvent.composedPath()[0];
  } else if (srcEvent.path) {
    srcEventTarget = srcEvent.path[0];
  } else {
    srcEventTarget = srcEvent.target;
  }
  if (hasParent$1(srcEventTarget, target)) {
    target = srcEventTarget;
  }
  input.target = target;
}
function inputHandler(manager, eventType, input) {
  var pointersLen = input.pointers.length;
  var changedPointersLen = input.changedPointers.length;
  var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
  var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
  input.isFirst = !!isFirst;
  input.isFinal = !!isFinal;
  if (isFirst) {
    manager.session = {};
  }
  input.eventType = eventType;
  computeInputData(manager, input);
  manager.emit("hammer.input", input);
  manager.recognize(input);
  manager.session.prevInput = input;
}
function splitStr(str) {
  return str.trim().split(/\s+/g);
}
function addEventListeners(target, types, handler) {
  each(splitStr(types), function(type) {
    target.addEventListener(type, handler, false);
  });
}
function removeEventListeners(target, types, handler) {
  each(splitStr(types), function(type) {
    target.removeEventListener(type, handler, false);
  });
}
function getWindowForElement(element) {
  var doc = element.ownerDocument || element;
  return doc.defaultView || doc.parentWindow || window;
}
var Input = (function() {
  function Input2(manager, callback) {
    var self2 = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;
    this.domHandler = function(ev) {
      if (boolOrFn(manager.options.enable, [manager])) {
        self2.handler(ev);
      }
    };
    this.init();
  }
  var _proto = Input2.prototype;
  _proto.handler = function handler() {
  };
  _proto.init = function init() {
    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
  };
  _proto.destroy = function destroy() {
    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
  };
  return Input2;
})();
function inArray(src, find2, findByKey) {
  if (src.indexOf && !findByKey) {
    return src.indexOf(find2);
  } else {
    var i = 0;
    while (i < src.length) {
      if (findByKey && src[i][findByKey] == find2 || !findByKey && src[i] === find2) {
        return i;
      }
      i++;
    }
    return -1;
  }
}
var POINTER_INPUT_MAP = {
  pointerdown: INPUT_START,
  pointermove: INPUT_MOVE,
  pointerup: INPUT_END,
  pointercancel: INPUT_CANCEL,
  pointerout: INPUT_CANCEL
};
var IE10_POINTER_TYPE_ENUM = {
  2: INPUT_TYPE_TOUCH,
  3: INPUT_TYPE_PEN,
  4: INPUT_TYPE_MOUSE,
  5: INPUT_TYPE_KINECT
  // see https://twitter.com/jacobrossi/status/480596438489890816
};
var POINTER_ELEMENT_EVENTS = "pointerdown";
var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
if (win.MSPointerEvent && !win.PointerEvent) {
  POINTER_ELEMENT_EVENTS = "MSPointerDown";
  POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
}
var PointerEventInput = (function(_Input) {
  _inheritsLoose(PointerEventInput2, _Input);
  function PointerEventInput2() {
    var _this;
    var proto = PointerEventInput2.prototype;
    proto.evEl = POINTER_ELEMENT_EVENTS;
    proto.evWin = POINTER_WINDOW_EVENTS;
    _this = _Input.apply(this, arguments) || this;
    _this.store = _this.manager.session.pointerEvents = [];
    return _this;
  }
  var _proto = PointerEventInput2.prototype;
  _proto.handler = function handler(ev) {
    var store = this.store;
    var removePointer = false;
    var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
    var isTouch = pointerType === INPUT_TYPE_TOUCH;
    var storeIndex = inArray(store, ev.pointerId, "pointerId");
    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
      if (storeIndex < 0) {
        store.push(ev);
        storeIndex = store.length - 1;
      }
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
      removePointer = true;
    }
    if (storeIndex < 0) {
      return;
    }
    store[storeIndex] = ev;
    this.callback(this.manager, eventType, {
      pointers: store,
      changedPointers: [ev],
      pointerType,
      srcEvent: ev
    });
    if (removePointer) {
      store.splice(storeIndex, 1);
    }
  };
  return PointerEventInput2;
})(Input);
function toArray$1(obj) {
  return Array.prototype.slice.call(obj, 0);
}
function uniqueArray(src, key, sort2) {
  var results = [];
  var values2 = [];
  var i = 0;
  while (i < src.length) {
    var val = key ? src[i][key] : src[i];
    if (inArray(values2, val) < 0) {
      results.push(src[i]);
    }
    values2[i] = val;
    i++;
  }
  if (sort2) {
    if (!key) {
      results = results.sort();
    } else {
      results = results.sort(function(a, b) {
        return a[key] > b[key];
      });
    }
  }
  return results;
}
var TOUCH_INPUT_MAP = {
  touchstart: INPUT_START,
  touchmove: INPUT_MOVE,
  touchend: INPUT_END,
  touchcancel: INPUT_CANCEL
};
var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
var TouchInput = (function(_Input) {
  _inheritsLoose(TouchInput2, _Input);
  function TouchInput2() {
    var _this;
    TouchInput2.prototype.evTarget = TOUCH_TARGET_EVENTS;
    _this = _Input.apply(this, arguments) || this;
    _this.targetIds = {};
    return _this;
  }
  var _proto = TouchInput2.prototype;
  _proto.handler = function handler(ev) {
    var type = TOUCH_INPUT_MAP[ev.type];
    var touches = getTouches.call(this, ev, type);
    if (!touches) {
      return;
    }
    this.callback(this.manager, type, {
      pointers: touches[0],
      changedPointers: touches[1],
      pointerType: INPUT_TYPE_TOUCH,
      srcEvent: ev
    });
  };
  return TouchInput2;
})(Input);
function getTouches(ev, type) {
  var allTouches = toArray$1(ev.touches);
  var targetIds = this.targetIds;
  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
    targetIds[allTouches[0].identifier] = true;
    return [allTouches, allTouches];
  }
  var i;
  var targetTouches;
  var changedTouches = toArray$1(ev.changedTouches);
  var changedTargetTouches = [];
  var target = this.target;
  targetTouches = allTouches.filter(function(touch) {
    return hasParent$1(touch.target, target);
  });
  if (type === INPUT_START) {
    i = 0;
    while (i < targetTouches.length) {
      targetIds[targetTouches[i].identifier] = true;
      i++;
    }
  }
  i = 0;
  while (i < changedTouches.length) {
    if (targetIds[changedTouches[i].identifier]) {
      changedTargetTouches.push(changedTouches[i]);
    }
    if (type & (INPUT_END | INPUT_CANCEL)) {
      delete targetIds[changedTouches[i].identifier];
    }
    i++;
  }
  if (!changedTargetTouches.length) {
    return;
  }
  return [
    // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
    uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
    changedTargetTouches
  ];
}
var MOUSE_INPUT_MAP = {
  mousedown: INPUT_START,
  mousemove: INPUT_MOVE,
  mouseup: INPUT_END
};
var MOUSE_ELEMENT_EVENTS = "mousedown";
var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
var MouseInput = (function(_Input) {
  _inheritsLoose(MouseInput2, _Input);
  function MouseInput2() {
    var _this;
    var proto = MouseInput2.prototype;
    proto.evEl = MOUSE_ELEMENT_EVENTS;
    proto.evWin = MOUSE_WINDOW_EVENTS;
    _this = _Input.apply(this, arguments) || this;
    _this.pressed = false;
    return _this;
  }
  var _proto = MouseInput2.prototype;
  _proto.handler = function handler(ev) {
    var eventType = MOUSE_INPUT_MAP[ev.type];
    if (eventType & INPUT_START && ev.button === 0) {
      this.pressed = true;
    }
    if (eventType & INPUT_MOVE && ev.which !== 1) {
      eventType = INPUT_END;
    }
    if (!this.pressed) {
      return;
    }
    if (eventType & INPUT_END) {
      this.pressed = false;
    }
    this.callback(this.manager, eventType, {
      pointers: [ev],
      changedPointers: [ev],
      pointerType: INPUT_TYPE_MOUSE,
      srcEvent: ev
    });
  };
  return MouseInput2;
})(Input);
var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;
function setLastTouch(eventData) {
  var _eventData$changedPoi = eventData.changedPointers, touch = _eventData$changedPoi[0];
  if (touch.identifier === this.primaryTouch) {
    var lastTouch = {
      x: touch.clientX,
      y: touch.clientY
    };
    var lts = this.lastTouches;
    this.lastTouches.push(lastTouch);
    var removeLastTouch = function removeLastTouch2() {
      var i = lts.indexOf(lastTouch);
      if (i > -1) {
        lts.splice(i, 1);
      }
    };
    setTimeout(removeLastTouch, DEDUP_TIMEOUT);
  }
}
function recordTouches(eventType, eventData) {
  if (eventType & INPUT_START) {
    this.primaryTouch = eventData.changedPointers[0].identifier;
    setLastTouch.call(this, eventData);
  } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
    setLastTouch.call(this, eventData);
  }
}
function isSyntheticEvent(eventData) {
  var x = eventData.srcEvent.clientX;
  var y = eventData.srcEvent.clientY;
  for (var i = 0; i < this.lastTouches.length; i++) {
    var t = this.lastTouches[i];
    var dx = Math.abs(x - t.x);
    var dy = Math.abs(y - t.y);
    if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
      return true;
    }
  }
  return false;
}
var TouchMouseInput = (function() {
  var TouchMouseInput2 = (function(_Input) {
    _inheritsLoose(TouchMouseInput3, _Input);
    function TouchMouseInput3(_manager, callback) {
      var _this;
      _this = _Input.call(this, _manager, callback) || this;
      _this.handler = function(manager, inputEvent, inputData) {
        var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;
        var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;
        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
          return;
        }
        if (isTouch) {
          recordTouches.call(_assertThisInitialized(_assertThisInitialized(_this)), inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(_assertThisInitialized(_assertThisInitialized(_this)), inputData)) {
          return;
        }
        _this.callback(manager, inputEvent, inputData);
      };
      _this.touch = new TouchInput(_this.manager, _this.handler);
      _this.mouse = new MouseInput(_this.manager, _this.handler);
      _this.primaryTouch = null;
      _this.lastTouches = [];
      return _this;
    }
    var _proto = TouchMouseInput3.prototype;
    _proto.destroy = function destroy() {
      this.touch.destroy();
      this.mouse.destroy();
    };
    return TouchMouseInput3;
  })(Input);
  return TouchMouseInput2;
})();
function createInputInstance(manager) {
  var Type;
  var inputClass = manager.options.inputClass;
  if (inputClass) {
    Type = inputClass;
  } else if (SUPPORT_POINTER_EVENTS) {
    Type = PointerEventInput;
  } else if (SUPPORT_ONLY_TOUCH) {
    Type = TouchInput;
  } else if (!SUPPORT_TOUCH) {
    Type = MouseInput;
  } else {
    Type = TouchMouseInput;
  }
  return new Type(manager, inputHandler);
}
function invokeArrayArg(arg, fn, context) {
  if (Array.isArray(arg)) {
    each(arg, context[fn], context);
    return true;
  }
  return false;
}
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;
var _uniqueId = 1;
function uniqueId() {
  return _uniqueId++;
}
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
  var manager = recognizer.manager;
  if (manager) {
    return manager.get(otherRecognizer);
  }
  return otherRecognizer;
}
function stateStr(state) {
  if (state & STATE_CANCELLED) {
    return "cancel";
  } else if (state & STATE_ENDED) {
    return "end";
  } else if (state & STATE_CHANGED) {
    return "move";
  } else if (state & STATE_BEGAN) {
    return "start";
  }
  return "";
}
var Recognizer = (function() {
  function Recognizer2(options) {
    if (options === void 0) {
      options = {};
    }
    this.options = _extends({
      enable: true
    }, options);
    this.id = uniqueId();
    this.manager = null;
    this.state = STATE_POSSIBLE;
    this.simultaneous = {};
    this.requireFail = [];
  }
  var _proto = Recognizer2.prototype;
  _proto.set = function set2(options) {
    assign$1(this.options, options);
    this.manager && this.manager.touchAction.update();
    return this;
  };
  _proto.recognizeWith = function recognizeWith(otherRecognizer) {
    if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
      return this;
    }
    var simultaneous = this.simultaneous;
    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
    if (!simultaneous[otherRecognizer.id]) {
      simultaneous[otherRecognizer.id] = otherRecognizer;
      otherRecognizer.recognizeWith(this);
    }
    return this;
  };
  _proto.dropRecognizeWith = function dropRecognizeWith(otherRecognizer) {
    if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
      return this;
    }
    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
    delete this.simultaneous[otherRecognizer.id];
    return this;
  };
  _proto.requireFailure = function requireFailure(otherRecognizer) {
    if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
      return this;
    }
    var requireFail = this.requireFail;
    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
    if (inArray(requireFail, otherRecognizer) === -1) {
      requireFail.push(otherRecognizer);
      otherRecognizer.requireFailure(this);
    }
    return this;
  };
  _proto.dropRequireFailure = function dropRequireFailure(otherRecognizer) {
    if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
      return this;
    }
    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
    var index = inArray(this.requireFail, otherRecognizer);
    if (index > -1) {
      this.requireFail.splice(index, 1);
    }
    return this;
  };
  _proto.hasRequireFailures = function hasRequireFailures() {
    return this.requireFail.length > 0;
  };
  _proto.canRecognizeWith = function canRecognizeWith(otherRecognizer) {
    return !!this.simultaneous[otherRecognizer.id];
  };
  _proto.emit = function emit(input) {
    var self2 = this;
    var state = this.state;
    function emit2(event2) {
      self2.manager.emit(event2, input);
    }
    if (state < STATE_ENDED) {
      emit2(self2.options.event + stateStr(state));
    }
    emit2(self2.options.event);
    if (input.additionalEvent) {
      emit2(input.additionalEvent);
    }
    if (state >= STATE_ENDED) {
      emit2(self2.options.event + stateStr(state));
    }
  };
  _proto.tryEmit = function tryEmit(input) {
    if (this.canEmit()) {
      return this.emit(input);
    }
    this.state = STATE_FAILED;
  };
  _proto.canEmit = function canEmit() {
    var i = 0;
    while (i < this.requireFail.length) {
      if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
        return false;
      }
      i++;
    }
    return true;
  };
  _proto.recognize = function recognize(inputData) {
    var inputDataClone = assign$1({}, inputData);
    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
      this.reset();
      this.state = STATE_FAILED;
      return;
    }
    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
      this.state = STATE_POSSIBLE;
    }
    this.state = this.process(inputDataClone);
    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
      this.tryEmit(inputDataClone);
    }
  };
  _proto.process = function process(inputData) {
  };
  _proto.getTouchAction = function getTouchAction() {
  };
  _proto.reset = function reset() {
  };
  return Recognizer2;
})();
var TapRecognizer = (function(_Recognizer) {
  _inheritsLoose(TapRecognizer2, _Recognizer);
  function TapRecognizer2(options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _Recognizer.call(this, _extends({
      event: "tap",
      pointers: 1,
      taps: 1,
      interval: 300,
      // max time between the multi-tap taps
      time: 250,
      // max time of the pointer to be down (like finger on the screen)
      threshold: 9,
      // a minimal movement is ok, but keep it low
      posThreshold: 10
    }, options)) || this;
    _this.pTime = false;
    _this.pCenter = false;
    _this._timer = null;
    _this._input = null;
    _this.count = 0;
    return _this;
  }
  var _proto = TapRecognizer2.prototype;
  _proto.getTouchAction = function getTouchAction() {
    return [TOUCH_ACTION_MANIPULATION];
  };
  _proto.process = function process(input) {
    var _this2 = this;
    var options = this.options;
    var validPointers = input.pointers.length === options.pointers;
    var validMovement = input.distance < options.threshold;
    var validTouchTime = input.deltaTime < options.time;
    this.reset();
    if (input.eventType & INPUT_START && this.count === 0) {
      return this.failTimeout();
    }
    if (validMovement && validTouchTime && validPointers) {
      if (input.eventType !== INPUT_END) {
        return this.failTimeout();
      }
      var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
      var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
      this.pTime = input.timeStamp;
      this.pCenter = input.center;
      if (!validMultiTap || !validInterval) {
        this.count = 1;
      } else {
        this.count += 1;
      }
      this._input = input;
      var tapCount = this.count % options.taps;
      if (tapCount === 0) {
        if (!this.hasRequireFailures()) {
          return STATE_RECOGNIZED;
        } else {
          this._timer = setTimeout(function() {
            _this2.state = STATE_RECOGNIZED;
            _this2.tryEmit();
          }, options.interval);
          return STATE_BEGAN;
        }
      }
    }
    return STATE_FAILED;
  };
  _proto.failTimeout = function failTimeout() {
    var _this3 = this;
    this._timer = setTimeout(function() {
      _this3.state = STATE_FAILED;
    }, this.options.interval);
    return STATE_FAILED;
  };
  _proto.reset = function reset() {
    clearTimeout(this._timer);
  };
  _proto.emit = function emit() {
    if (this.state === STATE_RECOGNIZED) {
      this._input.tapCount = this.count;
      this.manager.emit(this.options.event, this._input);
    }
  };
  return TapRecognizer2;
})(Recognizer);
var AttrRecognizer = (function(_Recognizer) {
  _inheritsLoose(AttrRecognizer2, _Recognizer);
  function AttrRecognizer2(options) {
    if (options === void 0) {
      options = {};
    }
    return _Recognizer.call(this, _extends({
      pointers: 1
    }, options)) || this;
  }
  var _proto = AttrRecognizer2.prototype;
  _proto.attrTest = function attrTest(input) {
    var optionPointers = this.options.pointers;
    return optionPointers === 0 || input.pointers.length === optionPointers;
  };
  _proto.process = function process(input) {
    var state = this.state;
    var eventType = input.eventType;
    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
    var isValid = this.attrTest(input);
    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
      return state | STATE_CANCELLED;
    } else if (isRecognized || isValid) {
      if (eventType & INPUT_END) {
        return state | STATE_ENDED;
      } else if (!(state & STATE_BEGAN)) {
        return STATE_BEGAN;
      }
      return state | STATE_CHANGED;
    }
    return STATE_FAILED;
  };
  return AttrRecognizer2;
})(Recognizer);
function directionStr(direction) {
  if (direction === DIRECTION_DOWN) {
    return "down";
  } else if (direction === DIRECTION_UP) {
    return "up";
  } else if (direction === DIRECTION_LEFT) {
    return "left";
  } else if (direction === DIRECTION_RIGHT) {
    return "right";
  }
  return "";
}
var PanRecognizer = (function(_AttrRecognizer) {
  _inheritsLoose(PanRecognizer2, _AttrRecognizer);
  function PanRecognizer2(options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _AttrRecognizer.call(this, _extends({
      event: "pan",
      threshold: 10,
      pointers: 1,
      direction: DIRECTION_ALL
    }, options)) || this;
    _this.pX = null;
    _this.pY = null;
    return _this;
  }
  var _proto = PanRecognizer2.prototype;
  _proto.getTouchAction = function getTouchAction() {
    var direction = this.options.direction;
    var actions = [];
    if (direction & DIRECTION_HORIZONTAL) {
      actions.push(TOUCH_ACTION_PAN_Y);
    }
    if (direction & DIRECTION_VERTICAL) {
      actions.push(TOUCH_ACTION_PAN_X);
    }
    return actions;
  };
  _proto.directionTest = function directionTest(input) {
    var options = this.options;
    var hasMoved = true;
    var distance = input.distance;
    var direction = input.direction;
    var x = input.deltaX;
    var y = input.deltaY;
    if (!(direction & options.direction)) {
      if (options.direction & DIRECTION_HORIZONTAL) {
        direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        hasMoved = x !== this.pX;
        distance = Math.abs(input.deltaX);
      } else {
        direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
        hasMoved = y !== this.pY;
        distance = Math.abs(input.deltaY);
      }
    }
    input.direction = direction;
    return hasMoved && distance > options.threshold && direction & options.direction;
  };
  _proto.attrTest = function attrTest(input) {
    return AttrRecognizer.prototype.attrTest.call(this, input) && // replace with a super call
    (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
  };
  _proto.emit = function emit(input) {
    this.pX = input.deltaX;
    this.pY = input.deltaY;
    var direction = directionStr(input.direction);
    if (direction) {
      input.additionalEvent = this.options.event + direction;
    }
    _AttrRecognizer.prototype.emit.call(this, input);
  };
  return PanRecognizer2;
})(AttrRecognizer);
var SwipeRecognizer = (function(_AttrRecognizer) {
  _inheritsLoose(SwipeRecognizer2, _AttrRecognizer);
  function SwipeRecognizer2(options) {
    if (options === void 0) {
      options = {};
    }
    return _AttrRecognizer.call(this, _extends({
      event: "swipe",
      threshold: 10,
      velocity: 0.3,
      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
      pointers: 1
    }, options)) || this;
  }
  var _proto = SwipeRecognizer2.prototype;
  _proto.getTouchAction = function getTouchAction() {
    return PanRecognizer.prototype.getTouchAction.call(this);
  };
  _proto.attrTest = function attrTest(input) {
    var direction = this.options.direction;
    var velocity;
    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
      velocity = input.overallVelocity;
    } else if (direction & DIRECTION_HORIZONTAL) {
      velocity = input.overallVelocityX;
    } else if (direction & DIRECTION_VERTICAL) {
      velocity = input.overallVelocityY;
    }
    return _AttrRecognizer.prototype.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
  };
  _proto.emit = function emit(input) {
    var direction = directionStr(input.offsetDirection);
    if (direction) {
      this.manager.emit(this.options.event + direction, input);
    }
    this.manager.emit(this.options.event, input);
  };
  return SwipeRecognizer2;
})(AttrRecognizer);
var PinchRecognizer = (function(_AttrRecognizer) {
  _inheritsLoose(PinchRecognizer2, _AttrRecognizer);
  function PinchRecognizer2(options) {
    if (options === void 0) {
      options = {};
    }
    return _AttrRecognizer.call(this, _extends({
      event: "pinch",
      threshold: 0,
      pointers: 2
    }, options)) || this;
  }
  var _proto = PinchRecognizer2.prototype;
  _proto.getTouchAction = function getTouchAction() {
    return [TOUCH_ACTION_NONE];
  };
  _proto.attrTest = function attrTest(input) {
    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
  };
  _proto.emit = function emit(input) {
    if (input.scale !== 1) {
      var inOut = input.scale < 1 ? "in" : "out";
      input.additionalEvent = this.options.event + inOut;
    }
    _AttrRecognizer.prototype.emit.call(this, input);
  };
  return PinchRecognizer2;
})(AttrRecognizer);
var RotateRecognizer = (function(_AttrRecognizer) {
  _inheritsLoose(RotateRecognizer2, _AttrRecognizer);
  function RotateRecognizer2(options) {
    if (options === void 0) {
      options = {};
    }
    return _AttrRecognizer.call(this, _extends({
      event: "rotate",
      threshold: 0,
      pointers: 2
    }, options)) || this;
  }
  var _proto = RotateRecognizer2.prototype;
  _proto.getTouchAction = function getTouchAction() {
    return [TOUCH_ACTION_NONE];
  };
  _proto.attrTest = function attrTest(input) {
    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
  };
  return RotateRecognizer2;
})(AttrRecognizer);
var PressRecognizer = (function(_Recognizer) {
  _inheritsLoose(PressRecognizer2, _Recognizer);
  function PressRecognizer2(options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _Recognizer.call(this, _extends({
      event: "press",
      pointers: 1,
      time: 251,
      // minimal time of the pointer to be pressed
      threshold: 9
    }, options)) || this;
    _this._timer = null;
    _this._input = null;
    return _this;
  }
  var _proto = PressRecognizer2.prototype;
  _proto.getTouchAction = function getTouchAction() {
    return [TOUCH_ACTION_AUTO];
  };
  _proto.process = function process(input) {
    var _this2 = this;
    var options = this.options;
    var validPointers = input.pointers.length === options.pointers;
    var validMovement = input.distance < options.threshold;
    var validTime = input.deltaTime > options.time;
    this._input = input;
    if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
      this.reset();
    } else if (input.eventType & INPUT_START) {
      this.reset();
      this._timer = setTimeout(function() {
        _this2.state = STATE_RECOGNIZED;
        _this2.tryEmit();
      }, options.time);
    } else if (input.eventType & INPUT_END) {
      return STATE_RECOGNIZED;
    }
    return STATE_FAILED;
  };
  _proto.reset = function reset() {
    clearTimeout(this._timer);
  };
  _proto.emit = function emit(input) {
    if (this.state !== STATE_RECOGNIZED) {
      return;
    }
    if (input && input.eventType & INPUT_END) {
      this.manager.emit(this.options.event + "up", input);
    } else {
      this._input.timeStamp = now();
      this.manager.emit(this.options.event, this._input);
    }
  };
  return PressRecognizer2;
})(Recognizer);
var defaults = {
  /**
   * @private
   * set if DOM events are being triggered.
   * But this is slower and unused by simple implementations, so disabled by default.
   * @type {Boolean}
   * @default false
   */
  domEvents: false,
  /**
   * @private
   * The value for the touchAction property/fallback.
   * When set to `compute` it will magically set the correct value based on the added recognizers.
   * @type {String}
   * @default compute
   */
  touchAction: TOUCH_ACTION_COMPUTE,
  /**
   * @private
   * @type {Boolean}
   * @default true
   */
  enable: true,
  /**
   * @private
   * EXPERIMENTAL FEATURE -- can be removed/changed
   * Change the parent input target element.
   * If Null, then it is being set the to main element.
   * @type {Null|EventTarget}
   * @default null
   */
  inputTarget: null,
  /**
   * @private
   * force an input class
   * @type {Null|Function}
   * @default null
   */
  inputClass: null,
  /**
   * @private
   * Some CSS properties can be used to improve the working of Hammer.
   * Add them to this method and they will be set when creating a new Manager.
   * @namespace
   */
  cssProps: {
    /**
     * @private
     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
     * @type {String}
     * @default 'none'
     */
    userSelect: "none",
    /**
     * @private
     * Disable the Windows Phone grippers when pressing an element.
     * @type {String}
     * @default 'none'
     */
    touchSelect: "none",
    /**
     * @private
     * Disables the default callout shown when you touch and hold a touch target.
     * On iOS, when you touch and hold a touch target such as a link, Safari displays
     * a callout containing information about the link. This property allows you to disable that callout.
     * @type {String}
     * @default 'none'
     */
    touchCallout: "none",
    /**
     * @private
     * Specifies whether zooming is enabled. Used by IE10>
     * @type {String}
     * @default 'none'
     */
    contentZooming: "none",
    /**
     * @private
     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
     * @type {String}
     * @default 'none'
     */
    userDrag: "none",
    /**
     * @private
     * Overrides the highlight color shown when the user taps a link or a JavaScript
     * clickable element in iOS. This property obeys the alpha value, if specified.
     * @type {String}
     * @default 'rgba(0,0,0,0)'
     */
    tapHighlightColor: "rgba(0,0,0,0)"
  }
};
var preset = [[RotateRecognizer, {
  enable: false
}], [PinchRecognizer, {
  enable: false
}, ["rotate"]], [SwipeRecognizer, {
  direction: DIRECTION_HORIZONTAL
}], [PanRecognizer, {
  direction: DIRECTION_HORIZONTAL
}, ["swipe"]], [TapRecognizer], [TapRecognizer, {
  event: "doubletap",
  taps: 2
}, ["tap"]], [PressRecognizer]];
var STOP = 1;
var FORCED_STOP = 2;
function toggleCssProps(manager, add) {
  var element = manager.element;
  if (!element.style) {
    return;
  }
  var prop;
  each(manager.options.cssProps, function(value, name) {
    prop = prefixed(element.style, name);
    if (add) {
      manager.oldCssProps[prop] = element.style[prop];
      element.style[prop] = value;
    } else {
      element.style[prop] = manager.oldCssProps[prop] || "";
    }
  });
  if (!add) {
    manager.oldCssProps = {};
  }
}
function triggerDomEvent(event2, data) {
  var gestureEvent = document.createEvent("Event");
  gestureEvent.initEvent(event2, true, true);
  gestureEvent.gesture = data;
  data.target.dispatchEvent(gestureEvent);
}
var Manager = (function() {
  function Manager2(element, options) {
    var _this = this;
    this.options = assign$1({}, defaults, options || {});
    this.options.inputTarget = this.options.inputTarget || element;
    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};
    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);
    toggleCssProps(this, true);
    each(this.options.recognizers, function(item) {
      var recognizer = _this.add(new item[0](item[1]));
      item[2] && recognizer.recognizeWith(item[2]);
      item[3] && recognizer.requireFailure(item[3]);
    }, this);
  }
  var _proto = Manager2.prototype;
  _proto.set = function set2(options) {
    assign$1(this.options, options);
    if (options.touchAction) {
      this.touchAction.update();
    }
    if (options.inputTarget) {
      this.input.destroy();
      this.input.target = options.inputTarget;
      this.input.init();
    }
    return this;
  };
  _proto.stop = function stop(force) {
    this.session.stopped = force ? FORCED_STOP : STOP;
  };
  _proto.recognize = function recognize(inputData) {
    var session = this.session;
    if (session.stopped) {
      return;
    }
    this.touchAction.preventDefaults(inputData);
    var recognizer;
    var recognizers = this.recognizers;
    var curRecognizer = session.curRecognizer;
    if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
      session.curRecognizer = null;
      curRecognizer = null;
    }
    var i = 0;
    while (i < recognizers.length) {
      recognizer = recognizers[i];
      if (session.stopped !== FORCED_STOP && // 1
      (!curRecognizer || recognizer === curRecognizer || // 2
      recognizer.canRecognizeWith(curRecognizer))) {
        recognizer.recognize(inputData);
      } else {
        recognizer.reset();
      }
      if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
        session.curRecognizer = recognizer;
        curRecognizer = recognizer;
      }
      i++;
    }
  };
  _proto.get = function get(recognizer) {
    if (recognizer instanceof Recognizer) {
      return recognizer;
    }
    var recognizers = this.recognizers;
    for (var i = 0; i < recognizers.length; i++) {
      if (recognizers[i].options.event === recognizer) {
        return recognizers[i];
      }
    }
    return null;
  };
  _proto.add = function add(recognizer) {
    if (invokeArrayArg(recognizer, "add", this)) {
      return this;
    }
    var existing = this.get(recognizer.options.event);
    if (existing) {
      this.remove(existing);
    }
    this.recognizers.push(recognizer);
    recognizer.manager = this;
    this.touchAction.update();
    return recognizer;
  };
  _proto.remove = function remove(recognizer) {
    if (invokeArrayArg(recognizer, "remove", this)) {
      return this;
    }
    var targetRecognizer = this.get(recognizer);
    if (recognizer) {
      var recognizers = this.recognizers;
      var index = inArray(recognizers, targetRecognizer);
      if (index !== -1) {
        recognizers.splice(index, 1);
        this.touchAction.update();
      }
    }
    return this;
  };
  _proto.on = function on(events, handler) {
    if (events === void 0 || handler === void 0) {
      return this;
    }
    var handlers = this.handlers;
    each(splitStr(events), function(event2) {
      handlers[event2] = handlers[event2] || [];
      handlers[event2].push(handler);
    });
    return this;
  };
  _proto.off = function off(events, handler) {
    if (events === void 0) {
      return this;
    }
    var handlers = this.handlers;
    each(splitStr(events), function(event2) {
      if (!handler) {
        delete handlers[event2];
      } else {
        handlers[event2] && handlers[event2].splice(inArray(handlers[event2], handler), 1);
      }
    });
    return this;
  };
  _proto.emit = function emit(event2, data) {
    if (this.options.domEvents) {
      triggerDomEvent(event2, data);
    }
    var handlers = this.handlers[event2] && this.handlers[event2].slice();
    if (!handlers || !handlers.length) {
      return;
    }
    data.type = event2;
    data.preventDefault = function() {
      data.srcEvent.preventDefault();
    };
    var i = 0;
    while (i < handlers.length) {
      handlers[i](data);
      i++;
    }
  };
  _proto.destroy = function destroy() {
    this.element && toggleCssProps(this, false);
    this.handlers = {};
    this.session = {};
    this.input.destroy();
    this.element = null;
  };
  return Manager2;
})();
var SINGLE_TOUCH_INPUT_MAP = {
  touchstart: INPUT_START,
  touchmove: INPUT_MOVE,
  touchend: INPUT_END,
  touchcancel: INPUT_CANCEL
};
var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
var SingleTouchInput = (function(_Input) {
  _inheritsLoose(SingleTouchInput2, _Input);
  function SingleTouchInput2() {
    var _this;
    var proto = SingleTouchInput2.prototype;
    proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    _this = _Input.apply(this, arguments) || this;
    _this.started = false;
    return _this;
  }
  var _proto = SingleTouchInput2.prototype;
  _proto.handler = function handler(ev) {
    var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
    if (type === INPUT_START) {
      this.started = true;
    }
    if (!this.started) {
      return;
    }
    var touches = normalizeSingleTouches.call(this, ev, type);
    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
      this.started = false;
    }
    this.callback(this.manager, type, {
      pointers: touches[0],
      changedPointers: touches[1],
      pointerType: INPUT_TYPE_TOUCH,
      srcEvent: ev
    });
  };
  return SingleTouchInput2;
})(Input);
function normalizeSingleTouches(ev, type) {
  var all = toArray$1(ev.touches);
  var changed = toArray$1(ev.changedTouches);
  if (type & (INPUT_END | INPUT_CANCEL)) {
    all = uniqueArray(all.concat(changed), "identifier", true);
  }
  return [all, changed];
}
function deprecate(method, name, message) {
  var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
  return function() {
    var e = new Error("get-stack-trace");
    var stack2 = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
    var log = window.console && (window.console.warn || window.console.log);
    if (log) {
      log.call(window.console, deprecationMessage, stack2);
    }
    return method.apply(this, arguments);
  };
}
var extend$1 = deprecate(function(dest, src, merge2) {
  var keys2 = Object.keys(src);
  var i = 0;
  while (i < keys2.length) {
    if (!merge2 || merge2 && dest[keys2[i]] === void 0) {
      dest[keys2[i]] = src[keys2[i]];
    }
    i++;
  }
  return dest;
}, "extend", "Use `assign`.");
var merge = deprecate(function(dest, src) {
  return extend$1(dest, src, true);
}, "merge", "Use `assign`.");
function inherit(child, base, properties) {
  var baseP = base.prototype;
  var childP;
  childP = child.prototype = Object.create(baseP);
  childP.constructor = child;
  childP._super = baseP;
  if (properties) {
    assign$1(childP, properties);
  }
}
function bindFn(fn, context) {
  return function boundFn() {
    return fn.apply(context, arguments);
  };
}
var Hammer$3 = (function() {
  var Hammer2 = (
    /**
      * @private
      * @const {string}
      */
    function Hammer3(element, options) {
      if (options === void 0) {
        options = {};
      }
      return new Manager(element, _extends({
        recognizers: preset.concat()
      }, options));
    }
  );
  Hammer2.VERSION = "2.0.17-rc";
  Hammer2.DIRECTION_ALL = DIRECTION_ALL;
  Hammer2.DIRECTION_DOWN = DIRECTION_DOWN;
  Hammer2.DIRECTION_LEFT = DIRECTION_LEFT;
  Hammer2.DIRECTION_RIGHT = DIRECTION_RIGHT;
  Hammer2.DIRECTION_UP = DIRECTION_UP;
  Hammer2.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;
  Hammer2.DIRECTION_VERTICAL = DIRECTION_VERTICAL;
  Hammer2.DIRECTION_NONE = DIRECTION_NONE;
  Hammer2.DIRECTION_DOWN = DIRECTION_DOWN;
  Hammer2.INPUT_START = INPUT_START;
  Hammer2.INPUT_MOVE = INPUT_MOVE;
  Hammer2.INPUT_END = INPUT_END;
  Hammer2.INPUT_CANCEL = INPUT_CANCEL;
  Hammer2.STATE_POSSIBLE = STATE_POSSIBLE;
  Hammer2.STATE_BEGAN = STATE_BEGAN;
  Hammer2.STATE_CHANGED = STATE_CHANGED;
  Hammer2.STATE_ENDED = STATE_ENDED;
  Hammer2.STATE_RECOGNIZED = STATE_RECOGNIZED;
  Hammer2.STATE_CANCELLED = STATE_CANCELLED;
  Hammer2.STATE_FAILED = STATE_FAILED;
  Hammer2.Manager = Manager;
  Hammer2.Input = Input;
  Hammer2.TouchAction = TouchAction;
  Hammer2.TouchInput = TouchInput;
  Hammer2.MouseInput = MouseInput;
  Hammer2.PointerEventInput = PointerEventInput;
  Hammer2.TouchMouseInput = TouchMouseInput;
  Hammer2.SingleTouchInput = SingleTouchInput;
  Hammer2.Recognizer = Recognizer;
  Hammer2.AttrRecognizer = AttrRecognizer;
  Hammer2.Tap = TapRecognizer;
  Hammer2.Pan = PanRecognizer;
  Hammer2.Swipe = SwipeRecognizer;
  Hammer2.Pinch = PinchRecognizer;
  Hammer2.Rotate = RotateRecognizer;
  Hammer2.Press = PressRecognizer;
  Hammer2.on = addEventListeners;
  Hammer2.off = removeEventListeners;
  Hammer2.each = each;
  Hammer2.merge = merge;
  Hammer2.extend = extend$1;
  Hammer2.bindFn = bindFn;
  Hammer2.assign = assign$1;
  Hammer2.inherit = inherit;
  Hammer2.bindFn = bindFn;
  Hammer2.prefixed = prefixed;
  Hammer2.toArray = toArray$1;
  Hammer2.inArray = inArray;
  Hammer2.uniqueArray = uniqueArray;
  Hammer2.splitStr = splitStr;
  Hammer2.boolOrFn = boolOrFn;
  Hammer2.hasParent = hasParent$1;
  Hammer2.addEventListeners = addEventListeners;
  Hammer2.removeEventListeners = removeEventListeners;
  Hammer2.defaults = assign$1({}, defaults, {
    preset
  });
  return Hammer2;
})();
Hammer$3.defaults;
var DELETE = _Symbol$1("DELETE");
function pureDeepObjectAssign(base) {
  for (var _len = arguments.length, updates = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    updates[_key - 1] = arguments[_key];
  }
  return deepObjectAssign({}, base, ...updates);
}
function deepObjectAssign() {
  const merged = deepObjectAssignNonentry(...arguments);
  stripDelete(merged);
  return merged;
}
function deepObjectAssignNonentry() {
  for (var _len2 = arguments.length, values2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    values2[_key2] = arguments[_key2];
  }
  if (values2.length < 2) {
    return values2[0];
  } else if (values2.length > 2) {
    return deepObjectAssignNonentry(deepObjectAssign(values2[0], values2[1]), ..._sliceInstanceProperty(values2).call(values2, 2));
  }
  const a = values2[0];
  const b = values2[1];
  if (a instanceof Date && b instanceof Date) {
    a.setTime(b.getTime());
    return a;
  }
  for (const prop of _Reflect$ownKeys(b)) {
    if (!Object.prototype.propertyIsEnumerable.call(b, prop)) ;
    else if (b[prop] === DELETE) {
      delete a[prop];
    } else if (a[prop] !== null && b[prop] !== null && typeof a[prop] === "object" && typeof b[prop] === "object" && !_Array$isArray(a[prop]) && !_Array$isArray(b[prop])) {
      a[prop] = deepObjectAssignNonentry(a[prop], b[prop]);
    } else {
      a[prop] = clone(b[prop]);
    }
  }
  return a;
}
function clone(a) {
  if (_Array$isArray(a)) {
    return _mapInstanceProperty(a).call(a, (value) => clone(value));
  } else if (typeof a === "object" && a !== null) {
    if (a instanceof Date) {
      return new Date(a.getTime());
    }
    return deepObjectAssignNonentry({}, a);
  } else {
    return a;
  }
}
function stripDelete(a) {
  for (const prop of _Object$keys(a)) {
    if (a[prop] === DELETE) {
      delete a[prop];
    } else if (typeof a[prop] === "object" && a[prop] !== null) {
      stripDelete(a[prop]);
    }
  }
}
function Alea() {
  for (var _len3 = arguments.length, seed = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    seed[_key3] = arguments[_key3];
  }
  return AleaImplementation(seed.length ? seed : [_Date$now()]);
}
function AleaImplementation(seed) {
  let [s0, s1, s2] = mashSeed(seed);
  let c = 1;
  const random = () => {
    const t = 2091639 * s0 + c * 23283064365386963e-26;
    s0 = s1;
    s1 = s2;
    return s2 = t - (c = t | 0);
  };
  random.uint32 = () => random() * 4294967296;
  random.fract53 = () => random() + (random() * 2097152 | 0) * 11102230246251565e-32;
  random.algorithm = "Alea";
  random.seed = seed;
  random.version = "0.9";
  return random;
}
function mashSeed() {
  const mash = Mash();
  let s0 = mash(" ");
  let s1 = mash(" ");
  let s2 = mash(" ");
  for (let i = 0; i < arguments.length; i++) {
    s0 -= mash(i < 0 || arguments.length <= i ? void 0 : arguments[i]);
    if (s0 < 0) {
      s0 += 1;
    }
    s1 -= mash(i < 0 || arguments.length <= i ? void 0 : arguments[i]);
    if (s1 < 0) {
      s1 += 1;
    }
    s2 -= mash(i < 0 || arguments.length <= i ? void 0 : arguments[i]);
    if (s2 < 0) {
      s2 += 1;
    }
  }
  return [s0, s1, s2];
}
function Mash() {
  let n = 4022871197;
  return function(data) {
    const string2 = data.toString();
    for (let i = 0; i < string2.length; i++) {
      n += string2.charCodeAt(i);
      let h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 4294967296;
    }
    return (n >>> 0) * 23283064365386963e-26;
  };
}
function hammerMock$1() {
  const noop = () => {
  };
  return {
    on: noop,
    off: noop,
    destroy: noop,
    emit: noop,
    get() {
      return {
        set: noop
      };
    }
  };
}
var Hammer$1 = typeof window !== "undefined" ? window.Hammer || Hammer$3 : function() {
  return hammerMock$1();
};
function Activator$1(container) {
  var _context;
  this._cleanupQueue = [];
  this.active = false;
  this._dom = {
    container,
    overlay: document.createElement("div")
  };
  this._dom.overlay.classList.add("vis-overlay");
  this._dom.container.appendChild(this._dom.overlay);
  this._cleanupQueue.push(() => {
    this._dom.overlay.parentNode.removeChild(this._dom.overlay);
  });
  const hammer = Hammer$1(this._dom.overlay);
  hammer.on("tap", _bindInstanceProperty(_context = this._onTapOverlay).call(_context, this));
  this._cleanupQueue.push(() => {
    hammer.destroy();
  });
  const events = ["tap", "doubletap", "press", "pinch", "pan", "panstart", "panmove", "panend"];
  _forEachInstanceProperty(events).call(events, (event2) => {
    hammer.on(event2, (event3) => {
      event3.srcEvent.stopPropagation();
    });
  });
  if (document && document.body) {
    this._onClick = (event2) => {
      if (!_hasParent$1(event2.target, container)) {
        this.deactivate();
      }
    };
    document.body.addEventListener("click", this._onClick);
    this._cleanupQueue.push(() => {
      document.body.removeEventListener("click", this._onClick);
    });
  }
  this._escListener = (event2) => {
    if ("key" in event2 ? event2.key === "Escape" : event2.keyCode === 27) {
      this.deactivate();
    }
  };
}
Emitter(Activator$1.prototype);
Activator$1.current = null;
Activator$1.prototype.destroy = function() {
  this.deactivate();
  for (const callback of _reverseInstanceProperty(_context2 = _spliceInstanceProperty(_context3 = this._cleanupQueue).call(_context3, 0)).call(_context2)) {
    var _context2, _context3;
    callback();
  }
};
Activator$1.prototype.activate = function() {
  if (Activator$1.current) {
    Activator$1.current.deactivate();
  }
  Activator$1.current = this;
  this.active = true;
  this._dom.overlay.style.display = "none";
  this._dom.container.classList.add("vis-active");
  this.emit("change");
  this.emit("activate");
  document.body.addEventListener("keydown", this._escListener);
};
Activator$1.prototype.deactivate = function() {
  this.active = false;
  this._dom.overlay.style.display = "block";
  this._dom.container.classList.remove("vis-active");
  document.body.removeEventListener("keydown", this._escListener);
  this.emit("change");
  this.emit("deactivate");
};
Activator$1.prototype._onTapOverlay = function(event2) {
  this.activate();
  event2.srcEvent.stopPropagation();
};
function _hasParent$1(element, parent) {
  while (element) {
    if (element === parent) {
      return true;
    }
    element = element.parentNode;
  }
  return false;
}
var ASPDateRegex$1 = /^\/?Date\((-?\d+)/i;
var fullHexRE = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
var shortHexRE = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
var rgbRE = /^rgb\( *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *\)$/i;
var rgbaRE = /^rgba\( *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *([01]|0?\.\d+) *\)$/i;
function isNumber(value) {
  return value instanceof Number || typeof value === "number";
}
function recursiveDOMDelete(DOMobject) {
  if (DOMobject) {
    while (DOMobject.hasChildNodes() === true) {
      const child = DOMobject.firstChild;
      if (child) {
        recursiveDOMDelete(child);
        DOMobject.removeChild(child);
      }
    }
  }
}
function isString(value) {
  return value instanceof String || typeof value === "string";
}
function isObject(value) {
  return typeof value === "object" && value !== null;
}
function isDate(value) {
  if (value instanceof Date) {
    return true;
  } else if (isString(value)) {
    const match = ASPDateRegex$1.exec(value);
    if (match) {
      return true;
    } else if (!isNaN(Date.parse(value))) {
      return true;
    }
  }
  return false;
}
function copyOrDelete(a, b, prop, allowDeletion) {
  let doDeletion = false;
  if (allowDeletion === true) {
    doDeletion = b[prop] === null && a[prop] !== void 0;
  }
  if (doDeletion) {
    delete a[prop];
  } else {
    a[prop] = b[prop];
  }
}
function fillIfDefined(a, b) {
  let allowDeletion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  for (const prop in a) {
    if (b[prop] !== void 0) {
      if (b[prop] === null || typeof b[prop] !== "object") {
        copyOrDelete(a, b, prop, allowDeletion);
      } else {
        const aProp = a[prop];
        const bProp = b[prop];
        if (isObject(aProp) && isObject(bProp)) {
          fillIfDefined(aProp, bProp, allowDeletion);
        }
      }
    }
  }
}
var extend = _Object$assign;
function selectiveExtend(props, a) {
  if (!_Array$isArray(props)) {
    throw new Error("Array with property names expected as first argument");
  }
  for (var _len4 = arguments.length, others = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
    others[_key4 - 2] = arguments[_key4];
  }
  for (const other of others) {
    for (let p = 0; p < props.length; p++) {
      const prop = props[p];
      if (other && Object.prototype.hasOwnProperty.call(other, prop)) {
        a[prop] = other[prop];
      }
    }
  }
  return a;
}
function selectiveDeepExtend(props, a, b) {
  let allowDeletion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (_Array$isArray(b)) {
    throw new TypeError("Arrays are not supported by deepExtend");
  }
  for (let p = 0; p < props.length; p++) {
    const prop = props[p];
    if (Object.prototype.hasOwnProperty.call(b, prop)) {
      if (b[prop] && b[prop].constructor === Object) {
        if (a[prop] === void 0) {
          a[prop] = {};
        }
        if (a[prop].constructor === Object) {
          deepExtend(a[prop], b[prop], false, allowDeletion);
        } else {
          copyOrDelete(a, b, prop, allowDeletion);
        }
      } else if (_Array$isArray(b[prop])) {
        throw new TypeError("Arrays are not supported by deepExtend");
      } else {
        copyOrDelete(a, b, prop, allowDeletion);
      }
    }
  }
  return a;
}
function selectiveNotDeepExtend(propsToExclude, a, b) {
  let allowDeletion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (_Array$isArray(b)) {
    throw new TypeError("Arrays are not supported by deepExtend");
  }
  for (const prop in b) {
    if (!Object.prototype.hasOwnProperty.call(b, prop)) {
      continue;
    }
    if (_includesInstanceProperty(propsToExclude).call(propsToExclude, prop)) {
      continue;
    }
    if (b[prop] && b[prop].constructor === Object) {
      if (a[prop] === void 0) {
        a[prop] = {};
      }
      if (a[prop].constructor === Object) {
        deepExtend(a[prop], b[prop]);
      } else {
        copyOrDelete(a, b, prop, allowDeletion);
      }
    } else if (_Array$isArray(b[prop])) {
      a[prop] = [];
      for (let i = 0; i < b[prop].length; i++) {
        a[prop].push(b[prop][i]);
      }
    } else {
      copyOrDelete(a, b, prop, allowDeletion);
    }
  }
  return a;
}
function deepExtend(a, b) {
  let protoExtend = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  let allowDeletion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  for (const prop in b) {
    if (Object.prototype.hasOwnProperty.call(b, prop) || protoExtend === true) {
      if (typeof b[prop] === "object" && b[prop] !== null && _Object$getPrototypeOf(b[prop]) === Object.prototype) {
        if (a[prop] === void 0) {
          a[prop] = deepExtend({}, b[prop], protoExtend);
        } else if (typeof a[prop] === "object" && a[prop] !== null && _Object$getPrototypeOf(a[prop]) === Object.prototype) {
          deepExtend(a[prop], b[prop], protoExtend);
        } else {
          copyOrDelete(a, b, prop, allowDeletion);
        }
      } else if (_Array$isArray(b[prop])) {
        var _context4;
        a[prop] = _sliceInstanceProperty(_context4 = b[prop]).call(_context4);
      } else {
        copyOrDelete(a, b, prop, allowDeletion);
      }
    }
  }
  return a;
}
function equalArray(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0, len = a.length; i < len; i++) {
    if (a[i] != b[i]) {
      return false;
    }
  }
  return true;
}
function getType(object2) {
  const type = typeof object2;
  if (type === "object") {
    if (object2 === null) {
      return "null";
    }
    if (object2 instanceof Boolean) {
      return "Boolean";
    }
    if (object2 instanceof Number) {
      return "Number";
    }
    if (object2 instanceof String) {
      return "String";
    }
    if (_Array$isArray(object2)) {
      return "Array";
    }
    if (object2 instanceof Date) {
      return "Date";
    }
    return "Object";
  }
  if (type === "number") {
    return "Number";
  }
  if (type === "boolean") {
    return "Boolean";
  }
  if (type === "string") {
    return "String";
  }
  if (type === void 0) {
    return "undefined";
  }
  return type;
}
function copyAndExtendArray(arr, newValue) {
  return [...arr, newValue];
}
function copyArray(arr) {
  return _sliceInstanceProperty(arr).call(arr);
}
function getAbsoluteLeft(elem) {
  return elem.getBoundingClientRect().left;
}
function getAbsoluteRight(elem) {
  return elem.getBoundingClientRect().right;
}
function getAbsoluteTop(elem) {
  return elem.getBoundingClientRect().top;
}
function addClassName(elem, classNames) {
  let classes = elem.className.split(" ");
  const newClasses = classNames.split(" ");
  classes = _concatInstanceProperty(classes).call(classes, _filterInstanceProperty(newClasses).call(newClasses, function(className) {
    return !_includesInstanceProperty(classes).call(classes, className);
  }));
  elem.className = classes.join(" ");
}
function removeClassName(elem, classNames) {
  let classes = elem.className.split(" ");
  const oldClasses = classNames.split(" ");
  classes = _filterInstanceProperty(classes).call(classes, function(className) {
    return !_includesInstanceProperty(oldClasses).call(oldClasses, className);
  });
  elem.className = classes.join(" ");
}
function forEach(object2, callback) {
  if (_Array$isArray(object2)) {
    const len = object2.length;
    for (let i = 0; i < len; i++) {
      callback(object2[i], i, object2);
    }
  } else {
    for (const key in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key)) {
        callback(object2[key], key, object2);
      }
    }
  }
}
var toArray = _Object$values;
function updateProperty(object2, key, value) {
  if (object2[key] !== value) {
    object2[key] = value;
    return true;
  } else {
    return false;
  }
}
function throttle(fn) {
  let scheduled = false;
  return () => {
    if (!scheduled) {
      scheduled = true;
      requestAnimationFrame(() => {
        scheduled = false;
        fn();
      });
    }
  };
}
function preventDefault(event2) {
  if (!event2) {
    event2 = window.event;
  }
  if (!event2) ;
  else if (event2.preventDefault) {
    event2.preventDefault();
  } else {
    event2.returnValue = false;
  }
}
function getTarget() {
  let event2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
  let target = null;
  if (!event2) ;
  else if (event2.target) {
    target = event2.target;
  } else if (event2.srcElement) {
    target = event2.srcElement;
  }
  if (!(target instanceof Element)) {
    return null;
  }
  if (target.nodeType != null && target.nodeType == 3) {
    target = target.parentNode;
    if (!(target instanceof Element)) {
      return null;
    }
  }
  return target;
}
function hasParent(element, parent) {
  let elem = element;
  while (elem) {
    if (elem === parent) {
      return true;
    } else if (elem.parentNode) {
      elem = elem.parentNode;
    } else {
      return false;
    }
  }
  return false;
}
var option = {
  /**
   * Convert a value into a boolean.
   * @param value - Value to be converted intoboolean, a function will be executed as `(() => unknown)`.
   * @param defaultValue - If the value or the return value of the function == null then this will be returned.
   * @returns Corresponding boolean value, if none then the default value, if none then null.
   */
  asBoolean(value, defaultValue) {
    if (typeof value == "function") {
      value = value();
    }
    if (value != null) {
      return value != false;
    }
    return defaultValue || null;
  },
  /**
   * Convert a value into a number.
   * @param value - Value to be converted intonumber, a function will be executed as `(() => unknown)`.
   * @param defaultValue - If the value or the return value of the function == null then this will be returned.
   * @returns Corresponding **boxed** number value, if none then the default value, if none then null.
   */
  asNumber(value, defaultValue) {
    if (typeof value == "function") {
      value = value();
    }
    if (value != null) {
      return Number(value) || defaultValue || null;
    }
    return defaultValue || null;
  },
  /**
   * Convert a value into a string.
   * @param value - Value to be converted intostring, a function will be executed as `(() => unknown)`.
   * @param defaultValue - If the value or the return value of the function == null then this will be returned.
   * @returns Corresponding **boxed** string value, if none then the default value, if none then null.
   */
  asString(value, defaultValue) {
    if (typeof value == "function") {
      value = value();
    }
    if (value != null) {
      return String(value);
    }
    return defaultValue || null;
  },
  /**
   * Convert a value into a size.
   * @param value - Value to be converted intosize, a function will be executed as `(() => unknown)`.
   * @param defaultValue - If the value or the return value of the function == null then this will be returned.
   * @returns Corresponding string value (number + 'px'), if none then the default value, if none then null.
   */
  asSize(value, defaultValue) {
    if (typeof value == "function") {
      value = value();
    }
    if (isString(value)) {
      return value;
    } else if (isNumber(value)) {
      return value + "px";
    } else {
      return defaultValue || null;
    }
  },
  /**
   * Convert a value into a DOM Element.
   * @param value - Value to be converted into DOM Element, a function will be executed as `(() => unknown)`.
   * @param defaultValue - If the value or the return value of the function == null then this will be returned.
   * @returns The DOM Element, if none then the default value, if none then null.
   */
  asElement(value, defaultValue) {
    if (typeof value == "function") {
      value = value();
    }
    return value || defaultValue || null;
  }
};
function hexToRGB(hex) {
  let result;
  switch (hex.length) {
    case 3:
    case 4:
      result = shortHexRE.exec(hex);
      return result ? {
        r: _parseInt(result[1] + result[1], 16),
        g: _parseInt(result[2] + result[2], 16),
        b: _parseInt(result[3] + result[3], 16)
      } : null;
    case 6:
    case 7:
      result = fullHexRE.exec(hex);
      return result ? {
        r: _parseInt(result[1], 16),
        g: _parseInt(result[2], 16),
        b: _parseInt(result[3], 16)
      } : null;
    default:
      return null;
  }
}
function overrideOpacity(color, opacity) {
  if (_includesInstanceProperty(color).call(color, "rgba")) {
    return color;
  } else if (_includesInstanceProperty(color).call(color, "rgb")) {
    const rgb = color.substr(_indexOfInstanceProperty(color).call(color, "(") + 1).replace(")", "").split(",");
    return "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + "," + opacity + ")";
  } else {
    const rgb = hexToRGB(color);
    if (rgb == null) {
      return color;
    } else {
      return "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + opacity + ")";
    }
  }
}
function RGBToHex(red, green, blue) {
  var _context5;
  return "#" + _sliceInstanceProperty(_context5 = ((1 << 24) + (red << 16) + (green << 8) + blue).toString(16)).call(_context5, 1);
}
function parseColor(inputColor, defaultColor) {
  if (isString(inputColor)) {
    let colorStr = inputColor;
    if (isValidRGB(colorStr)) {
      var _context6;
      const rgb = _mapInstanceProperty(_context6 = colorStr.substr(4).substr(0, colorStr.length - 5).split(",")).call(_context6, function(value) {
        return _parseInt(value);
      });
      colorStr = RGBToHex(rgb[0], rgb[1], rgb[2]);
    }
    if (isValidHex(colorStr) === true) {
      const hsv = hexToHSV(colorStr);
      const lighterColorHSV = {
        h: hsv.h,
        s: hsv.s * 0.8,
        v: Math.min(1, hsv.v * 1.02)
      };
      const darkerColorHSV = {
        h: hsv.h,
        s: Math.min(1, hsv.s * 1.25),
        v: hsv.v * 0.8
      };
      const darkerColorHex = HSVToHex(darkerColorHSV.h, darkerColorHSV.s, darkerColorHSV.v);
      const lighterColorHex = HSVToHex(lighterColorHSV.h, lighterColorHSV.s, lighterColorHSV.v);
      return {
        background: colorStr,
        border: darkerColorHex,
        highlight: {
          background: lighterColorHex,
          border: darkerColorHex
        },
        hover: {
          background: lighterColorHex,
          border: darkerColorHex
        }
      };
    } else {
      return {
        background: colorStr,
        border: colorStr,
        highlight: {
          background: colorStr,
          border: colorStr
        },
        hover: {
          background: colorStr,
          border: colorStr
        }
      };
    }
  } else {
    if (defaultColor) {
      const color = {
        background: inputColor.background || defaultColor.background,
        border: inputColor.border || defaultColor.border,
        highlight: isString(inputColor.highlight) ? {
          border: inputColor.highlight,
          background: inputColor.highlight
        } : {
          background: inputColor.highlight && inputColor.highlight.background || defaultColor.highlight.background,
          border: inputColor.highlight && inputColor.highlight.border || defaultColor.highlight.border
        },
        hover: isString(inputColor.hover) ? {
          border: inputColor.hover,
          background: inputColor.hover
        } : {
          border: inputColor.hover && inputColor.hover.border || defaultColor.hover.border,
          background: inputColor.hover && inputColor.hover.background || defaultColor.hover.background
        }
      };
      return color;
    } else {
      const color = {
        background: inputColor.background || void 0,
        border: inputColor.border || void 0,
        highlight: isString(inputColor.highlight) ? {
          border: inputColor.highlight,
          background: inputColor.highlight
        } : {
          background: inputColor.highlight && inputColor.highlight.background || void 0,
          border: inputColor.highlight && inputColor.highlight.border || void 0
        },
        hover: isString(inputColor.hover) ? {
          border: inputColor.hover,
          background: inputColor.hover
        } : {
          border: inputColor.hover && inputColor.hover.border || void 0,
          background: inputColor.hover && inputColor.hover.background || void 0
        }
      };
      return color;
    }
  }
}
function RGBToHSV(red, green, blue) {
  red = red / 255;
  green = green / 255;
  blue = blue / 255;
  const minRGB = Math.min(red, Math.min(green, blue));
  const maxRGB = Math.max(red, Math.max(green, blue));
  if (minRGB === maxRGB) {
    return {
      h: 0,
      s: 0,
      v: minRGB
    };
  }
  const d = red === minRGB ? green - blue : blue === minRGB ? red - green : blue - red;
  const h = red === minRGB ? 3 : blue === minRGB ? 1 : 5;
  const hue = 60 * (h - d / (maxRGB - minRGB)) / 360;
  const saturation = (maxRGB - minRGB) / maxRGB;
  const value = maxRGB;
  return {
    h: hue,
    s: saturation,
    v: value
  };
}
function splitCSSText(cssText) {
  const tmpEllement = document.createElement("div");
  const styles = {};
  tmpEllement.style.cssText = cssText;
  for (let i = 0; i < tmpEllement.style.length; ++i) {
    styles[tmpEllement.style[i]] = tmpEllement.style.getPropertyValue(tmpEllement.style[i]);
  }
  return styles;
}
function addCssText(element, cssText) {
  const cssStyle = splitCSSText(cssText);
  for (const [key, value] of _Object$entries(cssStyle)) {
    element.style.setProperty(key, value);
  }
}
function removeCssText(element, cssText) {
  const cssStyle = splitCSSText(cssText);
  for (const key of _Object$keys(cssStyle)) {
    element.style.removeProperty(key);
  }
}
function HSVToRGB(h, s, v) {
  let r;
  let g;
  let b;
  const i = Math.floor(h * 6);
  const f = h * 6 - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);
  switch (i % 6) {
    case 0:
      r = v, g = t, b = p;
      break;
    case 1:
      r = q, g = v, b = p;
      break;
    case 2:
      r = p, g = v, b = t;
      break;
    case 3:
      r = p, g = q, b = v;
      break;
    case 4:
      r = t, g = p, b = v;
      break;
    case 5:
      r = v, g = p, b = q;
      break;
  }
  return {
    r: Math.floor(r * 255),
    g: Math.floor(g * 255),
    b: Math.floor(b * 255)
  };
}
function HSVToHex(h, s, v) {
  const rgb = HSVToRGB(h, s, v);
  return RGBToHex(rgb.r, rgb.g, rgb.b);
}
function hexToHSV(hex) {
  const rgb = hexToRGB(hex);
  if (!rgb) {
    throw new TypeError("'".concat(hex, "' is not a valid color."));
  }
  return RGBToHSV(rgb.r, rgb.g, rgb.b);
}
function isValidHex(hex) {
  const isOk = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);
  return isOk;
}
function isValidRGB(rgb) {
  return rgbRE.test(rgb);
}
function isValidRGBA(rgba) {
  return rgbaRE.test(rgba);
}
function selectiveBridgeObject(fields, referenceObject) {
  if (referenceObject !== null && typeof referenceObject === "object") {
    const objectTo = _Object$create(referenceObject);
    for (let i = 0; i < fields.length; i++) {
      if (Object.prototype.hasOwnProperty.call(referenceObject, fields[i])) {
        if (typeof referenceObject[fields[i]] == "object") {
          objectTo[fields[i]] = bridgeObject(referenceObject[fields[i]]);
        }
      }
    }
    return objectTo;
  } else {
    return null;
  }
}
function bridgeObject(referenceObject) {
  if (referenceObject === null || typeof referenceObject !== "object") {
    return null;
  }
  if (referenceObject instanceof Element) {
    return referenceObject;
  }
  const objectTo = _Object$create(referenceObject);
  for (const i in referenceObject) {
    if (Object.prototype.hasOwnProperty.call(referenceObject, i)) {
      if (typeof referenceObject[i] == "object") {
        objectTo[i] = bridgeObject(referenceObject[i]);
      }
    }
  }
  return objectTo;
}
function insertSort(a, compare) {
  for (let i = 0; i < a.length; i++) {
    const k = a[i];
    let j;
    for (j = i; j > 0 && compare(k, a[j - 1]) < 0; j--) {
      a[j] = a[j - 1];
    }
    a[j] = k;
  }
  return a;
}
function mergeOptions(mergeTarget, options, option2) {
  let globalOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  const isPresent = function(obj) {
    return obj !== null && obj !== void 0;
  };
  const isObject2 = function(obj) {
    return obj !== null && typeof obj === "object";
  };
  const isEmpty = function(obj) {
    for (const x in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, x)) {
        return false;
      }
    }
    return true;
  };
  if (!isObject2(mergeTarget)) {
    throw new Error("Parameter mergeTarget must be an object");
  }
  if (!isObject2(options)) {
    throw new Error("Parameter options must be an object");
  }
  if (!isPresent(option2)) {
    throw new Error("Parameter option must have a value");
  }
  if (!isObject2(globalOptions)) {
    throw new Error("Parameter globalOptions must be an object");
  }
  const doMerge = function(target, options2, option3) {
    if (!isObject2(target[option3])) {
      target[option3] = {};
    }
    const src = options2[option3];
    const dst = target[option3];
    for (const prop in src) {
      if (Object.prototype.hasOwnProperty.call(src, prop)) {
        dst[prop] = src[prop];
      }
    }
  };
  const srcOption = options[option2];
  const globalPassed = isObject2(globalOptions) && !isEmpty(globalOptions);
  const globalOption = globalPassed ? globalOptions[option2] : void 0;
  const globalEnabled = globalOption ? globalOption.enabled : void 0;
  if (srcOption === void 0) {
    return;
  }
  if (typeof srcOption === "boolean") {
    if (!isObject2(mergeTarget[option2])) {
      mergeTarget[option2] = {};
    }
    mergeTarget[option2].enabled = srcOption;
    return;
  }
  if (srcOption === null && !isObject2(mergeTarget[option2])) {
    if (isPresent(globalOption)) {
      mergeTarget[option2] = _Object$create(globalOption);
    } else {
      return;
    }
  }
  if (!isObject2(srcOption)) {
    return;
  }
  let enabled = true;
  if (srcOption.enabled !== void 0) {
    enabled = srcOption.enabled;
  } else {
    if (globalEnabled !== void 0) {
      enabled = globalOption.enabled;
    }
  }
  doMerge(mergeTarget, options, option2);
  mergeTarget[option2].enabled = enabled;
}
function binarySearchCustom(orderedItems, comparator, field, field2) {
  const maxIterations = 1e4;
  let iteration = 0;
  let low = 0;
  let high = orderedItems.length - 1;
  while (low <= high && iteration < maxIterations) {
    const middle = Math.floor((low + high) / 2);
    const item = orderedItems[middle];
    const value = field2 === void 0 ? item[field] : item[field][field2];
    const searchResult = comparator(value);
    if (searchResult == 0) {
      return middle;
    } else if (searchResult == -1) {
      low = middle + 1;
    } else {
      high = middle - 1;
    }
    iteration++;
  }
  return -1;
}
function binarySearchValue(orderedItems, target, field, sidePreference, comparator) {
  const maxIterations = 1e4;
  let iteration = 0;
  let low = 0;
  let high = orderedItems.length - 1;
  let prevValue;
  let value;
  let nextValue;
  let middle;
  comparator = comparator != void 0 ? comparator : function(a, b) {
    return a == b ? 0 : a < b ? -1 : 1;
  };
  while (low <= high && iteration < maxIterations) {
    middle = Math.floor(0.5 * (high + low));
    prevValue = orderedItems[Math.max(0, middle - 1)][field];
    value = orderedItems[middle][field];
    nextValue = orderedItems[Math.min(orderedItems.length - 1, middle + 1)][field];
    if (comparator(value, target) == 0) {
      return middle;
    } else if (comparator(prevValue, target) < 0 && comparator(value, target) > 0) {
      return sidePreference == "before" ? Math.max(0, middle - 1) : middle;
    } else if (comparator(value, target) < 0 && comparator(nextValue, target) > 0) {
      return sidePreference == "before" ? middle : Math.min(orderedItems.length - 1, middle + 1);
    } else {
      if (comparator(value, target) < 0) {
        low = middle + 1;
      } else {
        high = middle - 1;
      }
    }
    iteration++;
  }
  return -1;
}
var easingFunctions = {
  /**
   * Provides no easing and no acceleration.
   * @param t - Time.
   * @returns Value at time t.
   */
  linear(t) {
    return t;
  },
  /**
   * Accelerate from zero velocity.
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInQuad(t) {
    return t * t;
  },
  /**
   * Decelerate to zero velocity.
   * @param t - Time.
   * @returns Value at time t.
   */
  easeOutQuad(t) {
    return t * (2 - t);
  },
  /**
   * Accelerate until halfway, then decelerate.
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  /**
   * Accelerate from zero velocity.
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInCubic(t) {
    return t * t * t;
  },
  /**
   * Decelerate to zero velocity.
   * @param t - Time.
   * @returns Value at time t.
   */
  easeOutCubic(t) {
    return --t * t * t + 1;
  },
  /**
   * Accelerate until halfway, then decelerate.
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  /**
   * Accelerate from zero velocity.
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInQuart(t) {
    return t * t * t * t;
  },
  /**
   * Decelerate to zero velocity.
   * @param t - Time.
   * @returns Value at time t.
   */
  easeOutQuart(t) {
    return 1 - --t * t * t * t;
  },
  /**
   * Accelerate until halfway, then decelerate.
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInOutQuart(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  /**
   * Accelerate from zero velocity.
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInQuint(t) {
    return t * t * t * t * t;
  },
  /**
   * Decelerate to zero velocity.
   * @param t - Time.
   * @returns Value at time t.
   */
  easeOutQuint(t) {
    return 1 + --t * t * t * t * t;
  },
  /**
   * Accelerate until halfway, then decelerate.
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInOutQuint(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};
function getScrollBarWidth() {
  const inner = document.createElement("p");
  inner.style.width = "100%";
  inner.style.height = "200px";
  const outer = document.createElement("div");
  outer.style.position = "absolute";
  outer.style.top = "0px";
  outer.style.left = "0px";
  outer.style.visibility = "hidden";
  outer.style.width = "200px";
  outer.style.height = "150px";
  outer.style.overflow = "hidden";
  outer.appendChild(inner);
  document.body.appendChild(outer);
  const w1 = inner.offsetWidth;
  outer.style.overflow = "scroll";
  let w2 = inner.offsetWidth;
  if (w1 == w2) {
    w2 = outer.clientWidth;
  }
  document.body.removeChild(outer);
  return w1 - w2;
}
function topMost(pile, accessors) {
  let candidate;
  if (!_Array$isArray(accessors)) {
    accessors = [accessors];
  }
  for (const member of pile) {
    if (member) {
      candidate = member[accessors[0]];
      for (let i = 1; i < accessors.length; i++) {
        if (candidate) {
          candidate = candidate[accessors[i]];
        }
      }
      if (typeof candidate !== "undefined") {
        break;
      }
    }
  }
  return candidate;
}
var htmlColors$1 = {
  black: "#000000",
  navy: "#000080",
  darkblue: "#00008B",
  mediumblue: "#0000CD",
  blue: "#0000FF",
  darkgreen: "#006400",
  green: "#008000",
  teal: "#008080",
  darkcyan: "#008B8B",
  deepskyblue: "#00BFFF",
  darkturquoise: "#00CED1",
  mediumspringgreen: "#00FA9A",
  lime: "#00FF00",
  springgreen: "#00FF7F",
  aqua: "#00FFFF",
  cyan: "#00FFFF",
  midnightblue: "#191970",
  dodgerblue: "#1E90FF",
  lightseagreen: "#20B2AA",
  forestgreen: "#228B22",
  seagreen: "#2E8B57",
  darkslategray: "#2F4F4F",
  limegreen: "#32CD32",
  mediumseagreen: "#3CB371",
  turquoise: "#40E0D0",
  royalblue: "#4169E1",
  steelblue: "#4682B4",
  darkslateblue: "#483D8B",
  mediumturquoise: "#48D1CC",
  indigo: "#4B0082",
  darkolivegreen: "#556B2F",
  cadetblue: "#5F9EA0",
  cornflowerblue: "#6495ED",
  mediumaquamarine: "#66CDAA",
  dimgray: "#696969",
  slateblue: "#6A5ACD",
  olivedrab: "#6B8E23",
  slategray: "#708090",
  lightslategray: "#778899",
  mediumslateblue: "#7B68EE",
  lawngreen: "#7CFC00",
  chartreuse: "#7FFF00",
  aquamarine: "#7FFFD4",
  maroon: "#800000",
  purple: "#800080",
  olive: "#808000",
  gray: "#808080",
  skyblue: "#87CEEB",
  lightskyblue: "#87CEFA",
  blueviolet: "#8A2BE2",
  darkred: "#8B0000",
  darkmagenta: "#8B008B",
  saddlebrown: "#8B4513",
  darkseagreen: "#8FBC8F",
  lightgreen: "#90EE90",
  mediumpurple: "#9370D8",
  darkviolet: "#9400D3",
  palegreen: "#98FB98",
  darkorchid: "#9932CC",
  yellowgreen: "#9ACD32",
  sienna: "#A0522D",
  brown: "#A52A2A",
  darkgray: "#A9A9A9",
  lightblue: "#ADD8E6",
  greenyellow: "#ADFF2F",
  paleturquoise: "#AFEEEE",
  lightsteelblue: "#B0C4DE",
  powderblue: "#B0E0E6",
  firebrick: "#B22222",
  darkgoldenrod: "#B8860B",
  mediumorchid: "#BA55D3",
  rosybrown: "#BC8F8F",
  darkkhaki: "#BDB76B",
  silver: "#C0C0C0",
  mediumvioletred: "#C71585",
  indianred: "#CD5C5C",
  peru: "#CD853F",
  chocolate: "#D2691E",
  tan: "#D2B48C",
  lightgrey: "#D3D3D3",
  palevioletred: "#D87093",
  thistle: "#D8BFD8",
  orchid: "#DA70D6",
  goldenrod: "#DAA520",
  crimson: "#DC143C",
  gainsboro: "#DCDCDC",
  plum: "#DDA0DD",
  burlywood: "#DEB887",
  lightcyan: "#E0FFFF",
  lavender: "#E6E6FA",
  darksalmon: "#E9967A",
  violet: "#EE82EE",
  palegoldenrod: "#EEE8AA",
  lightcoral: "#F08080",
  khaki: "#F0E68C",
  aliceblue: "#F0F8FF",
  honeydew: "#F0FFF0",
  azure: "#F0FFFF",
  sandybrown: "#F4A460",
  wheat: "#F5DEB3",
  beige: "#F5F5DC",
  whitesmoke: "#F5F5F5",
  mintcream: "#F5FFFA",
  ghostwhite: "#F8F8FF",
  salmon: "#FA8072",
  antiquewhite: "#FAEBD7",
  linen: "#FAF0E6",
  lightgoldenrodyellow: "#FAFAD2",
  oldlace: "#FDF5E6",
  red: "#FF0000",
  fuchsia: "#FF00FF",
  magenta: "#FF00FF",
  deeppink: "#FF1493",
  orangered: "#FF4500",
  tomato: "#FF6347",
  hotpink: "#FF69B4",
  coral: "#FF7F50",
  darkorange: "#FF8C00",
  lightsalmon: "#FFA07A",
  orange: "#FFA500",
  lightpink: "#FFB6C1",
  pink: "#FFC0CB",
  gold: "#FFD700",
  peachpuff: "#FFDAB9",
  navajowhite: "#FFDEAD",
  moccasin: "#FFE4B5",
  bisque: "#FFE4C4",
  mistyrose: "#FFE4E1",
  blanchedalmond: "#FFEBCD",
  papayawhip: "#FFEFD5",
  lavenderblush: "#FFF0F5",
  seashell: "#FFF5EE",
  cornsilk: "#FFF8DC",
  lemonchiffon: "#FFFACD",
  floralwhite: "#FFFAF0",
  snow: "#FFFAFA",
  yellow: "#FFFF00",
  lightyellow: "#FFFFE0",
  ivory: "#FFFFF0",
  white: "#FFFFFF"
};
var ColorPicker$1 = class ColorPicker {
  /**
   * @param {number} [pixelRatio]
   */
  constructor() {
    let pixelRatio = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
    this.pixelRatio = pixelRatio;
    this.generated = false;
    this.centerCoordinates = {
      x: 289 / 2,
      y: 289 / 2
    };
    this.r = 289 * 0.49;
    this.color = {
      r: 255,
      g: 255,
      b: 255,
      a: 1
    };
    this.hueCircle = void 0;
    this.initialColor = {
      r: 255,
      g: 255,
      b: 255,
      a: 1
    };
    this.previousColor = void 0;
    this.applied = false;
    this.updateCallback = () => {
    };
    this.closeCallback = () => {
    };
    this._create();
  }
  /**
   * this inserts the colorPicker into a div from the DOM
   * @param {Element} container
   */
  insertTo(container) {
    if (this.hammer !== void 0) {
      this.hammer.destroy();
      this.hammer = void 0;
    }
    this.container = container;
    this.container.appendChild(this.frame);
    this._bindHammer();
    this._setSize();
  }
  /**
   * the callback is executed on apply and save. Bind it to the application
   * @param {Function} callback
   */
  setUpdateCallback(callback) {
    if (typeof callback === "function") {
      this.updateCallback = callback;
    } else {
      throw new Error("Function attempted to set as colorPicker update callback is not a function.");
    }
  }
  /**
   * the callback is executed on apply and save. Bind it to the application
   * @param {Function} callback
   */
  setCloseCallback(callback) {
    if (typeof callback === "function") {
      this.closeCallback = callback;
    } else {
      throw new Error("Function attempted to set as colorPicker closing callback is not a function.");
    }
  }
  /**
   *
   * @param {string} color
   * @returns {string}
   * @private
   */
  _isColorString(color) {
    if (typeof color === "string") {
      return htmlColors$1[color];
    }
  }
  /**
   * Set the color of the colorPicker
   * Supported formats:
   * 'red'                   --> HTML color string
   * '#ffffff'               --> hex string
   * 'rgb(255,255,255)'      --> rgb string
   * 'rgba(255,255,255,1.0)' --> rgba string
   * {r:255,g:255,b:255}     --> rgb object
   * {r:255,g:255,b:255,a:1.0} --> rgba object
   * @param {string | object} color
   * @param {boolean} [setInitial]
   */
  setColor(color) {
    let setInitial = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (color === "none") {
      return;
    }
    let rgba;
    const htmlColor = this._isColorString(color);
    if (htmlColor !== void 0) {
      color = htmlColor;
    }
    if (isString(color) === true) {
      if (isValidRGB(color) === true) {
        const rgbaArray = color.substr(4).substr(0, color.length - 5).split(",");
        rgba = {
          r: rgbaArray[0],
          g: rgbaArray[1],
          b: rgbaArray[2],
          a: 1
        };
      } else if (isValidRGBA(color) === true) {
        const rgbaArray = color.substr(5).substr(0, color.length - 6).split(",");
        rgba = {
          r: rgbaArray[0],
          g: rgbaArray[1],
          b: rgbaArray[2],
          a: rgbaArray[3]
        };
      } else if (isValidHex(color) === true) {
        const rgbObj = hexToRGB(color);
        rgba = {
          r: rgbObj.r,
          g: rgbObj.g,
          b: rgbObj.b,
          a: 1
        };
      }
    } else {
      if (color instanceof Object) {
        if (color.r !== void 0 && color.g !== void 0 && color.b !== void 0) {
          const alpha = color.a !== void 0 ? color.a : "1.0";
          rgba = {
            r: color.r,
            g: color.g,
            b: color.b,
            a: alpha
          };
        }
      }
    }
    if (rgba === void 0) {
      throw new Error("Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: " + _JSON$stringify(color));
    } else {
      this._setColor(rgba, setInitial);
    }
  }
  /**
   * this shows the color picker.
   * The hue circle is constructed once and stored.
   */
  show() {
    if (this.closeCallback !== void 0) {
      this.closeCallback();
      this.closeCallback = void 0;
    }
    this.applied = false;
    this.frame.style.display = "block";
    this._generateHueCircle();
  }
  // ------------------------------------------ PRIVATE ----------------------------- //
  /**
   * Hide the picker. Is called by the cancel button.
   * Optional boolean to store the previous color for easy access later on.
   * @param {boolean} [storePrevious]
   * @private
   */
  _hide() {
    let storePrevious = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    if (storePrevious === true) {
      this.previousColor = _Object$assign({}, this.color);
    }
    if (this.applied === true) {
      this.updateCallback(this.initialColor);
    }
    this.frame.style.display = "none";
    _setTimeout(() => {
      if (this.closeCallback !== void 0) {
        this.closeCallback();
        this.closeCallback = void 0;
      }
    }, 0);
  }
  /**
   * bound to the save button. Saves and hides.
   * @private
   */
  _save() {
    this.updateCallback(this.color);
    this.applied = false;
    this._hide();
  }
  /**
   * Bound to apply button. Saves but does not close. Is undone by the cancel button.
   * @private
   */
  _apply() {
    this.applied = true;
    this.updateCallback(this.color);
    this._updatePicker(this.color);
  }
  /**
   * load the color from the previous session.
   * @private
   */
  _loadLast() {
    if (this.previousColor !== void 0) {
      this.setColor(this.previousColor, false);
    } else {
      alert("There is no last color to load...");
    }
  }
  /**
   * set the color, place the picker
   * @param {object} rgba
   * @param {boolean} [setInitial]
   * @private
   */
  _setColor(rgba) {
    let setInitial = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (setInitial === true) {
      this.initialColor = _Object$assign({}, rgba);
    }
    this.color = rgba;
    const hsv = RGBToHSV(rgba.r, rgba.g, rgba.b);
    const angleConvert = 2 * Math.PI;
    const radius = this.r * hsv.s;
    const x = this.centerCoordinates.x + radius * Math.sin(angleConvert * hsv.h);
    const y = this.centerCoordinates.y + radius * Math.cos(angleConvert * hsv.h);
    this.colorPickerSelector.style.left = x - 0.5 * this.colorPickerSelector.clientWidth + "px";
    this.colorPickerSelector.style.top = y - 0.5 * this.colorPickerSelector.clientHeight + "px";
    this._updatePicker(rgba);
  }
  /**
   * bound to opacity control
   * @param {number} value
   * @private
   */
  _setOpacity(value) {
    this.color.a = value / 100;
    this._updatePicker(this.color);
  }
  /**
   * bound to brightness control
   * @param {number} value
   * @private
   */
  _setBrightness(value) {
    const hsv = RGBToHSV(this.color.r, this.color.g, this.color.b);
    hsv.v = value / 100;
    const rgba = HSVToRGB(hsv.h, hsv.s, hsv.v);
    rgba["a"] = this.color.a;
    this.color = rgba;
    this._updatePicker();
  }
  /**
   * update the color picker. A black circle overlays the hue circle to mimic the brightness decreasing.
   * @param {object} rgba
   * @private
   */
  _updatePicker() {
    let rgba = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.color;
    const hsv = RGBToHSV(rgba.r, rgba.g, rgba.b);
    const ctx = this.colorPickerCanvas.getContext("2d");
    if (this.pixelRation === void 0) {
      this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
    }
    ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
    const w = this.colorPickerCanvas.clientWidth;
    const h = this.colorPickerCanvas.clientHeight;
    ctx.clearRect(0, 0, w, h);
    ctx.putImageData(this.hueCircle, 0, 0);
    ctx.fillStyle = "rgba(0,0,0," + (1 - hsv.v) + ")";
    ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
    _fillInstanceProperty(ctx).call(ctx);
    this.brightnessRange.value = 100 * hsv.v;
    this.opacityRange.value = 100 * rgba.a;
    this.initialColorDiv.style.backgroundColor = "rgba(" + this.initialColor.r + "," + this.initialColor.g + "," + this.initialColor.b + "," + this.initialColor.a + ")";
    this.newColorDiv.style.backgroundColor = "rgba(" + this.color.r + "," + this.color.g + "," + this.color.b + "," + this.color.a + ")";
  }
  /**
   * used by create to set the size of the canvas.
   * @private
   */
  _setSize() {
    this.colorPickerCanvas.style.width = "100%";
    this.colorPickerCanvas.style.height = "100%";
    this.colorPickerCanvas.width = 289 * this.pixelRatio;
    this.colorPickerCanvas.height = 289 * this.pixelRatio;
  }
  /**
   * create all dom elements
   * TODO: cleanup, lots of similar dom elements
   * @private
   */
  _create() {
    var _context7, _context8, _context9, _context0;
    this.frame = document.createElement("div");
    this.frame.className = "vis-color-picker";
    this.colorPickerDiv = document.createElement("div");
    this.colorPickerSelector = document.createElement("div");
    this.colorPickerSelector.className = "vis-selector";
    this.colorPickerDiv.appendChild(this.colorPickerSelector);
    this.colorPickerCanvas = document.createElement("canvas");
    this.colorPickerDiv.appendChild(this.colorPickerCanvas);
    if (!this.colorPickerCanvas.getContext) {
      const noCanvas = document.createElement("DIV");
      noCanvas.style.color = "red";
      noCanvas.style.fontWeight = "bold";
      noCanvas.style.padding = "10px";
      noCanvas.innerText = "Error: your browser does not support HTML canvas";
      this.colorPickerCanvas.appendChild(noCanvas);
    } else {
      const ctx = this.colorPickerCanvas.getContext("2d");
      this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
      this.colorPickerCanvas.getContext("2d").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
    }
    this.colorPickerDiv.className = "vis-color";
    this.opacityDiv = document.createElement("div");
    this.opacityDiv.className = "vis-opacity";
    this.brightnessDiv = document.createElement("div");
    this.brightnessDiv.className = "vis-brightness";
    this.arrowDiv = document.createElement("div");
    this.arrowDiv.className = "vis-arrow";
    this.opacityRange = document.createElement("input");
    try {
      this.opacityRange.type = "range";
      this.opacityRange.min = "0";
      this.opacityRange.max = "100";
    } catch (err) {
    }
    this.opacityRange.value = "100";
    this.opacityRange.className = "vis-range";
    this.brightnessRange = document.createElement("input");
    try {
      this.brightnessRange.type = "range";
      this.brightnessRange.min = "0";
      this.brightnessRange.max = "100";
    } catch (err) {
    }
    this.brightnessRange.value = "100";
    this.brightnessRange.className = "vis-range";
    this.opacityDiv.appendChild(this.opacityRange);
    this.brightnessDiv.appendChild(this.brightnessRange);
    const me = this;
    this.opacityRange.onchange = function() {
      me._setOpacity(this.value);
    };
    this.opacityRange.oninput = function() {
      me._setOpacity(this.value);
    };
    this.brightnessRange.onchange = function() {
      me._setBrightness(this.value);
    };
    this.brightnessRange.oninput = function() {
      me._setBrightness(this.value);
    };
    this.brightnessLabel = document.createElement("div");
    this.brightnessLabel.className = "vis-label vis-brightness";
    this.brightnessLabel.innerText = "brightness:";
    this.opacityLabel = document.createElement("div");
    this.opacityLabel.className = "vis-label vis-opacity";
    this.opacityLabel.innerText = "opacity:";
    this.newColorDiv = document.createElement("div");
    this.newColorDiv.className = "vis-new-color";
    this.newColorDiv.innerText = "new";
    this.initialColorDiv = document.createElement("div");
    this.initialColorDiv.className = "vis-initial-color";
    this.initialColorDiv.innerText = "initial";
    this.cancelButton = document.createElement("div");
    this.cancelButton.className = "vis-button vis-cancel";
    this.cancelButton.innerText = "cancel";
    this.cancelButton.onclick = _bindInstanceProperty(_context7 = this._hide).call(_context7, this, false);
    this.applyButton = document.createElement("div");
    this.applyButton.className = "vis-button vis-apply";
    this.applyButton.innerText = "apply";
    this.applyButton.onclick = _bindInstanceProperty(_context8 = this._apply).call(_context8, this);
    this.saveButton = document.createElement("div");
    this.saveButton.className = "vis-button vis-save";
    this.saveButton.innerText = "save";
    this.saveButton.onclick = _bindInstanceProperty(_context9 = this._save).call(_context9, this);
    this.loadButton = document.createElement("div");
    this.loadButton.className = "vis-button vis-load";
    this.loadButton.innerText = "load last";
    this.loadButton.onclick = _bindInstanceProperty(_context0 = this._loadLast).call(_context0, this);
    this.frame.appendChild(this.colorPickerDiv);
    this.frame.appendChild(this.arrowDiv);
    this.frame.appendChild(this.brightnessLabel);
    this.frame.appendChild(this.brightnessDiv);
    this.frame.appendChild(this.opacityLabel);
    this.frame.appendChild(this.opacityDiv);
    this.frame.appendChild(this.newColorDiv);
    this.frame.appendChild(this.initialColorDiv);
    this.frame.appendChild(this.cancelButton);
    this.frame.appendChild(this.applyButton);
    this.frame.appendChild(this.saveButton);
    this.frame.appendChild(this.loadButton);
  }
  /**
   * bind hammer to the color picker
   * @private
   */
  _bindHammer() {
    this.drag = {};
    this.pinch = {};
    this.hammer = new Hammer$1(this.colorPickerCanvas);
    this.hammer.get("pinch").set({
      enable: true
    });
    this.hammer.on("hammer.input", (event2) => {
      if (event2.isFirst) {
        this._moveSelector(event2);
      }
    });
    this.hammer.on("tap", (event2) => {
      this._moveSelector(event2);
    });
    this.hammer.on("panstart", (event2) => {
      this._moveSelector(event2);
    });
    this.hammer.on("panmove", (event2) => {
      this._moveSelector(event2);
    });
    this.hammer.on("panend", (event2) => {
      this._moveSelector(event2);
    });
  }
  /**
   * generate the hue circle. This is relatively heavy (200ms) and is done only once on the first time it is shown.
   * @private
   */
  _generateHueCircle() {
    if (this.generated === false) {
      const ctx = this.colorPickerCanvas.getContext("2d");
      if (this.pixelRation === void 0) {
        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
      }
      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
      const w = this.colorPickerCanvas.clientWidth;
      const h = this.colorPickerCanvas.clientHeight;
      ctx.clearRect(0, 0, w, h);
      let x, y, hue, sat;
      this.centerCoordinates = {
        x: w * 0.5,
        y: h * 0.5
      };
      this.r = 0.49 * w;
      const angleConvert = 2 * Math.PI / 360;
      const hfac = 1 / 360;
      const sfac = 1 / this.r;
      let rgb;
      for (hue = 0; hue < 360; hue++) {
        for (sat = 0; sat < this.r; sat++) {
          x = this.centerCoordinates.x + sat * Math.sin(angleConvert * hue);
          y = this.centerCoordinates.y + sat * Math.cos(angleConvert * hue);
          rgb = HSVToRGB(hue * hfac, sat * sfac, 1);
          ctx.fillStyle = "rgb(" + rgb.r + "," + rgb.g + "," + rgb.b + ")";
          ctx.fillRect(x - 0.5, y - 0.5, 2, 2);
        }
      }
      ctx.strokeStyle = "rgba(0,0,0,1)";
      ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
      ctx.stroke();
      this.hueCircle = ctx.getImageData(0, 0, w, h);
    }
    this.generated = true;
  }
  /**
   * move the selector. This is called by hammer functions.
   * @param {Event}  event   The event
   * @private
   */
  _moveSelector(event2) {
    const rect = this.colorPickerDiv.getBoundingClientRect();
    const left = event2.center.x - rect.left;
    const top = event2.center.y - rect.top;
    const centerY = 0.5 * this.colorPickerDiv.clientHeight;
    const centerX = 0.5 * this.colorPickerDiv.clientWidth;
    const x = left - centerX;
    const y = top - centerY;
    const angle = Math.atan2(x, y);
    const radius = 0.98 * Math.min(Math.sqrt(x * x + y * y), centerX);
    const newTop = Math.cos(angle) * radius + centerY;
    const newLeft = Math.sin(angle) * radius + centerX;
    this.colorPickerSelector.style.top = newTop - 0.5 * this.colorPickerSelector.clientHeight + "px";
    this.colorPickerSelector.style.left = newLeft - 0.5 * this.colorPickerSelector.clientWidth + "px";
    let h = angle / (2 * Math.PI);
    h = h < 0 ? h + 1 : h;
    const s = radius / this.r;
    const hsv = RGBToHSV(this.color.r, this.color.g, this.color.b);
    hsv.h = h;
    hsv.s = s;
    const rgba = HSVToRGB(hsv.h, hsv.s, hsv.v);
    rgba["a"] = this.color.a;
    this.color = rgba;
    this.initialColorDiv.style.backgroundColor = "rgba(" + this.initialColor.r + "," + this.initialColor.g + "," + this.initialColor.b + "," + this.initialColor.a + ")";
    this.newColorDiv.style.backgroundColor = "rgba(" + this.color.r + "," + this.color.g + "," + this.color.b + "," + this.color.a + ")";
  }
};
function wrapInTag() {
  for (var _len5 = arguments.length, rest = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    rest[_key5] = arguments[_key5];
  }
  if (rest.length < 1) {
    throw new TypeError("Invalid arguments.");
  } else if (rest.length === 1) {
    return document.createTextNode(rest[0]);
  } else {
    const element = document.createElement(rest[0]);
    element.appendChild(wrapInTag(..._sliceInstanceProperty(rest).call(rest, 1)));
    return element;
  }
}
var Configurator$1 = class Configurator {
  /**
   * @param {object} parentModule        | the location where parentModule.setOptions() can be called
   * @param {object} defaultContainer    | the default container of the module
   * @param {object} configureOptions    | the fully configured and predefined options set found in allOptions.js
   * @param {number} pixelRatio          | canvas pixel ratio
   * @param {Function} hideOption        | custom logic to dynamically hide options
   */
  constructor(parentModule, defaultContainer, configureOptions2) {
    let pixelRatio = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
    let hideOption = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : () => false;
    this.parent = parentModule;
    this.changedOptions = [];
    this.container = defaultContainer;
    this.allowCreation = false;
    this.hideOption = hideOption;
    this.options = {};
    this.initialized = false;
    this.popupCounter = 0;
    this.defaultOptions = {
      enabled: false,
      filter: true,
      container: void 0,
      showButton: true
    };
    _Object$assign(this.options, this.defaultOptions);
    this.configureOptions = configureOptions2;
    this.moduleOptions = {};
    this.domElements = [];
    this.popupDiv = {};
    this.popupLimit = 5;
    this.popupHistory = {};
    this.colorPicker = new ColorPicker$1(pixelRatio);
    this.wrapper = void 0;
  }
  /**
   * refresh all options.
   * Because all modules parse their options by themselves, we just use their options. We copy them here.
   * @param {object} options
   */
  setOptions(options) {
    if (options !== void 0) {
      this.popupHistory = {};
      this._removePopup();
      let enabled = true;
      if (typeof options === "string") {
        this.options.filter = options;
      } else if (_Array$isArray(options)) {
        this.options.filter = options.join();
      } else if (typeof options === "object") {
        if (options == null) {
          throw new TypeError("options cannot be null");
        }
        if (options.container !== void 0) {
          this.options.container = options.container;
        }
        if (_filterInstanceProperty(options) !== void 0) {
          this.options.filter = _filterInstanceProperty(options);
        }
        if (options.showButton !== void 0) {
          this.options.showButton = options.showButton;
        }
        if (options.enabled !== void 0) {
          enabled = options.enabled;
        }
      } else if (typeof options === "boolean") {
        this.options.filter = true;
        enabled = options;
      } else if (typeof options === "function") {
        this.options.filter = options;
        enabled = true;
      }
      if (_filterInstanceProperty(this.options) === false) {
        enabled = false;
      }
      this.options.enabled = enabled;
    }
    this._clean();
  }
  /**
   *
   * @param {object} moduleOptions
   */
  setModuleOptions(moduleOptions) {
    this.moduleOptions = moduleOptions;
    if (this.options.enabled === true) {
      this._clean();
      if (this.options.container !== void 0) {
        this.container = this.options.container;
      }
      this._create();
    }
  }
  /**
   * Create all DOM elements
   * @private
   */
  _create() {
    this._clean();
    this.changedOptions = [];
    const filter2 = _filterInstanceProperty(this.options);
    let counter = 0;
    let show = false;
    for (const option2 in this.configureOptions) {
      if (Object.prototype.hasOwnProperty.call(this.configureOptions, option2)) {
        this.allowCreation = false;
        show = false;
        if (typeof filter2 === "function") {
          show = filter2(option2, []);
          show = show || this._handleObject(this.configureOptions[option2], [option2], true);
        } else if (filter2 === true || _indexOfInstanceProperty(filter2).call(filter2, option2) !== -1) {
          show = true;
        }
        if (show !== false) {
          this.allowCreation = true;
          if (counter > 0) {
            this._makeItem([]);
          }
          this._makeHeader(option2);
          this._handleObject(this.configureOptions[option2], [option2]);
        }
        counter++;
      }
    }
    this._makeButton();
    this._push();
  }
  /**
   * draw all DOM elements on the screen
   * @private
   */
  _push() {
    this.wrapper = document.createElement("div");
    this.wrapper.className = "vis-configuration-wrapper";
    this.container.appendChild(this.wrapper);
    for (let i = 0; i < this.domElements.length; i++) {
      this.wrapper.appendChild(this.domElements[i]);
    }
    this._showPopupIfNeeded();
  }
  /**
   * delete all DOM elements
   * @private
   */
  _clean() {
    for (let i = 0; i < this.domElements.length; i++) {
      this.wrapper.removeChild(this.domElements[i]);
    }
    if (this.wrapper !== void 0) {
      this.container.removeChild(this.wrapper);
      this.wrapper = void 0;
    }
    this.domElements = [];
    this._removePopup();
  }
  /**
   * get the value from the actualOptions if it exists
   * @param {Array} path    | where to look for the actual option
   * @returns {*}
   * @private
   */
  _getValue(path2) {
    let base = this.moduleOptions;
    for (let i = 0; i < path2.length; i++) {
      if (base[path2[i]] !== void 0) {
        base = base[path2[i]];
      } else {
        base = void 0;
        break;
      }
    }
    return base;
  }
  /**
   * all option elements are wrapped in an item
   * @param {Array} path    | where to look for the actual option
   * @param {Array.<Element>} domElements
   * @returns {number}
   * @private
   */
  _makeItem(path2) {
    if (this.allowCreation === true) {
      const item = document.createElement("div");
      item.className = "vis-configuration vis-config-item vis-config-s" + path2.length;
      for (var _len6 = arguments.length, domElements = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
        domElements[_key6 - 1] = arguments[_key6];
      }
      _forEachInstanceProperty(domElements).call(domElements, (element) => {
        item.appendChild(element);
      });
      this.domElements.push(item);
      return this.domElements.length;
    }
    return 0;
  }
  /**
   * header for major subjects
   * @param {string} name
   * @private
   */
  _makeHeader(name) {
    const div = document.createElement("div");
    div.className = "vis-configuration vis-config-header";
    div.innerText = name;
    this._makeItem([], div);
  }
  /**
   * make a label, if it is an object label, it gets different styling.
   * @param {string} name
   * @param {Array} path    | where to look for the actual option
   * @param {string} objectLabel
   * @returns {HTMLElement}
   * @private
   */
  _makeLabel(name, path2) {
    let objectLabel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    const div = document.createElement("div");
    div.className = "vis-configuration vis-config-label vis-config-s" + path2.length;
    if (objectLabel === true) {
      while (div.firstChild) {
        div.removeChild(div.firstChild);
      }
      div.appendChild(wrapInTag("i", "b", name));
    } else {
      div.innerText = name + ":";
    }
    return div;
  }
  /**
   * make a dropdown list for multiple possible string optoins
   * @param {Array.<number>} arr
   * @param {number} value
   * @param {Array} path    | where to look for the actual option
   * @private
   */
  _makeDropdown(arr, value, path2) {
    const select = document.createElement("select");
    select.className = "vis-configuration vis-config-select";
    let selectedValue = 0;
    if (value !== void 0) {
      if (_indexOfInstanceProperty(arr).call(arr, value) !== -1) {
        selectedValue = _indexOfInstanceProperty(arr).call(arr, value);
      }
    }
    for (let i = 0; i < arr.length; i++) {
      const option2 = document.createElement("option");
      option2.value = arr[i];
      if (i === selectedValue) {
        option2.selected = "selected";
      }
      option2.innerText = arr[i];
      select.appendChild(option2);
    }
    const me = this;
    select.onchange = function() {
      me._update(this.value, path2);
    };
    const label = this._makeLabel(path2[path2.length - 1], path2);
    this._makeItem(path2, label, select);
  }
  /**
   * make a range object for numeric options
   * @param {Array.<number>} arr
   * @param {number} value
   * @param {Array} path    | where to look for the actual option
   * @private
   */
  _makeRange(arr, value, path2) {
    const defaultValue = arr[0];
    const min = arr[1];
    const max = arr[2];
    const step = arr[3];
    const range = document.createElement("input");
    range.className = "vis-configuration vis-config-range";
    try {
      range.type = "range";
      range.min = min;
      range.max = max;
    } catch (err) {
    }
    range.step = step;
    let popupString = "";
    let popupValue = 0;
    if (value !== void 0) {
      const factor = 1.2;
      if (value < 0 && value * factor < min) {
        range.min = Math.ceil(value * factor);
        popupValue = range.min;
        popupString = "range increased";
      } else if (value / factor < min) {
        range.min = Math.ceil(value / factor);
        popupValue = range.min;
        popupString = "range increased";
      }
      if (value * factor > max && max !== 1) {
        range.max = Math.ceil(value * factor);
        popupValue = range.max;
        popupString = "range increased";
      }
      range.value = value;
    } else {
      range.value = defaultValue;
    }
    const input = document.createElement("input");
    input.className = "vis-configuration vis-config-rangeinput";
    input.value = range.value;
    const me = this;
    range.onchange = function() {
      input.value = this.value;
      me._update(Number(this.value), path2);
    };
    range.oninput = function() {
      input.value = this.value;
    };
    const label = this._makeLabel(path2[path2.length - 1], path2);
    const itemIndex = this._makeItem(path2, label, range, input);
    if (popupString !== "" && this.popupHistory[itemIndex] !== popupValue) {
      this.popupHistory[itemIndex] = popupValue;
      this._setupPopup(popupString, itemIndex);
    }
  }
  /**
   * make a button object
   * @private
   */
  _makeButton() {
    if (this.options.showButton === true) {
      const generateButton = document.createElement("div");
      generateButton.className = "vis-configuration vis-config-button";
      generateButton.innerText = "generate options";
      generateButton.onclick = () => {
        this._printOptions();
      };
      generateButton.onmouseover = () => {
        generateButton.className = "vis-configuration vis-config-button hover";
      };
      generateButton.onmouseout = () => {
        generateButton.className = "vis-configuration vis-config-button";
      };
      this.optionsContainer = document.createElement("div");
      this.optionsContainer.className = "vis-configuration vis-config-option-container";
      this.domElements.push(this.optionsContainer);
      this.domElements.push(generateButton);
    }
  }
  /**
   * prepare the popup
   * @param {string} string
   * @param {number} index
   * @private
   */
  _setupPopup(string2, index) {
    if (this.initialized === true && this.allowCreation === true && this.popupCounter < this.popupLimit) {
      const div = document.createElement("div");
      div.id = "vis-configuration-popup";
      div.className = "vis-configuration-popup";
      div.innerText = string2;
      div.onclick = () => {
        this._removePopup();
      };
      this.popupCounter += 1;
      this.popupDiv = {
        html: div,
        index
      };
    }
  }
  /**
   * remove the popup from the dom
   * @private
   */
  _removePopup() {
    if (this.popupDiv.html !== void 0) {
      this.popupDiv.html.parentNode.removeChild(this.popupDiv.html);
      clearTimeout(this.popupDiv.hideTimeout);
      clearTimeout(this.popupDiv.deleteTimeout);
      this.popupDiv = {};
    }
  }
  /**
   * Show the popup if it is needed.
   * @private
   */
  _showPopupIfNeeded() {
    if (this.popupDiv.html !== void 0) {
      const correspondingElement = this.domElements[this.popupDiv.index];
      const rect = correspondingElement.getBoundingClientRect();
      this.popupDiv.html.style.left = rect.left + "px";
      this.popupDiv.html.style.top = rect.top - 30 + "px";
      document.body.appendChild(this.popupDiv.html);
      this.popupDiv.hideTimeout = _setTimeout(() => {
        this.popupDiv.html.style.opacity = 0;
      }, 1500);
      this.popupDiv.deleteTimeout = _setTimeout(() => {
        this._removePopup();
      }, 1800);
    }
  }
  /**
   * make a checkbox for boolean options.
   * @param {number} defaultValue
   * @param {number} value
   * @param {Array} path    | where to look for the actual option
   * @private
   */
  _makeCheckbox(defaultValue, value, path2) {
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.className = "vis-configuration vis-config-checkbox";
    checkbox.checked = defaultValue;
    if (value !== void 0) {
      checkbox.checked = value;
      if (value !== defaultValue) {
        if (typeof defaultValue === "object") {
          if (value !== defaultValue.enabled) {
            this.changedOptions.push({
              path: path2,
              value
            });
          }
        } else {
          this.changedOptions.push({
            path: path2,
            value
          });
        }
      }
    }
    const me = this;
    checkbox.onchange = function() {
      me._update(this.checked, path2);
    };
    const label = this._makeLabel(path2[path2.length - 1], path2);
    this._makeItem(path2, label, checkbox);
  }
  /**
   * make a text input field for string options.
   * @param {number} defaultValue
   * @param {number} value
   * @param {Array} path    | where to look for the actual option
   * @private
   */
  _makeTextInput(defaultValue, value, path2) {
    const checkbox = document.createElement("input");
    checkbox.type = "text";
    checkbox.className = "vis-configuration vis-config-text";
    checkbox.value = value;
    if (value !== defaultValue) {
      this.changedOptions.push({
        path: path2,
        value
      });
    }
    const me = this;
    checkbox.onchange = function() {
      me._update(this.value, path2);
    };
    const label = this._makeLabel(path2[path2.length - 1], path2);
    this._makeItem(path2, label, checkbox);
  }
  /**
   * make a color field with a color picker for color fields
   * @param {Array.<number>} arr
   * @param {number} value
   * @param {Array} path    | where to look for the actual option
   * @private
   */
  _makeColorField(arr, value, path2) {
    const defaultColor = arr[1];
    const div = document.createElement("div");
    value = value === void 0 ? defaultColor : value;
    if (value !== "none") {
      div.className = "vis-configuration vis-config-colorBlock";
      div.style.backgroundColor = value;
    } else {
      div.className = "vis-configuration vis-config-colorBlock none";
    }
    value = value === void 0 ? defaultColor : value;
    div.onclick = () => {
      this._showColorPicker(value, div, path2);
    };
    const label = this._makeLabel(path2[path2.length - 1], path2);
    this._makeItem(path2, label, div);
  }
  /**
   * used by the color buttons to call the color picker.
   * @param {number} value
   * @param {HTMLElement} div
   * @param {Array} path    | where to look for the actual option
   * @private
   */
  _showColorPicker(value, div, path2) {
    div.onclick = function() {
    };
    this.colorPicker.insertTo(div);
    this.colorPicker.show();
    this.colorPicker.setColor(value);
    this.colorPicker.setUpdateCallback((color) => {
      const colorString = "rgba(" + color.r + "," + color.g + "," + color.b + "," + color.a + ")";
      div.style.backgroundColor = colorString;
      this._update(colorString, path2);
    });
    this.colorPicker.setCloseCallback(() => {
      div.onclick = () => {
        this._showColorPicker(value, div, path2);
      };
    });
  }
  /**
   * parse an object and draw the correct items
   * @param {object} obj
   * @param {Array} [path]    | where to look for the actual option
   * @param {boolean} [checkOnly]
   * @returns {boolean}
   * @private
   */
  _handleObject(obj) {
    let path2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    let checkOnly = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    let show = false;
    const filter2 = _filterInstanceProperty(this.options);
    let visibleInSet = false;
    for (const subObj in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, subObj)) {
        show = true;
        const item = obj[subObj];
        const newPath = copyAndExtendArray(path2, subObj);
        if (typeof filter2 === "function") {
          show = filter2(subObj, path2);
          if (show === false) {
            if (!_Array$isArray(item) && typeof item !== "string" && typeof item !== "boolean" && item instanceof Object) {
              this.allowCreation = false;
              show = this._handleObject(item, newPath, true);
              this.allowCreation = checkOnly === false;
            }
          }
        }
        if (show !== false) {
          visibleInSet = true;
          const value = this._getValue(newPath);
          if (_Array$isArray(item)) {
            this._handleArray(item, value, newPath);
          } else if (typeof item === "string") {
            this._makeTextInput(item, value, newPath);
          } else if (typeof item === "boolean") {
            this._makeCheckbox(item, value, newPath);
          } else if (item instanceof Object) {
            if (!this.hideOption(path2, subObj, this.moduleOptions)) {
              if (item.enabled !== void 0) {
                const enabledPath = copyAndExtendArray(newPath, "enabled");
                const enabledValue = this._getValue(enabledPath);
                if (enabledValue === true) {
                  const label = this._makeLabel(subObj, newPath, true);
                  this._makeItem(newPath, label);
                  visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                } else {
                  this._makeCheckbox(item, enabledValue, newPath);
                }
              } else {
                const label = this._makeLabel(subObj, newPath, true);
                this._makeItem(newPath, label);
                visibleInSet = this._handleObject(item, newPath) || visibleInSet;
              }
            }
          } else {
            console.error("dont know how to handle", item, subObj, newPath);
          }
        }
      }
    }
    return visibleInSet;
  }
  /**
   * handle the array type of option
   * @param {Array.<number>} arr
   * @param {number} value
   * @param {Array} path    | where to look for the actual option
   * @private
   */
  _handleArray(arr, value, path2) {
    if (typeof arr[0] === "string" && arr[0] === "color") {
      this._makeColorField(arr, value, path2);
      if (arr[1] !== value) {
        this.changedOptions.push({
          path: path2,
          value
        });
      }
    } else if (typeof arr[0] === "string") {
      this._makeDropdown(arr, value, path2);
      if (arr[0] !== value) {
        this.changedOptions.push({
          path: path2,
          value
        });
      }
    } else if (typeof arr[0] === "number") {
      this._makeRange(arr, value, path2);
      if (arr[0] !== value) {
        this.changedOptions.push({
          path: path2,
          value: Number(value)
        });
      }
    }
  }
  /**
   * called to update the network with the new settings.
   * @param {number} value
   * @param {Array} path    | where to look for the actual option
   * @private
   */
  _update(value, path2) {
    const options = this._constructOptions(value, path2);
    if (this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit) {
      this.parent.body.emitter.emit("configChange", options);
    }
    this.initialized = true;
    this.parent.setOptions(options);
  }
  /**
   *
   * @param {string | boolean} value
   * @param {Array.<string>} path
   * @param {{}} optionsObj
   * @returns {{}}
   * @private
   */
  _constructOptions(value, path2) {
    let optionsObj = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let pointer = optionsObj;
    value = value === "true" ? true : value;
    value = value === "false" ? false : value;
    for (let i = 0; i < path2.length; i++) {
      if (path2[i] !== "global") {
        if (pointer[path2[i]] === void 0) {
          pointer[path2[i]] = {};
        }
        if (i !== path2.length - 1) {
          pointer = pointer[path2[i]];
        } else {
          pointer[path2[i]] = value;
        }
      }
    }
    return optionsObj;
  }
  /**
   * @private
   */
  _printOptions() {
    const options = this.getOptions();
    while (this.optionsContainer.firstChild) {
      this.optionsContainer.removeChild(this.optionsContainer.firstChild);
    }
    this.optionsContainer.appendChild(wrapInTag("pre", "const options = " + _JSON$stringify(options, null, 2)));
  }
  /**
   *
   * @returns {{}} options
   */
  getOptions() {
    const options = {};
    for (let i = 0; i < this.changedOptions.length; i++) {
      this._constructOptions(this.changedOptions[i].value, this.changedOptions[i].path, options);
    }
    return options;
  }
};
var Popup$1 = class Popup {
  /**
   * @param {Element} container       The container object.
   * @param {string}  overflowMethod  How the popup should act to overflowing ('flip' or 'cap')
   */
  constructor(container, overflowMethod) {
    this.container = container;
    this.overflowMethod = overflowMethod || "cap";
    this.x = 0;
    this.y = 0;
    this.padding = 5;
    this.hidden = false;
    this.frame = document.createElement("div");
    this.frame.className = "vis-tooltip";
    this.container.appendChild(this.frame);
  }
  /**
   * @param {number} x   Horizontal position of the popup window
   * @param {number} y   Vertical position of the popup window
   */
  setPosition(x, y) {
    this.x = _parseInt(x);
    this.y = _parseInt(y);
  }
  /**
   * Set the content for the popup window. This can be HTML code or text.
   * @param {string | Element} content
   */
  setText(content) {
    if (content instanceof Element) {
      while (this.frame.firstChild) {
        this.frame.removeChild(this.frame.firstChild);
      }
      this.frame.appendChild(content);
    } else {
      this.frame.innerText = content;
    }
  }
  /**
   * Show the popup window
   * @param {boolean} [doShow]    Show or hide the window
   */
  show(doShow) {
    if (doShow === void 0) {
      doShow = true;
    }
    if (doShow === true) {
      const height = this.frame.clientHeight;
      const width = this.frame.clientWidth;
      const maxHeight = this.frame.parentNode.clientHeight;
      const maxWidth = this.frame.parentNode.clientWidth;
      let left = 0, top = 0;
      if (this.overflowMethod == "flip") {
        let isLeft = false, isTop = true;
        if (this.y - height < this.padding) {
          isTop = false;
        }
        if (this.x + width > maxWidth - this.padding) {
          isLeft = true;
        }
        if (isLeft) {
          left = this.x - width;
        } else {
          left = this.x;
        }
        if (isTop) {
          top = this.y - height;
        } else {
          top = this.y;
        }
      } else {
        top = this.y - height;
        if (top + height + this.padding > maxHeight) {
          top = maxHeight - height - this.padding;
        }
        if (top < this.padding) {
          top = this.padding;
        }
        left = this.x;
        if (left + width + this.padding > maxWidth) {
          left = maxWidth - width - this.padding;
        }
        if (left < this.padding) {
          left = this.padding;
        }
      }
      this.frame.style.left = left + "px";
      this.frame.style.top = top + "px";
      this.frame.style.visibility = "visible";
      this.hidden = false;
    } else {
      this.hide();
    }
  }
  /**
   * Hide the popup window
   */
  hide() {
    this.hidden = true;
    this.frame.style.left = "0";
    this.frame.style.top = "0";
    this.frame.style.visibility = "hidden";
  }
  /**
   * Remove the popup window
   */
  destroy() {
    this.frame.parentNode.removeChild(this.frame);
  }
};
var errorFound$1 = false;
var allOptions$3;
var VALIDATOR_PRINT_STYLE$1 = "background: #FFeeee; color: #dd0000";
var Validator$1 = class Validator {
  /**
   * Main function to be called
   * @param {object} options
   * @param {object} referenceOptions
   * @param {object} subObject
   * @returns {boolean}
   * @static
   */
  static validate(options, referenceOptions, subObject) {
    errorFound$1 = false;
    allOptions$3 = referenceOptions;
    let usedOptions = referenceOptions;
    if (subObject !== void 0) {
      usedOptions = referenceOptions[subObject];
    }
    Validator.parse(options, usedOptions, []);
    return errorFound$1;
  }
  /**
   * Will traverse an object recursively and check every value
   * @param {object} options
   * @param {object} referenceOptions
   * @param {Array} path    | where to look for the actual option
   * @static
   */
  static parse(options, referenceOptions, path2) {
    for (const option2 in options) {
      if (Object.prototype.hasOwnProperty.call(options, option2)) {
        Validator.check(option2, options, referenceOptions, path2);
      }
    }
  }
  /**
   * Check every value. If the value is an object, call the parse function on that object.
   * @param {string} option
   * @param {object} options
   * @param {object} referenceOptions
   * @param {Array} path    | where to look for the actual option
   * @static
   */
  static check(option2, options, referenceOptions, path2) {
    if (referenceOptions[option2] === void 0 && referenceOptions.__any__ === void 0) {
      Validator.getSuggestion(option2, referenceOptions, path2);
      return;
    }
    let referenceOption = option2;
    let is_object = true;
    if (referenceOptions[option2] === void 0 && referenceOptions.__any__ !== void 0) {
      referenceOption = "__any__";
      is_object = Validator.getType(options[option2]) === "object";
    }
    let refOptionObj = referenceOptions[referenceOption];
    if (is_object && refOptionObj.__type__ !== void 0) {
      refOptionObj = refOptionObj.__type__;
    }
    Validator.checkFields(option2, options, referenceOptions, referenceOption, refOptionObj, path2);
  }
  /**
   *
   * @param {string}  option           | the option property
   * @param {object}  options          | The supplied options object
   * @param {object}  referenceOptions | The reference options containing all options and their allowed formats
   * @param {string}  referenceOption  | Usually this is the same as option, except when handling an __any__ tag.
   * @param {string}  refOptionObj     | This is the type object from the reference options
   * @param {Array}   path             | where in the object is the option
   * @static
   */
  static checkFields(option2, options, referenceOptions, referenceOption, refOptionObj, path2) {
    const log = function(message) {
      console.error("%c" + message + Validator.printLocation(path2, option2), VALIDATOR_PRINT_STYLE$1);
    };
    const optionType = Validator.getType(options[option2]);
    const refOptionType = refOptionObj[optionType];
    if (refOptionType !== void 0) {
      if (Validator.getType(refOptionType) === "array" && _indexOfInstanceProperty(refOptionType).call(refOptionType, options[option2]) === -1) {
        log('Invalid option detected in "' + option2 + '". Allowed values are:' + Validator.print(refOptionType) + ' not "' + options[option2] + '". ');
        errorFound$1 = true;
      } else if (optionType === "object" && referenceOption !== "__any__") {
        path2 = copyAndExtendArray(path2, option2);
        Validator.parse(options[option2], referenceOptions[referenceOption], path2);
      }
    } else if (refOptionObj["any"] === void 0) {
      log('Invalid type received for "' + option2 + '". Expected: ' + Validator.print(_Object$keys(refOptionObj)) + ". Received [" + optionType + '] "' + options[option2] + '"');
      errorFound$1 = true;
    }
  }
  /**
   *
   * @param {object | boolean | number | string | Array.<number> | Date | Node | Moment | undefined | null} object
   * @returns {string}
   * @static
   */
  static getType(object2) {
    const type = typeof object2;
    if (type === "object") {
      if (object2 === null) {
        return "null";
      }
      if (object2 instanceof Boolean) {
        return "boolean";
      }
      if (object2 instanceof Number) {
        return "number";
      }
      if (object2 instanceof String) {
        return "string";
      }
      if (_Array$isArray(object2)) {
        return "array";
      }
      if (object2 instanceof Date) {
        return "date";
      }
      if (object2.nodeType !== void 0) {
        return "dom";
      }
      if (object2._isAMomentObject === true) {
        return "moment";
      }
      return "object";
    } else if (type === "number") {
      return "number";
    } else if (type === "boolean") {
      return "boolean";
    } else if (type === "string") {
      return "string";
    } else if (type === void 0) {
      return "undefined";
    }
    return type;
  }
  /**
   * @param {string} option
   * @param {object} options
   * @param {Array.<string>} path
   * @static
   */
  static getSuggestion(option2, options, path2) {
    const localSearch = Validator.findInOptions(option2, options, path2, false);
    const globalSearch = Validator.findInOptions(option2, allOptions$3, [], true);
    const localSearchThreshold = 8;
    const globalSearchThreshold = 4;
    let msg;
    if (localSearch.indexMatch !== void 0) {
      msg = " in " + Validator.printLocation(localSearch.path, option2, "") + 'Perhaps it was incomplete? Did you mean: "' + localSearch.indexMatch + '"?\n\n';
    } else if (globalSearch.distance <= globalSearchThreshold && localSearch.distance > globalSearch.distance) {
      msg = " in " + Validator.printLocation(localSearch.path, option2, "") + "Perhaps it was misplaced? Matching option found at: " + Validator.printLocation(globalSearch.path, globalSearch.closestMatch, "");
    } else if (localSearch.distance <= localSearchThreshold) {
      msg = '. Did you mean "' + localSearch.closestMatch + '"?' + Validator.printLocation(localSearch.path, option2);
    } else {
      msg = ". Did you mean one of these: " + Validator.print(_Object$keys(options)) + Validator.printLocation(path2, option2);
    }
    console.error('%cUnknown option detected: "' + option2 + '"' + msg, VALIDATOR_PRINT_STYLE$1);
    errorFound$1 = true;
  }
  /**
   * traverse the options in search for a match.
   * @param {string} option
   * @param {object} options
   * @param {Array} path    | where to look for the actual option
   * @param {boolean} [recursive]
   * @returns {{closestMatch: string, path: Array, distance: number}}
   * @static
   */
  static findInOptions(option2, options, path2) {
    let recursive = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    let min = 1e9;
    let closestMatch = "";
    let closestMatchPath = [];
    const lowerCaseOption = option2.toLowerCase();
    let indexMatch = void 0;
    for (const op in options) {
      let distance;
      if (options[op].__type__ !== void 0 && recursive === true) {
        const result = Validator.findInOptions(option2, options[op], copyAndExtendArray(path2, op));
        if (min > result.distance) {
          closestMatch = result.closestMatch;
          closestMatchPath = result.path;
          min = result.distance;
          indexMatch = result.indexMatch;
        }
      } else {
        var _context1;
        if (_indexOfInstanceProperty(_context1 = op.toLowerCase()).call(_context1, lowerCaseOption) !== -1) {
          indexMatch = op;
        }
        distance = Validator.levenshteinDistance(option2, op);
        if (min > distance) {
          closestMatch = op;
          closestMatchPath = copyArray(path2);
          min = distance;
        }
      }
    }
    return {
      closestMatch,
      path: closestMatchPath,
      distance: min,
      indexMatch
    };
  }
  /**
   * @param {Array.<string>} path
   * @param {object} option
   * @param {string} prefix
   * @returns {string}
   * @static
   */
  static printLocation(path2, option2) {
    let prefix = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "Problem value found at: \n";
    let str = "\n\n" + prefix + "options = {\n";
    for (let i = 0; i < path2.length; i++) {
      for (let j = 0; j < i + 1; j++) {
        str += "  ";
      }
      str += path2[i] + ": {\n";
    }
    for (let j = 0; j < path2.length + 1; j++) {
      str += "  ";
    }
    str += option2 + "\n";
    for (let i = 0; i < path2.length + 1; i++) {
      for (let j = 0; j < path2.length - i; j++) {
        str += "  ";
      }
      str += "}\n";
    }
    return str + "\n\n";
  }
  /**
   * @param {object} options
   * @returns {string}
   * @static
   */
  static print(options) {
    return _JSON$stringify(options).replace(/(")|(\[)|(\])|(,"__type__")/g, "").replace(/(,)/g, ", ");
  }
  /**
   *  Compute the edit distance between the two given strings
   *  http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript
   *
   *  Copyright (c) 2011 Andrei Mackenzie
   *
   *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
   *
   *  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
   *
   *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   * @param {string} a
   * @param {string} b
   * @returns {Array.<Array.<number>>}}
   * @static
   */
  static levenshteinDistance(a, b) {
    if (a.length === 0) return b.length;
    if (b.length === 0) return a.length;
    const matrix = [];
    let i;
    for (i = 0; i <= b.length; i++) {
      matrix[i] = [i];
    }
    let j;
    for (j = 0; j <= a.length; j++) {
      matrix[0][j] = j;
    }
    for (i = 1; i <= b.length; i++) {
      for (j = 1; j <= a.length; j++) {
        if (b.charAt(i - 1) == a.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            // substitution
            Math.min(
              matrix[i][j - 1] + 1,
              // insertion
              matrix[i - 1][j] + 1
            )
          );
        }
      }
    }
    return matrix[b.length][a.length];
  }
};
var Activator$2 = Activator$1;
var ColorPicker$2 = ColorPicker$1;
var Configurator$2 = Configurator$1;
var Hammer$2 = Hammer$1;
var Popup$2 = Popup$1;
var VALIDATOR_PRINT_STYLE = VALIDATOR_PRINT_STYLE$1;
var Validator$2 = Validator$1;
var util$2 = Object.freeze({
  __proto__: null,
  Activator: Activator$2,
  Alea,
  ColorPicker: ColorPicker$2,
  Configurator: Configurator$2,
  DELETE,
  HSVToHex,
  HSVToRGB,
  Hammer: Hammer$2,
  Popup: Popup$2,
  RGBToHSV,
  RGBToHex,
  VALIDATOR_PRINT_STYLE,
  Validator: Validator$2,
  addClassName,
  addCssText,
  binarySearchCustom,
  binarySearchValue,
  bridgeObject,
  copyAndExtendArray,
  copyArray,
  deepExtend,
  deepObjectAssign,
  easingFunctions,
  equalArray,
  extend,
  fillIfDefined,
  forEach,
  getAbsoluteLeft,
  getAbsoluteRight,
  getAbsoluteTop,
  getScrollBarWidth,
  getTarget,
  getType,
  hasParent,
  hexToHSV,
  hexToRGB,
  insertSort,
  isDate,
  isNumber,
  isObject,
  isString,
  isValidHex,
  isValidRGB,
  isValidRGBA,
  mergeOptions,
  option,
  overrideOpacity,
  parseColor,
  preventDefault,
  pureDeepObjectAssign,
  recursiveDOMDelete,
  removeClassName,
  removeCssText,
  selectiveBridgeObject,
  selectiveDeepExtend,
  selectiveExtend,
  selectiveNotDeepExtend,
  throttle,
  toArray,
  topMost,
  updateProperty
});
function prepareElements(JSONcontainer) {
  for (var elementType in JSONcontainer) {
    if (!Object.prototype.hasOwnProperty.call(JSONcontainer, elementType)) continue;
    JSONcontainer[elementType].redundant = JSONcontainer[elementType].used;
    JSONcontainer[elementType].used = [];
  }
}
function cleanupElements(JSONcontainer) {
  for (var elementType in JSONcontainer) {
    if (!Object.prototype.hasOwnProperty.call(JSONcontainer, elementType)) continue;
    const elementTypeJsonContainer = JSONcontainer[elementType];
    for (var i = 0; i < elementTypeJsonContainer.redundant.length; i++) {
      elementTypeJsonContainer.redundant[i].parentNode.removeChild(elementTypeJsonContainer.redundant[i]);
    }
    elementTypeJsonContainer.redundant = [];
  }
}
function resetElements(JSONcontainer) {
  prepareElements(JSONcontainer);
  cleanupElements(JSONcontainer);
  prepareElements(JSONcontainer);
}
function getSVGElement(elementType, JSONcontainer, svgContainer) {
  var element;
  if (Object.prototype.hasOwnProperty.call(JSONcontainer, elementType)) {
    if (JSONcontainer[elementType].redundant.length > 0) {
      element = JSONcontainer[elementType].redundant[0];
      JSONcontainer[elementType].redundant.shift();
    } else {
      element = document.createElementNS("http://www.w3.org/2000/svg", elementType);
      svgContainer.appendChild(element);
    }
  } else {
    element = document.createElementNS("http://www.w3.org/2000/svg", elementType);
    JSONcontainer[elementType] = {
      used: [],
      redundant: []
    };
    svgContainer.appendChild(element);
  }
  JSONcontainer[elementType].used.push(element);
  return element;
}
function getDOMElement(elementType, JSONcontainer, DOMContainer, insertBefore) {
  var element;
  if (Object.prototype.hasOwnProperty.call(JSONcontainer, elementType)) {
    if (JSONcontainer[elementType].redundant.length > 0) {
      element = JSONcontainer[elementType].redundant[0];
      JSONcontainer[elementType].redundant.shift();
    } else {
      element = document.createElement(elementType);
      if (insertBefore !== void 0) {
        DOMContainer.insertBefore(element, insertBefore);
      } else {
        DOMContainer.appendChild(element);
      }
    }
  } else {
    element = document.createElement(elementType);
    JSONcontainer[elementType] = {
      used: [],
      redundant: []
    };
    if (insertBefore !== void 0) {
      DOMContainer.insertBefore(element, insertBefore);
    } else {
      DOMContainer.appendChild(element);
    }
  }
  JSONcontainer[elementType].used.push(element);
  return element;
}
function drawPoint(x, y, groupTemplate, JSONcontainer, svgContainer, labelObj) {
  var point;
  if (groupTemplate.style == "circle") {
    point = getSVGElement("circle", JSONcontainer, svgContainer);
    point.setAttributeNS(null, "cx", x);
    point.setAttributeNS(null, "cy", y);
    point.setAttributeNS(null, "r", 0.5 * groupTemplate.size);
  } else {
    point = getSVGElement("rect", JSONcontainer, svgContainer);
    point.setAttributeNS(null, "x", x - 0.5 * groupTemplate.size);
    point.setAttributeNS(null, "y", y - 0.5 * groupTemplate.size);
    point.setAttributeNS(null, "width", groupTemplate.size);
    point.setAttributeNS(null, "height", groupTemplate.size);
  }
  if (groupTemplate.styles !== void 0) {
    point.setAttributeNS(null, "style", groupTemplate.styles);
  }
  point.setAttributeNS(null, "class", groupTemplate.className + " vis-point");
  if (labelObj) {
    var label = getSVGElement("text", JSONcontainer, svgContainer);
    if (labelObj.xOffset) {
      x = x + labelObj.xOffset;
    }
    if (labelObj.yOffset) {
      y = y + labelObj.yOffset;
    }
    if (labelObj.content) {
      label.textContent = labelObj.content;
    }
    if (labelObj.className) {
      label.setAttributeNS(null, "class", labelObj.className + " vis-label");
    }
    label.setAttributeNS(null, "x", x);
    label.setAttributeNS(null, "y", y);
  }
  return point;
}
function drawBar(x, y, width, height, className, JSONcontainer, svgContainer, style) {
  if (height != 0) {
    if (height < 0) {
      height *= -1;
      y -= height;
    }
    var rect = getSVGElement("rect", JSONcontainer, svgContainer);
    rect.setAttributeNS(null, "x", x - 0.5 * width);
    rect.setAttributeNS(null, "y", y);
    rect.setAttributeNS(null, "width", width);
    rect.setAttributeNS(null, "height", height);
    rect.setAttributeNS(null, "class", className);
    if (style) {
      rect.setAttributeNS(null, "style", style);
    }
  }
}
function getNavigatorLanguage() {
  try {
    if (!navigator) return "en";
    if (navigator.languages && navigator.languages.length) {
      return navigator.languages;
    } else {
      return navigator.userLanguage || navigator.language || navigator.browserLanguage || "en";
    }
  } catch (error) {
    return "en";
  }
}
var DOMutil = Object.freeze({
  __proto__: null,
  cleanupElements,
  drawBar,
  drawPoint,
  getDOMElement,
  getNavigatorLanguage,
  getSVGElement,
  prepareElements,
  resetElements
});
var getOwnPropertySymbols$2;
var hasRequiredGetOwnPropertySymbols$2;
function requireGetOwnPropertySymbols$2() {
  if (hasRequiredGetOwnPropertySymbols$2) return getOwnPropertySymbols$2;
  hasRequiredGetOwnPropertySymbols$2 = 1;
  requireEs_symbol();
  var path2 = requirePath();
  getOwnPropertySymbols$2 = path2.Object.getOwnPropertySymbols;
  return getOwnPropertySymbols$2;
}
var getOwnPropertySymbols$1;
var hasRequiredGetOwnPropertySymbols$1;
function requireGetOwnPropertySymbols$1() {
  if (hasRequiredGetOwnPropertySymbols$1) return getOwnPropertySymbols$1;
  hasRequiredGetOwnPropertySymbols$1 = 1;
  var parent = requireGetOwnPropertySymbols$2();
  getOwnPropertySymbols$1 = parent;
  return getOwnPropertySymbols$1;
}
var getOwnPropertySymbols;
var hasRequiredGetOwnPropertySymbols;
function requireGetOwnPropertySymbols() {
  if (hasRequiredGetOwnPropertySymbols) return getOwnPropertySymbols;
  hasRequiredGetOwnPropertySymbols = 1;
  getOwnPropertySymbols = requireGetOwnPropertySymbols$1();
  return getOwnPropertySymbols;
}
var getOwnPropertySymbolsExports = requireGetOwnPropertySymbols();
var _Object$getOwnPropertySymbols = getDefaultExportFromCjs(getOwnPropertySymbolsExports);
var getOwnPropertyDescriptor$2 = { exports: {} };
var es_object_getOwnPropertyDescriptor = {};
var hasRequiredEs_object_getOwnPropertyDescriptor;
function requireEs_object_getOwnPropertyDescriptor() {
  if (hasRequiredEs_object_getOwnPropertyDescriptor) return es_object_getOwnPropertyDescriptor;
  hasRequiredEs_object_getOwnPropertyDescriptor = 1;
  var $ = require_export();
  var fails2 = requireFails();
  var toIndexedObject2 = requireToIndexedObject();
  var nativeGetOwnPropertyDescriptor = requireObjectGetOwnPropertyDescriptor().f;
  var DESCRIPTORS = requireDescriptors();
  var FORCED = !DESCRIPTORS || fails2(function() {
    nativeGetOwnPropertyDescriptor(1);
  });
  $({ target: "Object", stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
    getOwnPropertyDescriptor: function getOwnPropertyDescriptor2(it2, key) {
      return nativeGetOwnPropertyDescriptor(toIndexedObject2(it2), key);
    }
  });
  return es_object_getOwnPropertyDescriptor;
}
var hasRequiredGetOwnPropertyDescriptor$2;
function requireGetOwnPropertyDescriptor$2() {
  if (hasRequiredGetOwnPropertyDescriptor$2) return getOwnPropertyDescriptor$2.exports;
  hasRequiredGetOwnPropertyDescriptor$2 = 1;
  requireEs_object_getOwnPropertyDescriptor();
  var path2 = requirePath();
  var Object2 = path2.Object;
  var getOwnPropertyDescriptor2 = getOwnPropertyDescriptor$2.exports = function getOwnPropertyDescriptor3(it2, key) {
    return Object2.getOwnPropertyDescriptor(it2, key);
  };
  if (Object2.getOwnPropertyDescriptor.sham) getOwnPropertyDescriptor2.sham = true;
  return getOwnPropertyDescriptor$2.exports;
}
var getOwnPropertyDescriptor$1;
var hasRequiredGetOwnPropertyDescriptor$1;
function requireGetOwnPropertyDescriptor$1() {
  if (hasRequiredGetOwnPropertyDescriptor$1) return getOwnPropertyDescriptor$1;
  hasRequiredGetOwnPropertyDescriptor$1 = 1;
  var parent = requireGetOwnPropertyDescriptor$2();
  getOwnPropertyDescriptor$1 = parent;
  return getOwnPropertyDescriptor$1;
}
var getOwnPropertyDescriptor;
var hasRequiredGetOwnPropertyDescriptor;
function requireGetOwnPropertyDescriptor() {
  if (hasRequiredGetOwnPropertyDescriptor) return getOwnPropertyDescriptor;
  hasRequiredGetOwnPropertyDescriptor = 1;
  getOwnPropertyDescriptor = requireGetOwnPropertyDescriptor$1();
  return getOwnPropertyDescriptor;
}
var getOwnPropertyDescriptorExports = requireGetOwnPropertyDescriptor();
var _Object$getOwnPropertyDescriptor = getDefaultExportFromCjs(getOwnPropertyDescriptorExports);
var es_object_getOwnPropertyDescriptors = {};
var hasRequiredEs_object_getOwnPropertyDescriptors;
function requireEs_object_getOwnPropertyDescriptors() {
  if (hasRequiredEs_object_getOwnPropertyDescriptors) return es_object_getOwnPropertyDescriptors;
  hasRequiredEs_object_getOwnPropertyDescriptors = 1;
  var $ = require_export();
  var DESCRIPTORS = requireDescriptors();
  var ownKeys2 = requireOwnKeys$3();
  var toIndexedObject2 = requireToIndexedObject();
  var getOwnPropertyDescriptorModule = requireObjectGetOwnPropertyDescriptor();
  var createProperty2 = requireCreateProperty();
  $({ target: "Object", stat: true, sham: !DESCRIPTORS }, {
    getOwnPropertyDescriptors: function getOwnPropertyDescriptors2(object2) {
      var O = toIndexedObject2(object2);
      var getOwnPropertyDescriptor2 = getOwnPropertyDescriptorModule.f;
      var keys2 = ownKeys2(O);
      var result = {};
      var index = 0;
      var key, descriptor;
      while (keys2.length > index) {
        descriptor = getOwnPropertyDescriptor2(O, key = keys2[index++]);
        if (descriptor !== void 0) createProperty2(result, key, descriptor);
      }
      return result;
    }
  });
  return es_object_getOwnPropertyDescriptors;
}
var getOwnPropertyDescriptors$2;
var hasRequiredGetOwnPropertyDescriptors$2;
function requireGetOwnPropertyDescriptors$2() {
  if (hasRequiredGetOwnPropertyDescriptors$2) return getOwnPropertyDescriptors$2;
  hasRequiredGetOwnPropertyDescriptors$2 = 1;
  requireEs_object_getOwnPropertyDescriptors();
  var path2 = requirePath();
  getOwnPropertyDescriptors$2 = path2.Object.getOwnPropertyDescriptors;
  return getOwnPropertyDescriptors$2;
}
var getOwnPropertyDescriptors$1;
var hasRequiredGetOwnPropertyDescriptors$1;
function requireGetOwnPropertyDescriptors$1() {
  if (hasRequiredGetOwnPropertyDescriptors$1) return getOwnPropertyDescriptors$1;
  hasRequiredGetOwnPropertyDescriptors$1 = 1;
  var parent = requireGetOwnPropertyDescriptors$2();
  getOwnPropertyDescriptors$1 = parent;
  return getOwnPropertyDescriptors$1;
}
var getOwnPropertyDescriptors;
var hasRequiredGetOwnPropertyDescriptors;
function requireGetOwnPropertyDescriptors() {
  if (hasRequiredGetOwnPropertyDescriptors) return getOwnPropertyDescriptors;
  hasRequiredGetOwnPropertyDescriptors = 1;
  getOwnPropertyDescriptors = requireGetOwnPropertyDescriptors$1();
  return getOwnPropertyDescriptors;
}
var getOwnPropertyDescriptorsExports = requireGetOwnPropertyDescriptors();
var _Object$getOwnPropertyDescriptors = getDefaultExportFromCjs(getOwnPropertyDescriptorsExports);
var defineProperties$2 = { exports: {} };
var es_object_defineProperties = {};
var hasRequiredEs_object_defineProperties;
function requireEs_object_defineProperties() {
  if (hasRequiredEs_object_defineProperties) return es_object_defineProperties;
  hasRequiredEs_object_defineProperties = 1;
  var $ = require_export();
  var DESCRIPTORS = requireDescriptors();
  var defineProperties2 = requireObjectDefineProperties().f;
  $({ target: "Object", stat: true, forced: Object.defineProperties !== defineProperties2, sham: !DESCRIPTORS }, {
    defineProperties: defineProperties2
  });
  return es_object_defineProperties;
}
var hasRequiredDefineProperties$2;
function requireDefineProperties$2() {
  if (hasRequiredDefineProperties$2) return defineProperties$2.exports;
  hasRequiredDefineProperties$2 = 1;
  requireEs_object_defineProperties();
  var path2 = requirePath();
  var Object2 = path2.Object;
  var defineProperties2 = defineProperties$2.exports = function defineProperties3(T, D) {
    return Object2.defineProperties(T, D);
  };
  if (Object2.defineProperties.sham) defineProperties2.sham = true;
  return defineProperties$2.exports;
}
var defineProperties$1;
var hasRequiredDefineProperties$1;
function requireDefineProperties$1() {
  if (hasRequiredDefineProperties$1) return defineProperties$1;
  hasRequiredDefineProperties$1 = 1;
  var parent = requireDefineProperties$2();
  defineProperties$1 = parent;
  return defineProperties$1;
}
var defineProperties;
var hasRequiredDefineProperties;
function requireDefineProperties() {
  if (hasRequiredDefineProperties) return defineProperties;
  hasRequiredDefineProperties = 1;
  defineProperties = requireDefineProperties$1();
  return defineProperties;
}
var definePropertiesExports = requireDefineProperties();
var _Object$defineProperties = getDefaultExportFromCjs(definePropertiesExports);
var defineProperty$5 = { exports: {} };
var es_object_defineProperty = {};
var hasRequiredEs_object_defineProperty;
function requireEs_object_defineProperty() {
  if (hasRequiredEs_object_defineProperty) return es_object_defineProperty;
  hasRequiredEs_object_defineProperty = 1;
  var $ = require_export();
  var DESCRIPTORS = requireDescriptors();
  var defineProperty2 = requireObjectDefineProperty().f;
  $({ target: "Object", stat: true, forced: Object.defineProperty !== defineProperty2, sham: !DESCRIPTORS }, {
    defineProperty: defineProperty2
  });
  return es_object_defineProperty;
}
var hasRequiredDefineProperty$5;
function requireDefineProperty$5() {
  if (hasRequiredDefineProperty$5) return defineProperty$5.exports;
  hasRequiredDefineProperty$5 = 1;
  requireEs_object_defineProperty();
  var path2 = requirePath();
  var Object2 = path2.Object;
  var defineProperty2 = defineProperty$5.exports = function defineProperty3(it2, key, desc) {
    return Object2.defineProperty(it2, key, desc);
  };
  if (Object2.defineProperty.sham) defineProperty2.sham = true;
  return defineProperty$5.exports;
}
var defineProperty$4;
var hasRequiredDefineProperty$4;
function requireDefineProperty$4() {
  if (hasRequiredDefineProperty$4) return defineProperty$4;
  hasRequiredDefineProperty$4 = 1;
  var parent = requireDefineProperty$5();
  defineProperty$4 = parent;
  return defineProperty$4;
}
var defineProperty$3;
var hasRequiredDefineProperty$3;
function requireDefineProperty$3() {
  if (hasRequiredDefineProperty$3) return defineProperty$3;
  hasRequiredDefineProperty$3 = 1;
  var parent = requireDefineProperty$4();
  defineProperty$3 = parent;
  return defineProperty$3;
}
var defineProperty$2;
var hasRequiredDefineProperty$2;
function requireDefineProperty$2() {
  if (hasRequiredDefineProperty$2) return defineProperty$2;
  hasRequiredDefineProperty$2 = 1;
  var parent = requireDefineProperty$3();
  defineProperty$2 = parent;
  return defineProperty$2;
}
var defineProperty$1;
var hasRequiredDefineProperty$1;
function requireDefineProperty$1() {
  if (hasRequiredDefineProperty$1) return defineProperty$1;
  hasRequiredDefineProperty$1 = 1;
  defineProperty$1 = requireDefineProperty$2();
  return defineProperty$1;
}
var definePropertyExports$1 = requireDefineProperty$1();
var _Object$defineProperty$1 = getDefaultExportFromCjs(definePropertyExports$1);
var esnext_function_metadata = {};
var hasRequiredEsnext_function_metadata;
function requireEsnext_function_metadata() {
  if (hasRequiredEsnext_function_metadata) return esnext_function_metadata;
  hasRequiredEsnext_function_metadata = 1;
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var defineProperty2 = requireObjectDefineProperty().f;
  var METADATA = wellKnownSymbol2("metadata");
  var FunctionPrototype = Function.prototype;
  if (FunctionPrototype[METADATA] === void 0) {
    defineProperty2(FunctionPrototype, METADATA, {
      value: null
    });
  }
  return esnext_function_metadata;
}
var esnext_symbol_asyncDispose = {};
var hasRequiredEsnext_symbol_asyncDispose;
function requireEsnext_symbol_asyncDispose() {
  if (hasRequiredEsnext_symbol_asyncDispose) return esnext_symbol_asyncDispose;
  hasRequiredEsnext_symbol_asyncDispose = 1;
  requireEs_symbol_asyncDispose();
  return esnext_symbol_asyncDispose;
}
var esnext_symbol_dispose = {};
var hasRequiredEsnext_symbol_dispose;
function requireEsnext_symbol_dispose() {
  if (hasRequiredEsnext_symbol_dispose) return esnext_symbol_dispose;
  hasRequiredEsnext_symbol_dispose = 1;
  requireEs_symbol_dispose();
  return esnext_symbol_dispose;
}
var esnext_symbol_metadata = {};
var hasRequiredEsnext_symbol_metadata;
function requireEsnext_symbol_metadata() {
  if (hasRequiredEsnext_symbol_metadata) return esnext_symbol_metadata;
  hasRequiredEsnext_symbol_metadata = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("metadata");
  return esnext_symbol_metadata;
}
var symbol$2;
var hasRequiredSymbol$2;
function requireSymbol$2() {
  if (hasRequiredSymbol$2) return symbol$2;
  hasRequiredSymbol$2 = 1;
  var parent = requireSymbol$4();
  requireEsnext_function_metadata();
  requireEsnext_symbol_asyncDispose();
  requireEsnext_symbol_dispose();
  requireEsnext_symbol_metadata();
  symbol$2 = parent;
  return symbol$2;
}
var esnext_symbol_isRegisteredSymbol = {};
var symbolIsRegistered;
var hasRequiredSymbolIsRegistered;
function requireSymbolIsRegistered() {
  if (hasRequiredSymbolIsRegistered) return symbolIsRegistered;
  hasRequiredSymbolIsRegistered = 1;
  var getBuiltIn2 = requireGetBuiltIn();
  var uncurryThis = requireFunctionUncurryThis();
  var Symbol2 = getBuiltIn2("Symbol");
  var keyFor = Symbol2.keyFor;
  var thisSymbolValue = uncurryThis(Symbol2.prototype.valueOf);
  symbolIsRegistered = Symbol2.isRegisteredSymbol || function isRegisteredSymbol(value) {
    try {
      return keyFor(thisSymbolValue(value)) !== void 0;
    } catch (error) {
      return false;
    }
  };
  return symbolIsRegistered;
}
var hasRequiredEsnext_symbol_isRegisteredSymbol;
function requireEsnext_symbol_isRegisteredSymbol() {
  if (hasRequiredEsnext_symbol_isRegisteredSymbol) return esnext_symbol_isRegisteredSymbol;
  hasRequiredEsnext_symbol_isRegisteredSymbol = 1;
  var $ = require_export();
  var isRegisteredSymbol = requireSymbolIsRegistered();
  $({ target: "Symbol", stat: true }, {
    isRegisteredSymbol
  });
  return esnext_symbol_isRegisteredSymbol;
}
var esnext_symbol_isWellKnownSymbol = {};
var symbolIsWellKnown;
var hasRequiredSymbolIsWellKnown;
function requireSymbolIsWellKnown() {
  if (hasRequiredSymbolIsWellKnown) return symbolIsWellKnown;
  hasRequiredSymbolIsWellKnown = 1;
  var shared2 = requireShared();
  var getBuiltIn2 = requireGetBuiltIn();
  var uncurryThis = requireFunctionUncurryThis();
  var isSymbol2 = requireIsSymbol();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var Symbol2 = getBuiltIn2("Symbol");
  var $isWellKnownSymbol = Symbol2.isWellKnownSymbol;
  var getOwnPropertyNames = getBuiltIn2("Object", "getOwnPropertyNames");
  var thisSymbolValue = uncurryThis(Symbol2.prototype.valueOf);
  var WellKnownSymbolsStore = shared2("wks");
  for (var i = 0, symbolKeys = getOwnPropertyNames(Symbol2), symbolKeysLength = symbolKeys.length; i < symbolKeysLength; i++) {
    try {
      var symbolKey = symbolKeys[i];
      if (isSymbol2(Symbol2[symbolKey])) wellKnownSymbol2(symbolKey);
    } catch (error) {
    }
  }
  symbolIsWellKnown = function isWellKnownSymbol(value) {
    if ($isWellKnownSymbol && $isWellKnownSymbol(value)) return true;
    try {
      var symbol2 = thisSymbolValue(value);
      for (var j = 0, keys2 = getOwnPropertyNames(WellKnownSymbolsStore), keysLength = keys2.length; j < keysLength; j++) {
        if (WellKnownSymbolsStore[keys2[j]] == symbol2) return true;
      }
    } catch (error) {
    }
    return false;
  };
  return symbolIsWellKnown;
}
var hasRequiredEsnext_symbol_isWellKnownSymbol;
function requireEsnext_symbol_isWellKnownSymbol() {
  if (hasRequiredEsnext_symbol_isWellKnownSymbol) return esnext_symbol_isWellKnownSymbol;
  hasRequiredEsnext_symbol_isWellKnownSymbol = 1;
  var $ = require_export();
  var isWellKnownSymbol = requireSymbolIsWellKnown();
  $({ target: "Symbol", stat: true, forced: true }, {
    isWellKnownSymbol
  });
  return esnext_symbol_isWellKnownSymbol;
}
var esnext_symbol_customMatcher = {};
var hasRequiredEsnext_symbol_customMatcher;
function requireEsnext_symbol_customMatcher() {
  if (hasRequiredEsnext_symbol_customMatcher) return esnext_symbol_customMatcher;
  hasRequiredEsnext_symbol_customMatcher = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("customMatcher");
  return esnext_symbol_customMatcher;
}
var esnext_symbol_observable = {};
var hasRequiredEsnext_symbol_observable;
function requireEsnext_symbol_observable() {
  if (hasRequiredEsnext_symbol_observable) return esnext_symbol_observable;
  hasRequiredEsnext_symbol_observable = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("observable");
  return esnext_symbol_observable;
}
var esnext_symbol_isRegistered = {};
var hasRequiredEsnext_symbol_isRegistered;
function requireEsnext_symbol_isRegistered() {
  if (hasRequiredEsnext_symbol_isRegistered) return esnext_symbol_isRegistered;
  hasRequiredEsnext_symbol_isRegistered = 1;
  var $ = require_export();
  var isRegisteredSymbol = requireSymbolIsRegistered();
  $({ target: "Symbol", stat: true, name: "isRegisteredSymbol" }, {
    isRegistered: isRegisteredSymbol
  });
  return esnext_symbol_isRegistered;
}
var esnext_symbol_isWellKnown = {};
var hasRequiredEsnext_symbol_isWellKnown;
function requireEsnext_symbol_isWellKnown() {
  if (hasRequiredEsnext_symbol_isWellKnown) return esnext_symbol_isWellKnown;
  hasRequiredEsnext_symbol_isWellKnown = 1;
  var $ = require_export();
  var isWellKnownSymbol = requireSymbolIsWellKnown();
  $({ target: "Symbol", stat: true, name: "isWellKnownSymbol", forced: true }, {
    isWellKnown: isWellKnownSymbol
  });
  return esnext_symbol_isWellKnown;
}
var esnext_symbol_matcher = {};
var hasRequiredEsnext_symbol_matcher;
function requireEsnext_symbol_matcher() {
  if (hasRequiredEsnext_symbol_matcher) return esnext_symbol_matcher;
  hasRequiredEsnext_symbol_matcher = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("matcher");
  return esnext_symbol_matcher;
}
var esnext_symbol_metadataKey = {};
var hasRequiredEsnext_symbol_metadataKey;
function requireEsnext_symbol_metadataKey() {
  if (hasRequiredEsnext_symbol_metadataKey) return esnext_symbol_metadataKey;
  hasRequiredEsnext_symbol_metadataKey = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("metadataKey");
  return esnext_symbol_metadataKey;
}
var esnext_symbol_patternMatch = {};
var hasRequiredEsnext_symbol_patternMatch;
function requireEsnext_symbol_patternMatch() {
  if (hasRequiredEsnext_symbol_patternMatch) return esnext_symbol_patternMatch;
  hasRequiredEsnext_symbol_patternMatch = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("patternMatch");
  return esnext_symbol_patternMatch;
}
var esnext_symbol_replaceAll = {};
var hasRequiredEsnext_symbol_replaceAll;
function requireEsnext_symbol_replaceAll() {
  if (hasRequiredEsnext_symbol_replaceAll) return esnext_symbol_replaceAll;
  hasRequiredEsnext_symbol_replaceAll = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("replaceAll");
  return esnext_symbol_replaceAll;
}
var symbol$1;
var hasRequiredSymbol$1;
function requireSymbol$1() {
  if (hasRequiredSymbol$1) return symbol$1;
  hasRequiredSymbol$1 = 1;
  var parent = requireSymbol$2();
  requireEsnext_symbol_isRegisteredSymbol();
  requireEsnext_symbol_isWellKnownSymbol();
  requireEsnext_symbol_customMatcher();
  requireEsnext_symbol_observable();
  requireEsnext_symbol_isRegistered();
  requireEsnext_symbol_isWellKnown();
  requireEsnext_symbol_matcher();
  requireEsnext_symbol_metadataKey();
  requireEsnext_symbol_patternMatch();
  requireEsnext_symbol_replaceAll();
  symbol$1 = parent;
  return symbol$1;
}
var symbol;
var hasRequiredSymbol;
function requireSymbol() {
  if (hasRequiredSymbol) return symbol;
  hasRequiredSymbol = 1;
  symbol = requireSymbol$1();
  return symbol;
}
var symbolExports = requireSymbol();
var _Symbol = getDefaultExportFromCjs(symbolExports);
var es_string_iterator = {};
var stringMultibyte;
var hasRequiredStringMultibyte;
function requireStringMultibyte() {
  if (hasRequiredStringMultibyte) return stringMultibyte;
  hasRequiredStringMultibyte = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var toString2 = requireToString();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var charAt = uncurryThis("".charAt);
  var charCodeAt = uncurryThis("".charCodeAt);
  var stringSlice = uncurryThis("".slice);
  var createMethod = function(CONVERT_TO_STRING) {
    return function($this, pos) {
      var S = toString2(requireObjectCoercible2($this));
      var position = toIntegerOrInfinity2(pos);
      var size = S.length;
      var first, second;
      if (position < 0 || position >= size) return CONVERT_TO_STRING ? "" : void 0;
      first = charCodeAt(S, position);
      return first < 55296 || first > 56319 || position + 1 === size || (second = charCodeAt(S, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S, position) : first : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
    };
  };
  stringMultibyte = {
    // `String.prototype.codePointAt` method
    // https://tc39.es/ecma262/#sec-string.prototype.codepointat
    codeAt: createMethod(false),
    // `String.prototype.at` method
    // https://github.com/mathiasbynens/String.prototype.at
    charAt: createMethod(true)
  };
  return stringMultibyte;
}
var hasRequiredEs_string_iterator;
function requireEs_string_iterator() {
  if (hasRequiredEs_string_iterator) return es_string_iterator;
  hasRequiredEs_string_iterator = 1;
  var charAt = requireStringMultibyte().charAt;
  var toString2 = requireToString();
  var InternalStateModule = requireInternalState();
  var defineIterator = requireIteratorDefine();
  var createIterResultObject2 = requireCreateIterResultObject();
  var STRING_ITERATOR = "String Iterator";
  var setInternalState = InternalStateModule.set;
  var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
  defineIterator(String, "String", function(iterated) {
    setInternalState(this, {
      type: STRING_ITERATOR,
      string: toString2(iterated),
      index: 0
    });
  }, function next() {
    var state = getInternalState(this);
    var string2 = state.string;
    var index = state.index;
    var point;
    if (index >= string2.length) return createIterResultObject2(void 0, true);
    point = charAt(string2, index);
    state.index += point.length;
    return createIterResultObject2(point, false);
  });
  return es_string_iterator;
}
var iterator$5;
var hasRequiredIterator$5;
function requireIterator$5() {
  if (hasRequiredIterator$5) return iterator$5;
  hasRequiredIterator$5 = 1;
  requireEs_array_iterator();
  requireEs_string_iterator();
  requireEs_symbol_iterator();
  var WrappedWellKnownSymbolModule = requireWellKnownSymbolWrapped();
  iterator$5 = WrappedWellKnownSymbolModule.f("iterator");
  return iterator$5;
}
var iterator$4;
var hasRequiredIterator$4;
function requireIterator$4() {
  if (hasRequiredIterator$4) return iterator$4;
  hasRequiredIterator$4 = 1;
  var parent = requireIterator$5();
  requireWeb_domCollections_iterator();
  iterator$4 = parent;
  return iterator$4;
}
var iterator$3;
var hasRequiredIterator$3;
function requireIterator$3() {
  if (hasRequiredIterator$3) return iterator$3;
  hasRequiredIterator$3 = 1;
  var parent = requireIterator$4();
  iterator$3 = parent;
  return iterator$3;
}
var iterator$2;
var hasRequiredIterator$2;
function requireIterator$2() {
  if (hasRequiredIterator$2) return iterator$2;
  hasRequiredIterator$2 = 1;
  var parent = requireIterator$3();
  iterator$2 = parent;
  return iterator$2;
}
var iterator$1;
var hasRequiredIterator$1;
function requireIterator$1() {
  if (hasRequiredIterator$1) return iterator$1;
  hasRequiredIterator$1 = 1;
  iterator$1 = requireIterator$2();
  return iterator$1;
}
var iteratorExports$1 = requireIterator$1();
var _Symbol$iterator$1 = getDefaultExportFromCjs(iteratorExports$1);
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof _Symbol && "symbol" == typeof _Symbol$iterator$1 ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof _Symbol && o2.constructor === _Symbol && o2 !== _Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
var toPrimitive$5;
var hasRequiredToPrimitive$4;
function requireToPrimitive$4() {
  if (hasRequiredToPrimitive$4) return toPrimitive$5;
  hasRequiredToPrimitive$4 = 1;
  requireEs_symbol_toPrimitive();
  var WrappedWellKnownSymbolModule = requireWellKnownSymbolWrapped();
  toPrimitive$5 = WrappedWellKnownSymbolModule.f("toPrimitive");
  return toPrimitive$5;
}
var toPrimitive$4;
var hasRequiredToPrimitive$3;
function requireToPrimitive$3() {
  if (hasRequiredToPrimitive$3) return toPrimitive$4;
  hasRequiredToPrimitive$3 = 1;
  var parent = requireToPrimitive$4();
  toPrimitive$4 = parent;
  return toPrimitive$4;
}
var toPrimitive$3;
var hasRequiredToPrimitive$2;
function requireToPrimitive$2() {
  if (hasRequiredToPrimitive$2) return toPrimitive$3;
  hasRequiredToPrimitive$2 = 1;
  var parent = requireToPrimitive$3();
  toPrimitive$3 = parent;
  return toPrimitive$3;
}
var toPrimitive$2;
var hasRequiredToPrimitive$1;
function requireToPrimitive$1() {
  if (hasRequiredToPrimitive$1) return toPrimitive$2;
  hasRequiredToPrimitive$1 = 1;
  var parent = requireToPrimitive$2();
  toPrimitive$2 = parent;
  return toPrimitive$2;
}
var toPrimitive$1;
var hasRequiredToPrimitive;
function requireToPrimitive() {
  if (hasRequiredToPrimitive) return toPrimitive$1;
  hasRequiredToPrimitive = 1;
  toPrimitive$1 = requireToPrimitive$1();
  return toPrimitive$1;
}
var toPrimitiveExports = requireToPrimitive();
var _Symbol$toPrimitive = getDefaultExportFromCjs(toPrimitiveExports);
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[_Symbol$toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? _Object$defineProperty$1(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}
var es_array_reduce = {};
var arrayReduce;
var hasRequiredArrayReduce;
function requireArrayReduce() {
  if (hasRequiredArrayReduce) return arrayReduce;
  hasRequiredArrayReduce = 1;
  var aCallable2 = requireACallable();
  var toObject2 = requireToObject();
  var IndexedObject = requireIndexedObject();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var $TypeError = TypeError;
  var REDUCE_EMPTY = "Reduce of empty array with no initial value";
  var createMethod = function(IS_RIGHT) {
    return function(that, callbackfn, argumentsLength, memo) {
      var O = toObject2(that);
      var self2 = IndexedObject(O);
      var length = lengthOfArrayLike2(O);
      aCallable2(callbackfn);
      if (length === 0 && argumentsLength < 2) throw new $TypeError(REDUCE_EMPTY);
      var index = IS_RIGHT ? length - 1 : 0;
      var i = IS_RIGHT ? -1 : 1;
      if (argumentsLength < 2) while (true) {
        if (index in self2) {
          memo = self2[index];
          index += i;
          break;
        }
        index += i;
        if (IS_RIGHT ? index < 0 : length <= index) {
          throw new $TypeError(REDUCE_EMPTY);
        }
      }
      for (; IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self2) {
        memo = callbackfn(memo, self2[index], index, O);
      }
      return memo;
    };
  };
  arrayReduce = {
    // `Array.prototype.reduce` method
    // https://tc39.es/ecma262/#sec-array.prototype.reduce
    left: createMethod(false),
    // `Array.prototype.reduceRight` method
    // https://tc39.es/ecma262/#sec-array.prototype.reduceright
    right: createMethod(true)
  };
  return arrayReduce;
}
var environmentIsNode;
var hasRequiredEnvironmentIsNode;
function requireEnvironmentIsNode() {
  if (hasRequiredEnvironmentIsNode) return environmentIsNode;
  hasRequiredEnvironmentIsNode = 1;
  var ENVIRONMENT = requireEnvironment();
  environmentIsNode = ENVIRONMENT === "NODE";
  return environmentIsNode;
}
var hasRequiredEs_array_reduce;
function requireEs_array_reduce() {
  if (hasRequiredEs_array_reduce) return es_array_reduce;
  hasRequiredEs_array_reduce = 1;
  var $ = require_export();
  var $reduce = requireArrayReduce().left;
  var arrayMethodIsStrict2 = requireArrayMethodIsStrict();
  var CHROME_VERSION = requireEnvironmentV8Version();
  var IS_NODE = requireEnvironmentIsNode();
  var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
  var FORCED = CHROME_BUG || !arrayMethodIsStrict2("reduce");
  $({ target: "Array", proto: true, forced: FORCED }, {
    reduce: function reduce2(callbackfn) {
      var length = arguments.length;
      return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : void 0);
    }
  });
  return es_array_reduce;
}
var reduce$3;
var hasRequiredReduce$3;
function requireReduce$3() {
  if (hasRequiredReduce$3) return reduce$3;
  hasRequiredReduce$3 = 1;
  requireEs_array_reduce();
  var getBuiltInPrototypeMethod2 = requireGetBuiltInPrototypeMethod();
  reduce$3 = getBuiltInPrototypeMethod2("Array", "reduce");
  return reduce$3;
}
var reduce$2;
var hasRequiredReduce$2;
function requireReduce$2() {
  if (hasRequiredReduce$2) return reduce$2;
  hasRequiredReduce$2 = 1;
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var method = requireReduce$3();
  var ArrayPrototype = Array.prototype;
  reduce$2 = function(it2) {
    var own = it2.reduce;
    return it2 === ArrayPrototype || isPrototypeOf(ArrayPrototype, it2) && own === ArrayPrototype.reduce ? method : own;
  };
  return reduce$2;
}
var reduce$1;
var hasRequiredReduce$1;
function requireReduce$1() {
  if (hasRequiredReduce$1) return reduce$1;
  hasRequiredReduce$1 = 1;
  var parent = requireReduce$2();
  reduce$1 = parent;
  return reduce$1;
}
var reduce;
var hasRequiredReduce;
function requireReduce() {
  if (hasRequiredReduce) return reduce;
  hasRequiredReduce = 1;
  reduce = requireReduce$1();
  return reduce;
}
var reduceExports = requireReduce();
var _reduceInstanceProperty = getDefaultExportFromCjs(reduceExports);
var es_array_flatMap = {};
var flattenIntoArray_1;
var hasRequiredFlattenIntoArray;
function requireFlattenIntoArray() {
  if (hasRequiredFlattenIntoArray) return flattenIntoArray_1;
  hasRequiredFlattenIntoArray = 1;
  var isArray2 = requireIsArray$3();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var doesNotExceedSafeInteger2 = requireDoesNotExceedSafeInteger();
  var bind2 = requireFunctionBindContext();
  var flattenIntoArray = function(target, original, source, sourceLen, start, depth, mapper, thisArg) {
    var targetIndex = start;
    var sourceIndex = 0;
    var mapFn = mapper ? bind2(mapper, thisArg) : false;
    var element, elementLen;
    while (sourceIndex < sourceLen) {
      if (sourceIndex in source) {
        element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
        if (depth > 0 && isArray2(element)) {
          elementLen = lengthOfArrayLike2(element);
          targetIndex = flattenIntoArray(target, original, element, elementLen, targetIndex, depth - 1) - 1;
        } else {
          doesNotExceedSafeInteger2(targetIndex + 1);
          target[targetIndex] = element;
        }
        targetIndex++;
      }
      sourceIndex++;
    }
    return targetIndex;
  };
  flattenIntoArray_1 = flattenIntoArray;
  return flattenIntoArray_1;
}
var hasRequiredEs_array_flatMap;
function requireEs_array_flatMap() {
  if (hasRequiredEs_array_flatMap) return es_array_flatMap;
  hasRequiredEs_array_flatMap = 1;
  var $ = require_export();
  var flattenIntoArray = requireFlattenIntoArray();
  var aCallable2 = requireACallable();
  var toObject2 = requireToObject();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var arraySpeciesCreate2 = requireArraySpeciesCreate();
  $({ target: "Array", proto: true }, {
    flatMap: function flatMap2(callbackfn) {
      var O = toObject2(this);
      var sourceLen = lengthOfArrayLike2(O);
      var A;
      aCallable2(callbackfn);
      A = arraySpeciesCreate2(O, 0);
      A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      return A;
    }
  });
  return es_array_flatMap;
}
var es_array_unscopables_flatMap = {};
var hasRequiredEs_array_unscopables_flatMap;
function requireEs_array_unscopables_flatMap() {
  if (hasRequiredEs_array_unscopables_flatMap) return es_array_unscopables_flatMap;
  hasRequiredEs_array_unscopables_flatMap = 1;
  var addToUnscopables2 = requireAddToUnscopables();
  addToUnscopables2("flatMap");
  return es_array_unscopables_flatMap;
}
var flatMap$3;
var hasRequiredFlatMap$3;
function requireFlatMap$3() {
  if (hasRequiredFlatMap$3) return flatMap$3;
  hasRequiredFlatMap$3 = 1;
  requireEs_array_flatMap();
  requireEs_array_unscopables_flatMap();
  var getBuiltInPrototypeMethod2 = requireGetBuiltInPrototypeMethod();
  flatMap$3 = getBuiltInPrototypeMethod2("Array", "flatMap");
  return flatMap$3;
}
var flatMap$2;
var hasRequiredFlatMap$2;
function requireFlatMap$2() {
  if (hasRequiredFlatMap$2) return flatMap$2;
  hasRequiredFlatMap$2 = 1;
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var method = requireFlatMap$3();
  var ArrayPrototype = Array.prototype;
  flatMap$2 = function(it2) {
    var own = it2.flatMap;
    return it2 === ArrayPrototype || isPrototypeOf(ArrayPrototype, it2) && own === ArrayPrototype.flatMap ? method : own;
  };
  return flatMap$2;
}
var flatMap$1;
var hasRequiredFlatMap$1;
function requireFlatMap$1() {
  if (hasRequiredFlatMap$1) return flatMap$1;
  hasRequiredFlatMap$1 = 1;
  var parent = requireFlatMap$2();
  flatMap$1 = parent;
  return flatMap$1;
}
var flatMap;
var hasRequiredFlatMap;
function requireFlatMap() {
  if (hasRequiredFlatMap) return flatMap;
  hasRequiredFlatMap = 1;
  flatMap = requireFlatMap$1();
  return flatMap;
}
var flatMapExports = requireFlatMap();
var _flatMapInstanceProperty = getDefaultExportFromCjs(flatMapExports);
var iterator;
var hasRequiredIterator;
function requireIterator() {
  if (hasRequiredIterator) return iterator;
  hasRequiredIterator = 1;
  iterator = requireIterator$4();
  return iterator;
}
var iteratorExports = requireIterator();
var _Symbol$iterator = getDefaultExportFromCjs(iteratorExports);
var es_map = {};
var es_map_constructor = {};
var internalMetadata = { exports: {} };
var arrayBufferNonExtensible;
var hasRequiredArrayBufferNonExtensible;
function requireArrayBufferNonExtensible() {
  if (hasRequiredArrayBufferNonExtensible) return arrayBufferNonExtensible;
  hasRequiredArrayBufferNonExtensible = 1;
  var fails2 = requireFails();
  arrayBufferNonExtensible = fails2(function() {
    if (typeof ArrayBuffer == "function") {
      var buffer = new ArrayBuffer(8);
      if (Object.isExtensible(buffer)) Object.defineProperty(buffer, "a", { value: 8 });
    }
  });
  return arrayBufferNonExtensible;
}
var objectIsExtensible;
var hasRequiredObjectIsExtensible;
function requireObjectIsExtensible() {
  if (hasRequiredObjectIsExtensible) return objectIsExtensible;
  hasRequiredObjectIsExtensible = 1;
  var fails2 = requireFails();
  var isObject2 = requireIsObject();
  var classof2 = requireClassofRaw();
  var ARRAY_BUFFER_NON_EXTENSIBLE = requireArrayBufferNonExtensible();
  var $isExtensible = Object.isExtensible;
  var FAILS_ON_PRIMITIVES = fails2(function() {
  });
  objectIsExtensible = FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it2) {
    if (!isObject2(it2)) return false;
    if (ARRAY_BUFFER_NON_EXTENSIBLE && classof2(it2) === "ArrayBuffer") return false;
    return $isExtensible ? $isExtensible(it2) : true;
  } : $isExtensible;
  return objectIsExtensible;
}
var freezing;
var hasRequiredFreezing;
function requireFreezing() {
  if (hasRequiredFreezing) return freezing;
  hasRequiredFreezing = 1;
  var fails2 = requireFails();
  freezing = !fails2(function() {
    return Object.isExtensible(Object.preventExtensions({}));
  });
  return freezing;
}
var hasRequiredInternalMetadata;
function requireInternalMetadata() {
  if (hasRequiredInternalMetadata) return internalMetadata.exports;
  hasRequiredInternalMetadata = 1;
  var $ = require_export();
  var uncurryThis = requireFunctionUncurryThis();
  var hiddenKeys2 = requireHiddenKeys();
  var isObject2 = requireIsObject();
  var hasOwn = requireHasOwnProperty();
  var defineProperty2 = requireObjectDefineProperty().f;
  var getOwnPropertyNamesModule = requireObjectGetOwnPropertyNames();
  var getOwnPropertyNamesExternalModule = requireObjectGetOwnPropertyNamesExternal();
  var isExtensible = requireObjectIsExtensible();
  var uid2 = requireUid();
  var FREEZING = requireFreezing();
  var REQUIRED = false;
  var METADATA = uid2("meta");
  var id = 0;
  var setMetadata = function(it2) {
    defineProperty2(it2, METADATA, { value: {
      objectID: "O" + id++,
      // object ID
      weakData: {}
      // weak collections IDs
    } });
  };
  var fastKey = function(it2, create2) {
    if (!isObject2(it2)) return typeof it2 == "symbol" ? it2 : (typeof it2 == "string" ? "S" : "P") + it2;
    if (!hasOwn(it2, METADATA)) {
      if (!isExtensible(it2)) return "F";
      if (!create2) return "E";
      setMetadata(it2);
    }
    return it2[METADATA].objectID;
  };
  var getWeakData = function(it2, create2) {
    if (!hasOwn(it2, METADATA)) {
      if (!isExtensible(it2)) return true;
      if (!create2) return false;
      setMetadata(it2);
    }
    return it2[METADATA].weakData;
  };
  var onFreeze = function(it2) {
    if (FREEZING && REQUIRED && isExtensible(it2) && !hasOwn(it2, METADATA)) setMetadata(it2);
    return it2;
  };
  var enable = function() {
    meta.enable = function() {
    };
    REQUIRED = true;
    var getOwnPropertyNames = getOwnPropertyNamesModule.f;
    var splice2 = uncurryThis([].splice);
    var test = {};
    test[METADATA] = 1;
    if (getOwnPropertyNames(test).length) {
      getOwnPropertyNamesModule.f = function(it2) {
        var result = getOwnPropertyNames(it2);
        for (var i = 0, length = result.length; i < length; i++) {
          if (result[i] === METADATA) {
            splice2(result, i, 1);
            break;
          }
        }
        return result;
      };
      $({ target: "Object", stat: true, forced: true }, {
        getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
      });
    }
  };
  var meta = internalMetadata.exports = {
    enable,
    fastKey,
    getWeakData,
    onFreeze
  };
  hiddenKeys2[METADATA] = true;
  return internalMetadata.exports;
}
var isArrayIteratorMethod;
var hasRequiredIsArrayIteratorMethod;
function requireIsArrayIteratorMethod() {
  if (hasRequiredIsArrayIteratorMethod) return isArrayIteratorMethod;
  hasRequiredIsArrayIteratorMethod = 1;
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var Iterators = requireIterators();
  var ITERATOR = wellKnownSymbol2("iterator");
  var ArrayPrototype = Array.prototype;
  isArrayIteratorMethod = function(it2) {
    return it2 !== void 0 && (Iterators.Array === it2 || ArrayPrototype[ITERATOR] === it2);
  };
  return isArrayIteratorMethod;
}
var getIteratorMethod;
var hasRequiredGetIteratorMethod;
function requireGetIteratorMethod() {
  if (hasRequiredGetIteratorMethod) return getIteratorMethod;
  hasRequiredGetIteratorMethod = 1;
  var classof2 = requireClassof();
  var getMethod2 = requireGetMethod();
  var isNullOrUndefined2 = requireIsNullOrUndefined();
  var Iterators = requireIterators();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var ITERATOR = wellKnownSymbol2("iterator");
  getIteratorMethod = function(it2) {
    if (!isNullOrUndefined2(it2)) return getMethod2(it2, ITERATOR) || getMethod2(it2, "@@iterator") || Iterators[classof2(it2)];
  };
  return getIteratorMethod;
}
var getIterator$5;
var hasRequiredGetIterator$6;
function requireGetIterator$6() {
  if (hasRequiredGetIterator$6) return getIterator$5;
  hasRequiredGetIterator$6 = 1;
  var call = requireFunctionCall();
  var aCallable2 = requireACallable();
  var anObject2 = requireAnObject();
  var tryToString2 = requireTryToString();
  var getIteratorMethod2 = requireGetIteratorMethod();
  var $TypeError = TypeError;
  getIterator$5 = function(argument, usingIterator) {
    var iteratorMethod = arguments.length < 2 ? getIteratorMethod2(argument) : usingIterator;
    if (aCallable2(iteratorMethod)) return anObject2(call(iteratorMethod, argument));
    throw new $TypeError(tryToString2(argument) + " is not iterable");
  };
  return getIterator$5;
}
var iteratorClose;
var hasRequiredIteratorClose;
function requireIteratorClose() {
  if (hasRequiredIteratorClose) return iteratorClose;
  hasRequiredIteratorClose = 1;
  var call = requireFunctionCall();
  var anObject2 = requireAnObject();
  var getMethod2 = requireGetMethod();
  iteratorClose = function(iterator2, kind, value) {
    var innerResult, innerError;
    anObject2(iterator2);
    try {
      innerResult = getMethod2(iterator2, "return");
      if (!innerResult) {
        if (kind === "throw") throw value;
        return value;
      }
      innerResult = call(innerResult, iterator2);
    } catch (error) {
      innerError = true;
      innerResult = error;
    }
    if (kind === "throw") throw value;
    if (innerError) throw innerResult;
    anObject2(innerResult);
    return value;
  };
  return iteratorClose;
}
var iterate;
var hasRequiredIterate;
function requireIterate() {
  if (hasRequiredIterate) return iterate;
  hasRequiredIterate = 1;
  var bind2 = requireFunctionBindContext();
  var call = requireFunctionCall();
  var anObject2 = requireAnObject();
  var tryToString2 = requireTryToString();
  var isArrayIteratorMethod2 = requireIsArrayIteratorMethod();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var getIterator2 = requireGetIterator$6();
  var getIteratorMethod2 = requireGetIteratorMethod();
  var iteratorClose2 = requireIteratorClose();
  var $TypeError = TypeError;
  var Result = function(stopped, result) {
    this.stopped = stopped;
    this.result = result;
  };
  var ResultPrototype = Result.prototype;
  iterate = function(iterable, unboundFunction, options) {
    var that = options && options.that;
    var AS_ENTRIES = !!(options && options.AS_ENTRIES);
    var IS_RECORD = !!(options && options.IS_RECORD);
    var IS_ITERATOR = !!(options && options.IS_ITERATOR);
    var INTERRUPTED = !!(options && options.INTERRUPTED);
    var fn = bind2(unboundFunction, that);
    var iterator2, iterFn, index, length, result, next, step;
    var stop = function(condition) {
      if (iterator2) iteratorClose2(iterator2, "normal");
      return new Result(true, condition);
    };
    var callFn = function(value) {
      if (AS_ENTRIES) {
        anObject2(value);
        return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
      }
      return INTERRUPTED ? fn(value, stop) : fn(value);
    };
    if (IS_RECORD) {
      iterator2 = iterable.iterator;
    } else if (IS_ITERATOR) {
      iterator2 = iterable;
    } else {
      iterFn = getIteratorMethod2(iterable);
      if (!iterFn) throw new $TypeError(tryToString2(iterable) + " is not iterable");
      if (isArrayIteratorMethod2(iterFn)) {
        for (index = 0, length = lengthOfArrayLike2(iterable); length > index; index++) {
          result = callFn(iterable[index]);
          if (result && isPrototypeOf(ResultPrototype, result)) return result;
        }
        return new Result(false);
      }
      iterator2 = getIterator2(iterable, iterFn);
    }
    next = IS_RECORD ? iterable.next : iterator2.next;
    while (!(step = call(next, iterator2)).done) {
      try {
        result = callFn(step.value);
      } catch (error) {
        iteratorClose2(iterator2, "throw", error);
      }
      if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result)) return result;
    }
    return new Result(false);
  };
  return iterate;
}
var anInstance;
var hasRequiredAnInstance;
function requireAnInstance() {
  if (hasRequiredAnInstance) return anInstance;
  hasRequiredAnInstance = 1;
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var $TypeError = TypeError;
  anInstance = function(it2, Prototype) {
    if (isPrototypeOf(Prototype, it2)) return it2;
    throw new $TypeError("Incorrect invocation");
  };
  return anInstance;
}
var collection;
var hasRequiredCollection;
function requireCollection() {
  if (hasRequiredCollection) return collection;
  hasRequiredCollection = 1;
  var $ = require_export();
  var globalThis2 = requireGlobalThis();
  var InternalMetadataModule = requireInternalMetadata();
  var fails2 = requireFails();
  var createNonEnumerableProperty2 = requireCreateNonEnumerableProperty();
  var iterate2 = requireIterate();
  var anInstance2 = requireAnInstance();
  var isCallable2 = requireIsCallable();
  var isObject2 = requireIsObject();
  var isNullOrUndefined2 = requireIsNullOrUndefined();
  var setToStringTag2 = requireSetToStringTag();
  var defineProperty2 = requireObjectDefineProperty().f;
  var forEach2 = requireArrayIteration().forEach;
  var DESCRIPTORS = requireDescriptors();
  var InternalStateModule = requireInternalState();
  var setInternalState = InternalStateModule.set;
  var internalStateGetterFor = InternalStateModule.getterFor;
  collection = function(CONSTRUCTOR_NAME, wrapper, common) {
    var IS_MAP = CONSTRUCTOR_NAME.indexOf("Map") !== -1;
    var IS_WEAK = CONSTRUCTOR_NAME.indexOf("Weak") !== -1;
    var ADDER = IS_MAP ? "set" : "add";
    var NativeConstructor = globalThis2[CONSTRUCTOR_NAME];
    var NativePrototype = NativeConstructor && NativeConstructor.prototype;
    var exported = {};
    var Constructor;
    if (!DESCRIPTORS || !isCallable2(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails2(function() {
      new NativeConstructor().entries().next();
    }))) {
      Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
      InternalMetadataModule.enable();
    } else {
      Constructor = wrapper(function(target, iterable) {
        setInternalState(anInstance2(target, Prototype), {
          type: CONSTRUCTOR_NAME,
          collection: new NativeConstructor()
        });
        if (!isNullOrUndefined2(iterable)) iterate2(iterable, target[ADDER], { that: target, AS_ENTRIES: IS_MAP });
      });
      var Prototype = Constructor.prototype;
      var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
      forEach2(["add", "clear", "delete", "forEach", "get", "has", "set", "keys", "values", "entries"], function(KEY) {
        var IS_ADDER = KEY === "add" || KEY === "set";
        if (KEY in NativePrototype && !(IS_WEAK && KEY === "clear")) {
          createNonEnumerableProperty2(Prototype, KEY, function(a, b) {
            var collection2 = getInternalState(this).collection;
            if (!IS_ADDER && IS_WEAK && !isObject2(a)) return KEY === "get" ? void 0 : false;
            var result = collection2[KEY](a === 0 ? 0 : a, b);
            return IS_ADDER ? this : result;
          });
        }
      });
      IS_WEAK || defineProperty2(Prototype, "size", {
        configurable: true,
        get: function() {
          return getInternalState(this).collection.size;
        }
      });
    }
    setToStringTag2(Constructor, CONSTRUCTOR_NAME, false, true);
    exported[CONSTRUCTOR_NAME] = Constructor;
    $({ global: true, forced: true }, exported);
    if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
    return Constructor;
  };
  return collection;
}
var defineBuiltIns;
var hasRequiredDefineBuiltIns;
function requireDefineBuiltIns() {
  if (hasRequiredDefineBuiltIns) return defineBuiltIns;
  hasRequiredDefineBuiltIns = 1;
  var defineBuiltIn2 = requireDefineBuiltIn();
  defineBuiltIns = function(target, src, options) {
    for (var key in src) {
      if (options && options.unsafe && target[key]) target[key] = src[key];
      else defineBuiltIn2(target, key, src[key], options);
    }
    return target;
  };
  return defineBuiltIns;
}
var setSpecies;
var hasRequiredSetSpecies;
function requireSetSpecies() {
  if (hasRequiredSetSpecies) return setSpecies;
  hasRequiredSetSpecies = 1;
  var getBuiltIn2 = requireGetBuiltIn();
  var defineBuiltInAccessor2 = requireDefineBuiltInAccessor();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var DESCRIPTORS = requireDescriptors();
  var SPECIES = wellKnownSymbol2("species");
  setSpecies = function(CONSTRUCTOR_NAME) {
    var Constructor = getBuiltIn2(CONSTRUCTOR_NAME);
    if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
      defineBuiltInAccessor2(Constructor, SPECIES, {
        configurable: true,
        get: function() {
          return this;
        }
      });
    }
  };
  return setSpecies;
}
var collectionStrong;
var hasRequiredCollectionStrong;
function requireCollectionStrong() {
  if (hasRequiredCollectionStrong) return collectionStrong;
  hasRequiredCollectionStrong = 1;
  var create2 = requireObjectCreate();
  var defineBuiltInAccessor2 = requireDefineBuiltInAccessor();
  var defineBuiltIns2 = requireDefineBuiltIns();
  var bind2 = requireFunctionBindContext();
  var anInstance2 = requireAnInstance();
  var isNullOrUndefined2 = requireIsNullOrUndefined();
  var iterate2 = requireIterate();
  var defineIterator = requireIteratorDefine();
  var createIterResultObject2 = requireCreateIterResultObject();
  var setSpecies2 = requireSetSpecies();
  var DESCRIPTORS = requireDescriptors();
  var fastKey = requireInternalMetadata().fastKey;
  var InternalStateModule = requireInternalState();
  var setInternalState = InternalStateModule.set;
  var internalStateGetterFor = InternalStateModule.getterFor;
  collectionStrong = {
    getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
      var Constructor = wrapper(function(that, iterable) {
        anInstance2(that, Prototype);
        setInternalState(that, {
          type: CONSTRUCTOR_NAME,
          index: create2(null),
          first: null,
          last: null,
          size: 0
        });
        if (!DESCRIPTORS) that.size = 0;
        if (!isNullOrUndefined2(iterable)) iterate2(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
      });
      var Prototype = Constructor.prototype;
      var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
      var define = function(that, key, value) {
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        var previous, index;
        if (entry) {
          entry.value = value;
        } else {
          state.last = entry = {
            index: index = fastKey(key, true),
            key,
            value,
            previous: previous = state.last,
            next: null,
            removed: false
          };
          if (!state.first) state.first = entry;
          if (previous) previous.next = entry;
          if (DESCRIPTORS) state.size++;
          else that.size++;
          if (index !== "F") state.index[index] = entry;
        }
        return that;
      };
      var getEntry = function(that, key) {
        var state = getInternalState(that);
        var index = fastKey(key);
        var entry;
        if (index !== "F") return state.index[index];
        for (entry = state.first; entry; entry = entry.next) {
          if (entry.key === key) return entry;
        }
      };
      defineBuiltIns2(Prototype, {
        // `{ Map, Set }.prototype.clear()` methods
        // https://tc39.es/ecma262/#sec-map.prototype.clear
        // https://tc39.es/ecma262/#sec-set.prototype.clear
        clear: function clear() {
          var that = this;
          var state = getInternalState(that);
          var entry = state.first;
          while (entry) {
            entry.removed = true;
            if (entry.previous) entry.previous = entry.previous.next = null;
            entry = entry.next;
          }
          state.first = state.last = null;
          state.index = create2(null);
          if (DESCRIPTORS) state.size = 0;
          else that.size = 0;
        },
        // `{ Map, Set }.prototype.delete(key)` methods
        // https://tc39.es/ecma262/#sec-map.prototype.delete
        // https://tc39.es/ecma262/#sec-set.prototype.delete
        "delete": function(key) {
          var that = this;
          var state = getInternalState(that);
          var entry = getEntry(that, key);
          if (entry) {
            var next = entry.next;
            var prev = entry.previous;
            delete state.index[entry.index];
            entry.removed = true;
            if (prev) prev.next = next;
            if (next) next.previous = prev;
            if (state.first === entry) state.first = next;
            if (state.last === entry) state.last = prev;
            if (DESCRIPTORS) state.size--;
            else that.size--;
          }
          return !!entry;
        },
        // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
        // https://tc39.es/ecma262/#sec-map.prototype.foreach
        // https://tc39.es/ecma262/#sec-set.prototype.foreach
        forEach: function forEach2(callbackfn) {
          var state = getInternalState(this);
          var boundFunction = bind2(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
          var entry;
          while (entry = entry ? entry.next : state.first) {
            boundFunction(entry.value, entry.key, this);
            while (entry && entry.removed) entry = entry.previous;
          }
        },
        // `{ Map, Set}.prototype.has(key)` methods
        // https://tc39.es/ecma262/#sec-map.prototype.has
        // https://tc39.es/ecma262/#sec-set.prototype.has
        has: function has(key) {
          return !!getEntry(this, key);
        }
      });
      defineBuiltIns2(Prototype, IS_MAP ? {
        // `Map.prototype.get(key)` method
        // https://tc39.es/ecma262/#sec-map.prototype.get
        get: function get(key) {
          var entry = getEntry(this, key);
          return entry && entry.value;
        },
        // `Map.prototype.set(key, value)` method
        // https://tc39.es/ecma262/#sec-map.prototype.set
        set: function set2(key, value) {
          return define(this, key === 0 ? 0 : key, value);
        }
      } : {
        // `Set.prototype.add(value)` method
        // https://tc39.es/ecma262/#sec-set.prototype.add
        add: function add(value) {
          return define(this, value = value === 0 ? 0 : value, value);
        }
      });
      if (DESCRIPTORS) defineBuiltInAccessor2(Prototype, "size", {
        configurable: true,
        get: function() {
          return getInternalState(this).size;
        }
      });
      return Constructor;
    },
    setStrong: function(Constructor, CONSTRUCTOR_NAME, IS_MAP) {
      var ITERATOR_NAME = CONSTRUCTOR_NAME + " Iterator";
      var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
      var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
      defineIterator(Constructor, CONSTRUCTOR_NAME, function(iterated, kind) {
        setInternalState(this, {
          type: ITERATOR_NAME,
          target: iterated,
          state: getInternalCollectionState(iterated),
          kind,
          last: null
        });
      }, function() {
        var state = getInternalIteratorState(this);
        var kind = state.kind;
        var entry = state.last;
        while (entry && entry.removed) entry = entry.previous;
        if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
          state.target = null;
          return createIterResultObject2(void 0, true);
        }
        if (kind === "keys") return createIterResultObject2(entry.key, false);
        if (kind === "values") return createIterResultObject2(entry.value, false);
        return createIterResultObject2([entry.key, entry.value], false);
      }, IS_MAP ? "entries" : "values", !IS_MAP, true);
      setSpecies2(CONSTRUCTOR_NAME);
    }
  };
  return collectionStrong;
}
var hasRequiredEs_map_constructor;
function requireEs_map_constructor() {
  if (hasRequiredEs_map_constructor) return es_map_constructor;
  hasRequiredEs_map_constructor = 1;
  var collection2 = requireCollection();
  var collectionStrong2 = requireCollectionStrong();
  collection2("Map", function(init) {
    return function Map() {
      return init(this, arguments.length ? arguments[0] : void 0);
    };
  }, collectionStrong2);
  return es_map_constructor;
}
var hasRequiredEs_map;
function requireEs_map() {
  if (hasRequiredEs_map) return es_map;
  hasRequiredEs_map = 1;
  requireEs_map_constructor();
  return es_map;
}
var es_map_groupBy = {};
var caller;
var hasRequiredCaller;
function requireCaller() {
  if (hasRequiredCaller) return caller;
  hasRequiredCaller = 1;
  caller = function(methodName, numArgs) {
    return numArgs === 1 ? function(object2, arg) {
      return object2[methodName](arg);
    } : function(object2, arg1, arg2) {
      return object2[methodName](arg1, arg2);
    };
  };
  return caller;
}
var mapHelpers;
var hasRequiredMapHelpers;
function requireMapHelpers() {
  if (hasRequiredMapHelpers) return mapHelpers;
  hasRequiredMapHelpers = 1;
  var getBuiltIn2 = requireGetBuiltIn();
  var caller2 = requireCaller();
  var Map = getBuiltIn2("Map");
  mapHelpers = {
    Map,
    set: caller2("set", 2),
    get: caller2("get", 1),
    has: caller2("has", 1),
    remove: caller2("delete", 1),
    proto: Map.prototype
  };
  return mapHelpers;
}
var hasRequiredEs_map_groupBy;
function requireEs_map_groupBy() {
  if (hasRequiredEs_map_groupBy) return es_map_groupBy;
  hasRequiredEs_map_groupBy = 1;
  var $ = require_export();
  var uncurryThis = requireFunctionUncurryThis();
  var aCallable2 = requireACallable();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var iterate2 = requireIterate();
  var MapHelpers = requireMapHelpers();
  var IS_PURE = requireIsPure();
  var fails2 = requireFails();
  var Map = MapHelpers.Map;
  var has = MapHelpers.has;
  var get = MapHelpers.get;
  var set2 = MapHelpers.set;
  var push = uncurryThis([].push);
  var DOES_NOT_WORK_WITH_PRIMITIVES = IS_PURE || fails2(function() {
    return Map.groupBy("ab", function(it2) {
      return it2;
    }).get("a").length !== 1;
  });
  $({ target: "Map", stat: true, forced: IS_PURE || DOES_NOT_WORK_WITH_PRIMITIVES }, {
    groupBy: function groupBy(items, callbackfn) {
      requireObjectCoercible2(items);
      aCallable2(callbackfn);
      var map2 = new Map();
      var k = 0;
      iterate2(items, function(value) {
        var key = callbackfn(value, k++);
        if (!has(map2, key)) set2(map2, key, [value]);
        else push(get(map2, key), value);
      });
      return map2;
    }
  });
  return es_map_groupBy;
}
var map$2;
var hasRequiredMap$2;
function requireMap$2() {
  if (hasRequiredMap$2) return map$2;
  hasRequiredMap$2 = 1;
  requireEs_array_iterator();
  requireEs_map();
  requireEs_map_groupBy();
  requireEs_string_iterator();
  var path2 = requirePath();
  map$2 = path2.Map;
  return map$2;
}
var map$1;
var hasRequiredMap$1;
function requireMap$1() {
  if (hasRequiredMap$1) return map$1;
  hasRequiredMap$1 = 1;
  var parent = requireMap$2();
  requireWeb_domCollections_iterator();
  map$1 = parent;
  return map$1;
}
var map;
var hasRequiredMap;
function requireMap() {
  if (hasRequiredMap) return map;
  hasRequiredMap = 1;
  map = requireMap$1();
  return map;
}
var mapExports = requireMap();
var _Map = getDefaultExportFromCjs(mapExports);
var es_set = {};
var es_set_constructor = {};
var hasRequiredEs_set_constructor;
function requireEs_set_constructor() {
  if (hasRequiredEs_set_constructor) return es_set_constructor;
  hasRequiredEs_set_constructor = 1;
  var collection2 = requireCollection();
  var collectionStrong2 = requireCollectionStrong();
  collection2("Set", function(init) {
    return function Set2() {
      return init(this, arguments.length ? arguments[0] : void 0);
    };
  }, collectionStrong2);
  return es_set_constructor;
}
var hasRequiredEs_set;
function requireEs_set() {
  if (hasRequiredEs_set) return es_set;
  hasRequiredEs_set = 1;
  requireEs_set_constructor();
  return es_set;
}
var es_set_difference_v2 = {};
var aSet;
var hasRequiredASet;
function requireASet() {
  if (hasRequiredASet) return aSet;
  hasRequiredASet = 1;
  var tryToString2 = requireTryToString();
  var $TypeError = TypeError;
  aSet = function(it2) {
    if (typeof it2 == "object" && "size" in it2 && "has" in it2 && "add" in it2 && "delete" in it2 && "keys" in it2) return it2;
    throw new $TypeError(tryToString2(it2) + " is not a set");
  };
  return aSet;
}
var setHelpers;
var hasRequiredSetHelpers;
function requireSetHelpers() {
  if (hasRequiredSetHelpers) return setHelpers;
  hasRequiredSetHelpers = 1;
  var getBuiltIn2 = requireGetBuiltIn();
  var caller2 = requireCaller();
  var Set2 = getBuiltIn2("Set");
  var SetPrototype = Set2.prototype;
  setHelpers = {
    Set: Set2,
    add: caller2("add", 1),
    has: caller2("has", 1),
    remove: caller2("delete", 1),
    proto: SetPrototype
  };
  return setHelpers;
}
var iterateSimple;
var hasRequiredIterateSimple;
function requireIterateSimple() {
  if (hasRequiredIterateSimple) return iterateSimple;
  hasRequiredIterateSimple = 1;
  var call = requireFunctionCall();
  iterateSimple = function(record, fn, ITERATOR_INSTEAD_OF_RECORD) {
    var iterator2 = ITERATOR_INSTEAD_OF_RECORD ? record : record.iterator;
    var next = record.next;
    var step, result;
    while (!(step = call(next, iterator2)).done) {
      result = fn(step.value);
      if (result !== void 0) return result;
    }
  };
  return iterateSimple;
}
var setIterate;
var hasRequiredSetIterate;
function requireSetIterate() {
  if (hasRequiredSetIterate) return setIterate;
  hasRequiredSetIterate = 1;
  var iterateSimple2 = requireIterateSimple();
  setIterate = function(set2, fn, interruptible) {
    return interruptible ? iterateSimple2(set2.keys(), fn, true) : set2.forEach(fn);
  };
  return setIterate;
}
var setClone;
var hasRequiredSetClone;
function requireSetClone() {
  if (hasRequiredSetClone) return setClone;
  hasRequiredSetClone = 1;
  var SetHelpers = requireSetHelpers();
  var iterate2 = requireSetIterate();
  var Set2 = SetHelpers.Set;
  var add = SetHelpers.add;
  setClone = function(set2) {
    var result = new Set2();
    iterate2(set2, function(it2) {
      add(result, it2);
    });
    return result;
  };
  return setClone;
}
var setSize;
var hasRequiredSetSize;
function requireSetSize() {
  if (hasRequiredSetSize) return setSize;
  hasRequiredSetSize = 1;
  setSize = function(set2) {
    return set2.size;
  };
  return setSize;
}
var getIteratorDirect;
var hasRequiredGetIteratorDirect;
function requireGetIteratorDirect() {
  if (hasRequiredGetIteratorDirect) return getIteratorDirect;
  hasRequiredGetIteratorDirect = 1;
  getIteratorDirect = function(obj) {
    return {
      iterator: obj,
      next: obj.next,
      done: false
    };
  };
  return getIteratorDirect;
}
var getSetRecord;
var hasRequiredGetSetRecord;
function requireGetSetRecord() {
  if (hasRequiredGetSetRecord) return getSetRecord;
  hasRequiredGetSetRecord = 1;
  var aCallable2 = requireACallable();
  var anObject2 = requireAnObject();
  var call = requireFunctionCall();
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var getIteratorDirect2 = requireGetIteratorDirect();
  var INVALID_SIZE = "Invalid size";
  var $RangeError = RangeError;
  var $TypeError = TypeError;
  var max = Math.max;
  var SetRecord = function(set2, intSize) {
    this.set = set2;
    this.size = max(intSize, 0);
    this.has = aCallable2(set2.has);
    this.keys = aCallable2(set2.keys);
  };
  SetRecord.prototype = {
    getIterator: function() {
      return getIteratorDirect2(anObject2(call(this.keys, this.set)));
    },
    includes: function(it2) {
      return call(this.has, this.set, it2);
    }
  };
  getSetRecord = function(obj) {
    anObject2(obj);
    var numSize = +obj.size;
    if (numSize !== numSize) throw new $TypeError(INVALID_SIZE);
    var intSize = toIntegerOrInfinity2(numSize);
    if (intSize < 0) throw new $RangeError(INVALID_SIZE);
    return new SetRecord(obj, intSize);
  };
  return getSetRecord;
}
var setDifference;
var hasRequiredSetDifference;
function requireSetDifference() {
  if (hasRequiredSetDifference) return setDifference;
  hasRequiredSetDifference = 1;
  var aSet2 = requireASet();
  var SetHelpers = requireSetHelpers();
  var clone2 = requireSetClone();
  var size = requireSetSize();
  var getSetRecord2 = requireGetSetRecord();
  var iterateSet = requireSetIterate();
  var iterateSimple2 = requireIterateSimple();
  var has = SetHelpers.has;
  var remove = SetHelpers.remove;
  setDifference = function difference(other) {
    var O = aSet2(this);
    var otherRec = getSetRecord2(other);
    var result = clone2(O);
    if (size(O) <= otherRec.size) iterateSet(O, function(e) {
      if (otherRec.includes(e)) remove(result, e);
    });
    else iterateSimple2(otherRec.getIterator(), function(e) {
      if (has(result, e)) remove(result, e);
    });
    return result;
  };
  return setDifference;
}
var setMethodAcceptSetLike;
var hasRequiredSetMethodAcceptSetLike;
function requireSetMethodAcceptSetLike() {
  if (hasRequiredSetMethodAcceptSetLike) return setMethodAcceptSetLike;
  hasRequiredSetMethodAcceptSetLike = 1;
  setMethodAcceptSetLike = function() {
    return false;
  };
  return setMethodAcceptSetLike;
}
var hasRequiredEs_set_difference_v2;
function requireEs_set_difference_v2() {
  if (hasRequiredEs_set_difference_v2) return es_set_difference_v2;
  hasRequiredEs_set_difference_v2 = 1;
  var $ = require_export();
  var difference = requireSetDifference();
  var fails2 = requireFails();
  var setMethodAcceptSetLike2 = requireSetMethodAcceptSetLike();
  var SET_LIKE_INCORRECT_BEHAVIOR = !setMethodAcceptSetLike2("difference", function(result) {
    return result.size === 0;
  });
  var FORCED = SET_LIKE_INCORRECT_BEHAVIOR || fails2(function() {
    var setLike = {
      size: 1,
      has: function() {
        return true;
      },
      keys: function() {
        var index = 0;
        return {
          next: function() {
            var done = index++ > 1;
            if (baseSet.has(1)) baseSet.clear();
            return { done, value: 2 };
          }
        };
      }
    };
    var baseSet = /* @__PURE__ */ new Set([1, 2, 3, 4]);
    return baseSet.difference(setLike).size !== 3;
  });
  $({ target: "Set", proto: true, real: true, forced: FORCED }, {
    difference
  });
  return es_set_difference_v2;
}
var es_set_intersection_v2 = {};
var setIntersection;
var hasRequiredSetIntersection;
function requireSetIntersection() {
  if (hasRequiredSetIntersection) return setIntersection;
  hasRequiredSetIntersection = 1;
  var aSet2 = requireASet();
  var SetHelpers = requireSetHelpers();
  var size = requireSetSize();
  var getSetRecord2 = requireGetSetRecord();
  var iterateSet = requireSetIterate();
  var iterateSimple2 = requireIterateSimple();
  var Set2 = SetHelpers.Set;
  var add = SetHelpers.add;
  var has = SetHelpers.has;
  setIntersection = function intersection(other) {
    var O = aSet2(this);
    var otherRec = getSetRecord2(other);
    var result = new Set2();
    if (size(O) > otherRec.size) {
      iterateSimple2(otherRec.getIterator(), function(e) {
        if (has(O, e)) add(result, e);
      });
    } else {
      iterateSet(O, function(e) {
        if (otherRec.includes(e)) add(result, e);
      });
    }
    return result;
  };
  return setIntersection;
}
var hasRequiredEs_set_intersection_v2;
function requireEs_set_intersection_v2() {
  if (hasRequiredEs_set_intersection_v2) return es_set_intersection_v2;
  hasRequiredEs_set_intersection_v2 = 1;
  var $ = require_export();
  var fails2 = requireFails();
  var intersection = requireSetIntersection();
  var setMethodAcceptSetLike2 = requireSetMethodAcceptSetLike();
  var INCORRECT = !setMethodAcceptSetLike2("intersection", function(result) {
    return result.size === 2 && result.has(1) && result.has(2);
  }) || fails2(function() {
    return String(Array.from((/* @__PURE__ */ new Set([1, 2, 3])).intersection(/* @__PURE__ */ new Set([3, 2])))) !== "3,2";
  });
  $({ target: "Set", proto: true, real: true, forced: INCORRECT }, {
    intersection
  });
  return es_set_intersection_v2;
}
var es_set_isDisjointFrom_v2 = {};
var setIsDisjointFrom;
var hasRequiredSetIsDisjointFrom;
function requireSetIsDisjointFrom() {
  if (hasRequiredSetIsDisjointFrom) return setIsDisjointFrom;
  hasRequiredSetIsDisjointFrom = 1;
  var aSet2 = requireASet();
  var has = requireSetHelpers().has;
  var size = requireSetSize();
  var getSetRecord2 = requireGetSetRecord();
  var iterateSet = requireSetIterate();
  var iterateSimple2 = requireIterateSimple();
  var iteratorClose2 = requireIteratorClose();
  setIsDisjointFrom = function isDisjointFrom(other) {
    var O = aSet2(this);
    var otherRec = getSetRecord2(other);
    if (size(O) <= otherRec.size) return iterateSet(O, function(e) {
      if (otherRec.includes(e)) return false;
    }, true) !== false;
    var iterator2 = otherRec.getIterator();
    return iterateSimple2(iterator2, function(e) {
      if (has(O, e)) return iteratorClose2(iterator2, "normal", false);
    }) !== false;
  };
  return setIsDisjointFrom;
}
var hasRequiredEs_set_isDisjointFrom_v2;
function requireEs_set_isDisjointFrom_v2() {
  if (hasRequiredEs_set_isDisjointFrom_v2) return es_set_isDisjointFrom_v2;
  hasRequiredEs_set_isDisjointFrom_v2 = 1;
  var $ = require_export();
  var isDisjointFrom = requireSetIsDisjointFrom();
  var setMethodAcceptSetLike2 = requireSetMethodAcceptSetLike();
  var INCORRECT = !setMethodAcceptSetLike2("isDisjointFrom", function(result) {
    return !result;
  });
  $({ target: "Set", proto: true, real: true, forced: INCORRECT }, {
    isDisjointFrom
  });
  return es_set_isDisjointFrom_v2;
}
var es_set_isSubsetOf_v2 = {};
var setIsSubsetOf;
var hasRequiredSetIsSubsetOf;
function requireSetIsSubsetOf() {
  if (hasRequiredSetIsSubsetOf) return setIsSubsetOf;
  hasRequiredSetIsSubsetOf = 1;
  var aSet2 = requireASet();
  var size = requireSetSize();
  var iterate2 = requireSetIterate();
  var getSetRecord2 = requireGetSetRecord();
  setIsSubsetOf = function isSubsetOf(other) {
    var O = aSet2(this);
    var otherRec = getSetRecord2(other);
    if (size(O) > otherRec.size) return false;
    return iterate2(O, function(e) {
      if (!otherRec.includes(e)) return false;
    }, true) !== false;
  };
  return setIsSubsetOf;
}
var hasRequiredEs_set_isSubsetOf_v2;
function requireEs_set_isSubsetOf_v2() {
  if (hasRequiredEs_set_isSubsetOf_v2) return es_set_isSubsetOf_v2;
  hasRequiredEs_set_isSubsetOf_v2 = 1;
  var $ = require_export();
  var isSubsetOf = requireSetIsSubsetOf();
  var setMethodAcceptSetLike2 = requireSetMethodAcceptSetLike();
  var INCORRECT = !setMethodAcceptSetLike2("isSubsetOf", function(result) {
    return result;
  });
  $({ target: "Set", proto: true, real: true, forced: INCORRECT }, {
    isSubsetOf
  });
  return es_set_isSubsetOf_v2;
}
var es_set_isSupersetOf_v2 = {};
var setIsSupersetOf;
var hasRequiredSetIsSupersetOf;
function requireSetIsSupersetOf() {
  if (hasRequiredSetIsSupersetOf) return setIsSupersetOf;
  hasRequiredSetIsSupersetOf = 1;
  var aSet2 = requireASet();
  var has = requireSetHelpers().has;
  var size = requireSetSize();
  var getSetRecord2 = requireGetSetRecord();
  var iterateSimple2 = requireIterateSimple();
  var iteratorClose2 = requireIteratorClose();
  setIsSupersetOf = function isSupersetOf(other) {
    var O = aSet2(this);
    var otherRec = getSetRecord2(other);
    if (size(O) < otherRec.size) return false;
    var iterator2 = otherRec.getIterator();
    return iterateSimple2(iterator2, function(e) {
      if (!has(O, e)) return iteratorClose2(iterator2, "normal", false);
    }) !== false;
  };
  return setIsSupersetOf;
}
var hasRequiredEs_set_isSupersetOf_v2;
function requireEs_set_isSupersetOf_v2() {
  if (hasRequiredEs_set_isSupersetOf_v2) return es_set_isSupersetOf_v2;
  hasRequiredEs_set_isSupersetOf_v2 = 1;
  var $ = require_export();
  var isSupersetOf = requireSetIsSupersetOf();
  var setMethodAcceptSetLike2 = requireSetMethodAcceptSetLike();
  var INCORRECT = !setMethodAcceptSetLike2("isSupersetOf", function(result) {
    return !result;
  });
  $({ target: "Set", proto: true, real: true, forced: INCORRECT }, {
    isSupersetOf
  });
  return es_set_isSupersetOf_v2;
}
var es_set_symmetricDifference_v2 = {};
var setSymmetricDifference;
var hasRequiredSetSymmetricDifference;
function requireSetSymmetricDifference() {
  if (hasRequiredSetSymmetricDifference) return setSymmetricDifference;
  hasRequiredSetSymmetricDifference = 1;
  var aSet2 = requireASet();
  var SetHelpers = requireSetHelpers();
  var clone2 = requireSetClone();
  var getSetRecord2 = requireGetSetRecord();
  var iterateSimple2 = requireIterateSimple();
  var add = SetHelpers.add;
  var has = SetHelpers.has;
  var remove = SetHelpers.remove;
  setSymmetricDifference = function symmetricDifference(other) {
    var O = aSet2(this);
    var keysIter = getSetRecord2(other).getIterator();
    var result = clone2(O);
    iterateSimple2(keysIter, function(e) {
      if (has(O, e)) remove(result, e);
      else add(result, e);
    });
    return result;
  };
  return setSymmetricDifference;
}
var setMethodGetKeysBeforeCloningDetection;
var hasRequiredSetMethodGetKeysBeforeCloningDetection;
function requireSetMethodGetKeysBeforeCloningDetection() {
  if (hasRequiredSetMethodGetKeysBeforeCloningDetection) return setMethodGetKeysBeforeCloningDetection;
  hasRequiredSetMethodGetKeysBeforeCloningDetection = 1;
  setMethodGetKeysBeforeCloningDetection = function(METHOD_NAME) {
    try {
      var baseSet = /* @__PURE__ */ new Set();
      var setLike = {
        size: 0,
        has: function() {
          return true;
        },
        keys: function() {
          return Object.defineProperty({}, "next", {
            get: function() {
              baseSet.clear();
              baseSet.add(4);
              return function() {
                return { done: true };
              };
            }
          });
        }
      };
      var result = baseSet[METHOD_NAME](setLike);
      return result.size === 1 && result.values().next().value === 4;
    } catch (error) {
      return false;
    }
  };
  return setMethodGetKeysBeforeCloningDetection;
}
var hasRequiredEs_set_symmetricDifference_v2;
function requireEs_set_symmetricDifference_v2() {
  if (hasRequiredEs_set_symmetricDifference_v2) return es_set_symmetricDifference_v2;
  hasRequiredEs_set_symmetricDifference_v2 = 1;
  var $ = require_export();
  var symmetricDifference = requireSetSymmetricDifference();
  var setMethodGetKeysBeforeCloning = requireSetMethodGetKeysBeforeCloningDetection();
  var setMethodAcceptSetLike2 = requireSetMethodAcceptSetLike();
  var FORCED = !setMethodAcceptSetLike2("symmetricDifference") || !setMethodGetKeysBeforeCloning("symmetricDifference");
  $({ target: "Set", proto: true, real: true, forced: FORCED }, {
    symmetricDifference
  });
  return es_set_symmetricDifference_v2;
}
var es_set_union_v2 = {};
var setUnion;
var hasRequiredSetUnion;
function requireSetUnion() {
  if (hasRequiredSetUnion) return setUnion;
  hasRequiredSetUnion = 1;
  var aSet2 = requireASet();
  var add = requireSetHelpers().add;
  var clone2 = requireSetClone();
  var getSetRecord2 = requireGetSetRecord();
  var iterateSimple2 = requireIterateSimple();
  setUnion = function union(other) {
    var O = aSet2(this);
    var keysIter = getSetRecord2(other).getIterator();
    var result = clone2(O);
    iterateSimple2(keysIter, function(it2) {
      add(result, it2);
    });
    return result;
  };
  return setUnion;
}
var hasRequiredEs_set_union_v2;
function requireEs_set_union_v2() {
  if (hasRequiredEs_set_union_v2) return es_set_union_v2;
  hasRequiredEs_set_union_v2 = 1;
  var $ = require_export();
  var union = requireSetUnion();
  var setMethodGetKeysBeforeCloning = requireSetMethodGetKeysBeforeCloningDetection();
  var setMethodAcceptSetLike2 = requireSetMethodAcceptSetLike();
  var FORCED = !setMethodAcceptSetLike2("union") || !setMethodGetKeysBeforeCloning("union");
  $({ target: "Set", proto: true, real: true, forced: FORCED }, {
    union
  });
  return es_set_union_v2;
}
var set$2;
var hasRequiredSet$2;
function requireSet$2() {
  if (hasRequiredSet$2) return set$2;
  hasRequiredSet$2 = 1;
  requireEs_array_iterator();
  requireEs_set();
  requireEs_set_difference_v2();
  requireEs_set_intersection_v2();
  requireEs_set_isDisjointFrom_v2();
  requireEs_set_isSubsetOf_v2();
  requireEs_set_isSupersetOf_v2();
  requireEs_set_symmetricDifference_v2();
  requireEs_set_union_v2();
  requireEs_string_iterator();
  var path2 = requirePath();
  set$2 = path2.Set;
  return set$2;
}
var set$1;
var hasRequiredSet$1;
function requireSet$1() {
  if (hasRequiredSet$1) return set$1;
  hasRequiredSet$1 = 1;
  var parent = requireSet$2();
  requireWeb_domCollections_iterator();
  set$1 = parent;
  return set$1;
}
var set;
var hasRequiredSet;
function requireSet() {
  if (hasRequiredSet) return set;
  hasRequiredSet = 1;
  set = requireSet$1();
  return set;
}
var setExports = requireSet();
var _Set = getDefaultExportFromCjs(setExports);
var getIterator_1;
var hasRequiredGetIterator$5;
function requireGetIterator$5() {
  if (hasRequiredGetIterator$5) return getIterator_1;
  hasRequiredGetIterator$5 = 1;
  requireEs_array_iterator();
  requireEs_string_iterator();
  var getIterator2 = requireGetIterator$6();
  getIterator_1 = getIterator2;
  return getIterator_1;
}
var getIterator$4;
var hasRequiredGetIterator$4;
function requireGetIterator$4() {
  if (hasRequiredGetIterator$4) return getIterator$4;
  hasRequiredGetIterator$4 = 1;
  var parent = requireGetIterator$5();
  requireWeb_domCollections_iterator();
  getIterator$4 = parent;
  return getIterator$4;
}
var getIterator$3;
var hasRequiredGetIterator$3;
function requireGetIterator$3() {
  if (hasRequiredGetIterator$3) return getIterator$3;
  hasRequiredGetIterator$3 = 1;
  var parent = requireGetIterator$4();
  getIterator$3 = parent;
  return getIterator$3;
}
var getIterator$2;
var hasRequiredGetIterator$2;
function requireGetIterator$2() {
  if (hasRequiredGetIterator$2) return getIterator$2;
  hasRequiredGetIterator$2 = 1;
  var parent = requireGetIterator$3();
  getIterator$2 = parent;
  return getIterator$2;
}
var getIterator$1;
var hasRequiredGetIterator$1;
function requireGetIterator$1() {
  if (hasRequiredGetIterator$1) return getIterator$1;
  hasRequiredGetIterator$1 = 1;
  getIterator$1 = requireGetIterator$2();
  return getIterator$1;
}
var getIterator;
var hasRequiredGetIterator;
function requireGetIterator() {
  if (hasRequiredGetIterator) return getIterator;
  hasRequiredGetIterator = 1;
  getIterator = requireGetIterator$1();
  return getIterator;
}
var getIteratorExports = requireGetIterator();
var _getIterator = getDefaultExportFromCjs(getIteratorExports);
var es_array_sort = {};
var arraySort;
var hasRequiredArraySort;
function requireArraySort() {
  if (hasRequiredArraySort) return arraySort;
  hasRequiredArraySort = 1;
  var arraySlice2 = requireArraySlice();
  var floor = Math.floor;
  var sort2 = function(array2, comparefn) {
    var length = array2.length;
    if (length < 8) {
      var i = 1;
      var element, j;
      while (i < length) {
        j = i;
        element = array2[i];
        while (j && comparefn(array2[j - 1], element) > 0) {
          array2[j] = array2[--j];
        }
        if (j !== i++) array2[j] = element;
      }
    } else {
      var middle = floor(length / 2);
      var left = sort2(arraySlice2(array2, 0, middle), comparefn);
      var right = sort2(arraySlice2(array2, middle), comparefn);
      var llength = left.length;
      var rlength = right.length;
      var lindex = 0;
      var rindex = 0;
      while (lindex < llength || rindex < rlength) {
        array2[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
      }
    }
    return array2;
  };
  arraySort = sort2;
  return arraySort;
}
var environmentFfVersion;
var hasRequiredEnvironmentFfVersion;
function requireEnvironmentFfVersion() {
  if (hasRequiredEnvironmentFfVersion) return environmentFfVersion;
  hasRequiredEnvironmentFfVersion = 1;
  var userAgent = requireEnvironmentUserAgent();
  var firefox = userAgent.match(/firefox\/(\d+)/i);
  environmentFfVersion = !!firefox && +firefox[1];
  return environmentFfVersion;
}
var environmentIsIeOrEdge;
var hasRequiredEnvironmentIsIeOrEdge;
function requireEnvironmentIsIeOrEdge() {
  if (hasRequiredEnvironmentIsIeOrEdge) return environmentIsIeOrEdge;
  hasRequiredEnvironmentIsIeOrEdge = 1;
  var UA = requireEnvironmentUserAgent();
  environmentIsIeOrEdge = /MSIE|Trident/.test(UA);
  return environmentIsIeOrEdge;
}
var environmentWebkitVersion;
var hasRequiredEnvironmentWebkitVersion;
function requireEnvironmentWebkitVersion() {
  if (hasRequiredEnvironmentWebkitVersion) return environmentWebkitVersion;
  hasRequiredEnvironmentWebkitVersion = 1;
  var userAgent = requireEnvironmentUserAgent();
  var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
  environmentWebkitVersion = !!webkit && +webkit[1];
  return environmentWebkitVersion;
}
var hasRequiredEs_array_sort;
function requireEs_array_sort() {
  if (hasRequiredEs_array_sort) return es_array_sort;
  hasRequiredEs_array_sort = 1;
  var $ = require_export();
  var uncurryThis = requireFunctionUncurryThis();
  var aCallable2 = requireACallable();
  var toObject2 = requireToObject();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var deletePropertyOrThrow2 = requireDeletePropertyOrThrow();
  var toString2 = requireToString();
  var fails2 = requireFails();
  var internalSort = requireArraySort();
  var arrayMethodIsStrict2 = requireArrayMethodIsStrict();
  var FF = requireEnvironmentFfVersion();
  var IE_OR_EDGE = requireEnvironmentIsIeOrEdge();
  var V8 = requireEnvironmentV8Version();
  var WEBKIT = requireEnvironmentWebkitVersion();
  var test = [];
  var nativeSort = uncurryThis(test.sort);
  var push = uncurryThis(test.push);
  var FAILS_ON_UNDEFINED = fails2(function() {
    test.sort(void 0);
  });
  var FAILS_ON_NULL = fails2(function() {
    test.sort(null);
  });
  var STRICT_METHOD = arrayMethodIsStrict2("sort");
  var STABLE_SORT = !fails2(function() {
    if (V8) return V8 < 70;
    if (FF && FF > 3) return;
    if (IE_OR_EDGE) return true;
    if (WEBKIT) return WEBKIT < 603;
    var result = "";
    var code, chr, value, index;
    for (code = 65; code < 76; code++) {
      chr = String.fromCharCode(code);
      switch (code) {
        case 66:
        case 69:
        case 70:
        case 72:
          value = 3;
          break;
        case 68:
        case 71:
          value = 4;
          break;
        default:
          value = 2;
      }
      for (index = 0; index < 47; index++) {
        test.push({ k: chr + index, v: value });
      }
    }
    test.sort(function(a, b) {
      return b.v - a.v;
    });
    for (index = 0; index < test.length; index++) {
      chr = test[index].k.charAt(0);
      if (result.charAt(result.length - 1) !== chr) result += chr;
    }
    return result !== "DGBEFHACIJK";
  });
  var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;
  var getSortCompare = function(comparefn) {
    return function(x, y) {
      if (y === void 0) return -1;
      if (x === void 0) return 1;
      if (comparefn !== void 0) return +comparefn(x, y) || 0;
      return toString2(x) > toString2(y) ? 1 : -1;
    };
  };
  $({ target: "Array", proto: true, forced: FORCED }, {
    sort: function sort2(comparefn) {
      if (comparefn !== void 0) aCallable2(comparefn);
      var array2 = toObject2(this);
      if (STABLE_SORT) return comparefn === void 0 ? nativeSort(array2) : nativeSort(array2, comparefn);
      var items = [];
      var arrayLength = lengthOfArrayLike2(array2);
      var itemsLength, index;
      for (index = 0; index < arrayLength; index++) {
        if (index in array2) push(items, array2[index]);
      }
      internalSort(items, getSortCompare(comparefn));
      itemsLength = lengthOfArrayLike2(items);
      index = 0;
      while (index < itemsLength) array2[index] = items[index++];
      while (index < arrayLength) deletePropertyOrThrow2(array2, index++);
      return array2;
    }
  });
  return es_array_sort;
}
var sort$3;
var hasRequiredSort$3;
function requireSort$3() {
  if (hasRequiredSort$3) return sort$3;
  hasRequiredSort$3 = 1;
  requireEs_array_sort();
  var getBuiltInPrototypeMethod2 = requireGetBuiltInPrototypeMethod();
  sort$3 = getBuiltInPrototypeMethod2("Array", "sort");
  return sort$3;
}
var sort$2;
var hasRequiredSort$2;
function requireSort$2() {
  if (hasRequiredSort$2) return sort$2;
  hasRequiredSort$2 = 1;
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var method = requireSort$3();
  var ArrayPrototype = Array.prototype;
  sort$2 = function(it2) {
    var own = it2.sort;
    return it2 === ArrayPrototype || isPrototypeOf(ArrayPrototype, it2) && own === ArrayPrototype.sort ? method : own;
  };
  return sort$2;
}
var sort$1;
var hasRequiredSort$1;
function requireSort$1() {
  if (hasRequiredSort$1) return sort$1;
  hasRequiredSort$1 = 1;
  var parent = requireSort$2();
  sort$1 = parent;
  return sort$1;
}
var sort;
var hasRequiredSort;
function requireSort() {
  if (hasRequiredSort) return sort;
  hasRequiredSort = 1;
  sort = requireSort$1();
  return sort;
}
var sortExports = requireSort();
var _sortInstanceProperty = getDefaultExportFromCjs(sortExports);
var es_array_some = {};
var hasRequiredEs_array_some;
function requireEs_array_some() {
  if (hasRequiredEs_array_some) return es_array_some;
  hasRequiredEs_array_some = 1;
  var $ = require_export();
  var $some = requireArrayIteration().some;
  var arrayMethodIsStrict2 = requireArrayMethodIsStrict();
  var STRICT_METHOD = arrayMethodIsStrict2("some");
  $({ target: "Array", proto: true, forced: !STRICT_METHOD }, {
    some: function some2(callbackfn) {
      return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    }
  });
  return es_array_some;
}
var some$3;
var hasRequiredSome$3;
function requireSome$3() {
  if (hasRequiredSome$3) return some$3;
  hasRequiredSome$3 = 1;
  requireEs_array_some();
  var getBuiltInPrototypeMethod2 = requireGetBuiltInPrototypeMethod();
  some$3 = getBuiltInPrototypeMethod2("Array", "some");
  return some$3;
}
var some$2;
var hasRequiredSome$2;
function requireSome$2() {
  if (hasRequiredSome$2) return some$2;
  hasRequiredSome$2 = 1;
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var method = requireSome$3();
  var ArrayPrototype = Array.prototype;
  some$2 = function(it2) {
    var own = it2.some;
    return it2 === ArrayPrototype || isPrototypeOf(ArrayPrototype, it2) && own === ArrayPrototype.some ? method : own;
  };
  return some$2;
}
var some$1;
var hasRequiredSome$1;
function requireSome$1() {
  if (hasRequiredSome$1) return some$1;
  hasRequiredSome$1 = 1;
  var parent = requireSome$2();
  some$1 = parent;
  return some$1;
}
var some;
var hasRequiredSome;
function requireSome() {
  if (hasRequiredSome) return some;
  hasRequiredSome = 1;
  some = requireSome$1();
  return some;
}
var someExports = requireSome();
var _someInstanceProperty = getDefaultExportFromCjs(someExports);
var keys$3;
var hasRequiredKeys$3;
function requireKeys$3() {
  if (hasRequiredKeys$3) return keys$3;
  hasRequiredKeys$3 = 1;
  requireEs_array_iterator();
  var getBuiltInPrototypeMethod2 = requireGetBuiltInPrototypeMethod();
  keys$3 = getBuiltInPrototypeMethod2("Array", "keys");
  return keys$3;
}
var keys$2;
var hasRequiredKeys$2;
function requireKeys$2() {
  if (hasRequiredKeys$2) return keys$2;
  hasRequiredKeys$2 = 1;
  var parent = requireKeys$3();
  keys$2 = parent;
  return keys$2;
}
var keys$1;
var hasRequiredKeys$1;
function requireKeys$1() {
  if (hasRequiredKeys$1) return keys$1;
  hasRequiredKeys$1 = 1;
  requireWeb_domCollections_iterator();
  var classof2 = requireClassof();
  var hasOwn = requireHasOwnProperty();
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var method = requireKeys$2();
  var ArrayPrototype = Array.prototype;
  var DOMIterables = {
    DOMTokenList: true,
    NodeList: true
  };
  keys$1 = function(it2) {
    var own = it2.keys;
    return it2 === ArrayPrototype || isPrototypeOf(ArrayPrototype, it2) && own === ArrayPrototype.keys || hasOwn(DOMIterables, classof2(it2)) ? method : own;
  };
  return keys$1;
}
var keys;
var hasRequiredKeys;
function requireKeys() {
  if (hasRequiredKeys) return keys;
  hasRequiredKeys = 1;
  keys = requireKeys$1();
  return keys;
}
var keysExports = requireKeys();
var _keysInstanceProperty = getDefaultExportFromCjs(keysExports);
var values$3;
var hasRequiredValues$3;
function requireValues$3() {
  if (hasRequiredValues$3) return values$3;
  hasRequiredValues$3 = 1;
  requireEs_array_iterator();
  var getBuiltInPrototypeMethod2 = requireGetBuiltInPrototypeMethod();
  values$3 = getBuiltInPrototypeMethod2("Array", "values");
  return values$3;
}
var values$2;
var hasRequiredValues$2;
function requireValues$2() {
  if (hasRequiredValues$2) return values$2;
  hasRequiredValues$2 = 1;
  var parent = requireValues$3();
  values$2 = parent;
  return values$2;
}
var values$1;
var hasRequiredValues$1;
function requireValues$1() {
  if (hasRequiredValues$1) return values$1;
  hasRequiredValues$1 = 1;
  requireWeb_domCollections_iterator();
  var classof2 = requireClassof();
  var hasOwn = requireHasOwnProperty();
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var method = requireValues$2();
  var ArrayPrototype = Array.prototype;
  var DOMIterables = {
    DOMTokenList: true,
    NodeList: true
  };
  values$1 = function(it2) {
    var own = it2.values;
    return it2 === ArrayPrototype || isPrototypeOf(ArrayPrototype, it2) && own === ArrayPrototype.values || hasOwn(DOMIterables, classof2(it2)) ? method : own;
  };
  return values$1;
}
var values;
var hasRequiredValues;
function requireValues() {
  if (hasRequiredValues) return values;
  hasRequiredValues = 1;
  values = requireValues$1();
  return values;
}
var valuesExports = requireValues();
var _valuesInstanceProperty = getDefaultExportFromCjs(valuesExports);
var entries$3;
var hasRequiredEntries$3;
function requireEntries$3() {
  if (hasRequiredEntries$3) return entries$3;
  hasRequiredEntries$3 = 1;
  requireEs_array_iterator();
  var getBuiltInPrototypeMethod2 = requireGetBuiltInPrototypeMethod();
  entries$3 = getBuiltInPrototypeMethod2("Array", "entries");
  return entries$3;
}
var entries$2;
var hasRequiredEntries$2;
function requireEntries$2() {
  if (hasRequiredEntries$2) return entries$2;
  hasRequiredEntries$2 = 1;
  var parent = requireEntries$3();
  entries$2 = parent;
  return entries$2;
}
var entries$1;
var hasRequiredEntries$1;
function requireEntries$1() {
  if (hasRequiredEntries$1) return entries$1;
  hasRequiredEntries$1 = 1;
  requireWeb_domCollections_iterator();
  var classof2 = requireClassof();
  var hasOwn = requireHasOwnProperty();
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var method = requireEntries$2();
  var ArrayPrototype = Array.prototype;
  var DOMIterables = {
    DOMTokenList: true,
    NodeList: true
  };
  entries$1 = function(it2) {
    var own = it2.entries;
    return it2 === ArrayPrototype || isPrototypeOf(ArrayPrototype, it2) && own === ArrayPrototype.entries || hasOwn(DOMIterables, classof2(it2)) ? method : own;
  };
  return entries$1;
}
var entries;
var hasRequiredEntries;
function requireEntries() {
  if (hasRequiredEntries) return entries;
  hasRequiredEntries = 1;
  entries = requireEntries$1();
  return entries;
}
var entriesExports = requireEntries();
var _entriesInstanceProperty = getDefaultExportFromCjs(entriesExports);
var defineProperty;
var hasRequiredDefineProperty;
function requireDefineProperty() {
  if (hasRequiredDefineProperty) return defineProperty;
  hasRequiredDefineProperty = 1;
  defineProperty = requireDefineProperty$4();
  return defineProperty;
}
var definePropertyExports = requireDefineProperty();
var _Object$defineProperty = getDefaultExportFromCjs(definePropertyExports);
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native = { randomUUID };
function _v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random ?? options.rng?.() ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return unsafeStringify(rnds);
}
function v4(options, buf, offset) {
  if (native.randomUUID && true && !options) {
    return native.randomUUID();
  }
  return _v4(options);
}
function ownKeys$1(e, r) {
  var t = _Object$keys(e);
  if (_Object$getOwnPropertySymbols) {
    var o = _Object$getOwnPropertySymbols(e);
    r && (o = _filterInstanceProperty(o).call(o, function(r2) {
      return _Object$getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$1(e) {
  for (var r = 1; r < arguments.length; r++) {
    var _context21, _context22;
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? _forEachInstanceProperty(_context21 = ownKeys$1(Object(t), true)).call(_context21, function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : _forEachInstanceProperty(_context22 = ownKeys$1(Object(t))).call(_context22, function(r2) {
      _Object$defineProperty(e, r2, _Object$getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function createNewDataPipeFrom(from) {
  return new DataPipeUnderConstruction(from);
}
var SimpleDataPipe = class {
  /**
   * Create a new data pipe.
   * @param source - The data set or data view that will be observed.
   * @param transformers - An array of transforming functions to be used to
   * filter or transform the items in the pipe.
   * @param target - The data set or data view that will receive the items.
   */
  constructor(source, transformers, target) {
    var _context, _context2, _context3;
    _defineProperty(this, "_source", void 0);
    _defineProperty(this, "_transformers", void 0);
    _defineProperty(this, "_target", void 0);
    _defineProperty(this, "_listeners", {
      add: _bindInstanceProperty(_context = this._add).call(_context, this),
      remove: _bindInstanceProperty(_context2 = this._remove).call(_context2, this),
      update: _bindInstanceProperty(_context3 = this._update).call(_context3, this)
    });
    this._source = source;
    this._transformers = transformers;
    this._target = target;
  }
  /** @inheritDoc */
  all() {
    this._target.update(this._transformItems(this._source.get()));
    return this;
  }
  /** @inheritDoc */
  start() {
    this._source.on("add", this._listeners.add);
    this._source.on("remove", this._listeners.remove);
    this._source.on("update", this._listeners.update);
    return this;
  }
  /** @inheritDoc */
  stop() {
    this._source.off("add", this._listeners.add);
    this._source.off("remove", this._listeners.remove);
    this._source.off("update", this._listeners.update);
    return this;
  }
  /**
   * Apply the transformers to the items.
   * @param items - The items to be transformed.
   * @returns The transformed items.
   */
  _transformItems(items) {
    var _context4;
    return _reduceInstanceProperty(_context4 = this._transformers).call(_context4, (items2, transform) => {
      return transform(items2);
    }, items);
  }
  /**
   * Handle an add event.
   * @param _name - Ignored.
   * @param payload - The payload containing the ids of the added items.
   */
  _add(_name, payload) {
    if (payload == null) {
      return;
    }
    this._target.add(this._transformItems(this._source.get(payload.items)));
  }
  /**
   * Handle an update event.
   * @param _name - Ignored.
   * @param payload - The payload containing the ids of the updated items.
   */
  _update(_name, payload) {
    if (payload == null) {
      return;
    }
    this._target.update(this._transformItems(this._source.get(payload.items)));
  }
  /**
   * Handle a remove event.
   * @param _name - Ignored.
   * @param payload - The payload containing the data of the removed items.
   */
  _remove(_name, payload) {
    if (payload == null) {
      return;
    }
    this._target.remove(this._transformItems(payload.oldData));
  }
};
var DataPipeUnderConstruction = class {
  /**
   * Create a new data pipe factory. This is an internal constructor that
   * should never be called from outside of this file.
   * @param source - The source data set or data view for this pipe.
   */
  constructor(source) {
    _defineProperty(this, "_source", void 0);
    _defineProperty(this, "_transformers", []);
    this._source = source;
  }
  /**
   * Filter the items.
   * @param callback - A filtering function that returns true if given item
   * should be piped and false if not.
   * @returns This factory for further configuration.
   */
  filter(callback) {
    this._transformers.push((input) => _filterInstanceProperty(input).call(input, callback));
    return this;
  }
  /**
   * Map each source item to a new type.
   * @param callback - A mapping function that takes a source item and returns
   * corresponding mapped item.
   * @typeParam TI - Target item type.
   * @typeParam TP - Target item type's id property name.
   * @returns This factory for further configuration.
   */
  map(callback) {
    this._transformers.push((input) => _mapInstanceProperty(input).call(input, callback));
    return this;
  }
  /**
   * Map each source item to zero or more items of a new type.
   * @param callback - A mapping function that takes a source item and returns
   * an array of corresponding mapped items.
   * @typeParam TI - Target item type.
   * @typeParam TP - Target item type's id property name.
   * @returns This factory for further configuration.
   */
  flatMap(callback) {
    this._transformers.push((input) => _flatMapInstanceProperty(input).call(input, callback));
    return this;
  }
  /**
   * Connect this pipe to given data set.
   * @param target - The data set that will receive the items from this pipe.
   * @returns The pipe connected between given data sets and performing
   * configured transformation on the processed items.
   */
  to(target) {
    return new SimpleDataPipe(this._source, this._transformers, target);
  }
};
function isId(value) {
  return typeof value === "string" || typeof value === "number";
}
var Queue = class _Queue {
  /**
   * Construct a new Queue.
   * @param options - Queue configuration.
   */
  constructor(options) {
    _defineProperty(this, "delay", void 0);
    _defineProperty(this, "max", void 0);
    _defineProperty(this, "_queue", []);
    _defineProperty(this, "_timeout", null);
    _defineProperty(this, "_extended", null);
    this.delay = null;
    this.max = Infinity;
    this.setOptions(options);
  }
  /**
   * Update the configuration of the queue.
   * @param options - Queue configuration.
   */
  setOptions(options) {
    if (options && typeof options.delay !== "undefined") {
      this.delay = options.delay;
    }
    if (options && typeof options.max !== "undefined") {
      this.max = options.max;
    }
    this._flushIfNeeded();
  }
  /**
   * Extend an object with queuing functionality.
   * The object will be extended with a function flush, and the methods provided in options.replace will be replaced with queued ones.
   * @param object - The object to be extended.
   * @param options - Additional options.
   * @returns The created queue.
   */
  static extend(object2, options) {
    const queue = new _Queue(options);
    if (object2.flush !== void 0) {
      throw new Error("Target object already has a property flush");
    }
    object2.flush = () => {
      queue.flush();
    };
    const methods = [{
      name: "flush",
      original: void 0
    }];
    if (options && options.replace) {
      for (let i = 0; i < options.replace.length; i++) {
        const name = options.replace[i];
        methods.push({
          name,
          // @TODO: better solution?
          original: object2[name]
        });
        queue.replace(object2, name);
      }
    }
    queue._extended = {
      object: object2,
      methods
    };
    return queue;
  }
  /**
   * Destroy the queue. The queue will first flush all queued actions, and in case it has extended an object, will restore the original object.
   */
  destroy() {
    this.flush();
    if (this._extended) {
      const object2 = this._extended.object;
      const methods = this._extended.methods;
      for (let i = 0; i < methods.length; i++) {
        const method = methods[i];
        if (method.original) {
          object2[method.name] = method.original;
        } else {
          delete object2[method.name];
        }
      }
      this._extended = null;
    }
  }
  /**
   * Replace a method on an object with a queued version.
   * @param object - Object having the method.
   * @param method - The method name.
   */
  replace(object2, method) {
    const me = this;
    const original = object2[method];
    if (!original) {
      throw new Error("Method " + method + " undefined");
    }
    object2[method] = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      me.queue({
        args,
        fn: original,
        context: this
      });
    };
  }
  /**
   * Queue a call.
   * @param entry - The function or entry to be queued.
   */
  queue(entry) {
    if (typeof entry === "function") {
      this._queue.push({
        fn: entry
      });
    } else {
      this._queue.push(entry);
    }
    this._flushIfNeeded();
  }
  /**
   * Check whether the queue needs to be flushed.
   */
  _flushIfNeeded() {
    if (this._queue.length > this.max) {
      this.flush();
    }
    if (this._timeout != null) {
      clearTimeout(this._timeout);
      this._timeout = null;
    }
    if (this.queue.length > 0 && typeof this.delay === "number") {
      this._timeout = _setTimeout(() => {
        this.flush();
      }, this.delay);
    }
  }
  /**
   * Flush all queued calls
   */
  flush() {
    var _context5, _context6;
    _forEachInstanceProperty(_context5 = _spliceInstanceProperty(_context6 = this._queue).call(_context6, 0)).call(_context5, (entry) => {
      entry.fn.apply(entry.context || entry.fn, entry.args || []);
    });
  }
};
var DataSetPart = class _DataSetPart {
  constructor() {
    _defineProperty(this, "_subscribers", {
      "*": [],
      add: [],
      remove: [],
      update: []
    });
    _defineProperty(this, "subscribe", _DataSetPart.prototype.on);
    _defineProperty(this, "unsubscribe", _DataSetPart.prototype.off);
  }
  /**
   * Trigger an event
   * @param event - Event name.
   * @param payload - Event payload.
   * @param senderId - Id of the sender.
   */
  _trigger(event2, payload, senderId) {
    var _context7;
    if (event2 === "*") {
      throw new Error("Cannot trigger event *");
    }
    _forEachInstanceProperty(_context7 = [...this._subscribers[event2], ...this._subscribers["*"]]).call(_context7, (subscriber) => {
      subscriber(event2, payload, senderId != null ? senderId : null);
    });
  }
  /**
   * Subscribe to an event, add an event listener.
   * @remarks Non-function callbacks are ignored.
   * @param event - Event name.
   * @param callback - Callback method.
   */
  on(event2, callback) {
    if (typeof callback === "function") {
      this._subscribers[event2].push(callback);
    }
  }
  /**
   * Unsubscribe from an event, remove an event listener.
   * @remarks If the same callback was subscribed more than once **all** occurences will be removed.
   * @param event - Event name.
   * @param callback - Callback method.
   */
  off(event2, callback) {
    var _context8;
    this._subscribers[event2] = _filterInstanceProperty(_context8 = this._subscribers[event2]).call(_context8, (subscriber) => subscriber !== callback);
  }
};
var DataStream = class _DataStream {
  /**
   * Create a new data stream.
   * @param pairs - The id, item pairs.
   */
  constructor(pairs) {
    _defineProperty(this, "_pairs", void 0);
    this._pairs = pairs;
  }
  /**
   * Return an iterable of key, value pairs for every entry in the stream.
   */
  *[_Symbol$iterator]() {
    for (const [id, item] of this._pairs) {
      yield [id, item];
    }
  }
  /**
   * Return an iterable of key, value pairs for every entry in the stream.
   */
  *entries() {
    for (const [id, item] of this._pairs) {
      yield [id, item];
    }
  }
  /**
   * Return an iterable of keys in the stream.
   */
  *keys() {
    for (const [id] of this._pairs) {
      yield id;
    }
  }
  /**
   * Return an iterable of values in the stream.
   */
  *values() {
    for (const [, item] of this._pairs) {
      yield item;
    }
  }
  /**
   * Return an array containing all the ids in this stream.
   * @remarks
   * The array may contain duplicities.
   * @returns The array with all ids from this stream.
   */
  toIdArray() {
    var _context9;
    return _mapInstanceProperty(_context9 = [...this._pairs]).call(_context9, (pair) => pair[0]);
  }
  /**
   * Return an array containing all the items in this stream.
   * @remarks
   * The array may contain duplicities.
   * @returns The array with all items from this stream.
   */
  toItemArray() {
    var _context0;
    return _mapInstanceProperty(_context0 = [...this._pairs]).call(_context0, (pair) => pair[1]);
  }
  /**
   * Return an array containing all the entries in this stream.
   * @remarks
   * The array may contain duplicities.
   * @returns The array with all entries from this stream.
   */
  toEntryArray() {
    return [...this._pairs];
  }
  /**
   * Return an object map containing all the items in this stream accessible by ids.
   * @remarks
   * In case of duplicate ids (coerced to string so `7 == '7'`) the last encoutered appears in the returned object.
   * @returns The object map of all id  item pairs from this stream.
   */
  toObjectMap() {
    const map2 = _Object$create(null);
    for (const [id, item] of this._pairs) {
      map2[id] = item;
    }
    return map2;
  }
  /**
   * Return a map containing all the items in this stream accessible by ids.
   * @returns The map of all id  item pairs from this stream.
   */
  toMap() {
    return new _Map(this._pairs);
  }
  /**
   * Return a set containing all the (unique) ids in this stream.
   * @returns The set of all ids from this stream.
   */
  toIdSet() {
    return new _Set(this.toIdArray());
  }
  /**
   * Return a set containing all the (unique) items in this stream.
   * @returns The set of all items from this stream.
   */
  toItemSet() {
    return new _Set(this.toItemArray());
  }
  /**
   * Cache the items from this stream.
   * @remarks
   * This method allows for items to be fetched immediatelly and used (possibly multiple times) later.
   * It can also be used to optimize performance as {@link DataStream} would otherwise reevaluate everything upon each iteration.
   *
   * ## Example
   * ```javascript
   * const ds = new DataSet([])
   *
   * const cachedStream = ds.stream()
   *   .filter()
   *   .sort()
   *   .map()
   *   .cached() // Data are fetched, processed and cached here.
   *
   * ds.clear()
   * chachedStream // Still has all the items.
   * ```
   * @returns A new {@link DataStream} with cached items (detached from the original {@link DataSet}).
   */
  cache() {
    return new _DataStream([...this._pairs]);
  }
  /**
   * Get the distinct values of given property.
   * @param callback - The function that picks and possibly converts the property.
   * @typeParam T - The type of the distinct value.
   * @returns A set of all distinct properties.
   */
  distinct(callback) {
    const set2 = new _Set();
    for (const [id, item] of this._pairs) {
      set2.add(callback(item, id));
    }
    return set2;
  }
  /**
   * Filter the items of the stream.
   * @param callback - The function that decides whether an item will be included.
   * @returns A new data stream with the filtered items.
   */
  filter(callback) {
    const pairs = this._pairs;
    return new _DataStream({
      *[_Symbol$iterator]() {
        for (const [id, item] of pairs) {
          if (callback(item, id)) {
            yield [id, item];
          }
        }
      }
    });
  }
  /**
   * Execute a callback for each item of the stream.
   * @param callback - The function that will be invoked for each item.
   */
  forEach(callback) {
    for (const [id, item] of this._pairs) {
      callback(item, id);
    }
  }
  /**
   * Map the items into a different type.
   * @param callback - The function that does the conversion.
   * @typeParam Mapped - The type of the item after mapping.
   * @returns A new data stream with the mapped items.
   */
  map(callback) {
    const pairs = this._pairs;
    return new _DataStream({
      *[_Symbol$iterator]() {
        for (const [id, item] of pairs) {
          yield [id, callback(item, id)];
        }
      }
    });
  }
  /**
   * Get the item with the maximum value of given property.
   * @param callback - The function that picks and possibly converts the property.
   * @returns The item with the maximum if found otherwise null.
   */
  max(callback) {
    const iter = _getIterator(this._pairs);
    let curr = iter.next();
    if (curr.done) {
      return null;
    }
    let maxItem = curr.value[1];
    let maxValue = callback(curr.value[1], curr.value[0]);
    while (!(curr = iter.next()).done) {
      const [id, item] = curr.value;
      const value = callback(item, id);
      if (value > maxValue) {
        maxValue = value;
        maxItem = item;
      }
    }
    return maxItem;
  }
  /**
   * Get the item with the minimum value of given property.
   * @param callback - The function that picks and possibly converts the property.
   * @returns The item with the minimum if found otherwise null.
   */
  min(callback) {
    const iter = _getIterator(this._pairs);
    let curr = iter.next();
    if (curr.done) {
      return null;
    }
    let minItem = curr.value[1];
    let minValue = callback(curr.value[1], curr.value[0]);
    while (!(curr = iter.next()).done) {
      const [id, item] = curr.value;
      const value = callback(item, id);
      if (value < minValue) {
        minValue = value;
        minItem = item;
      }
    }
    return minItem;
  }
  /**
   * Reduce the items into a single value.
   * @param callback - The function that does the reduction.
   * @param accumulator - The initial value of the accumulator.
   * @typeParam T - The type of the accumulated value.
   * @returns The reduced value.
   */
  reduce(callback, accumulator) {
    for (const [id, item] of this._pairs) {
      accumulator = callback(accumulator, item, id);
    }
    return accumulator;
  }
  /**
   * Sort the items.
   * @param callback - Item comparator.
   * @returns A new stream with sorted items.
   */
  sort(callback) {
    return new _DataStream({
      [_Symbol$iterator]: () => {
        var _context1;
        return _getIterator(_sortInstanceProperty(_context1 = [...this._pairs]).call(_context1, (_ref, _ref2) => {
          let [idA, itemA] = _ref;
          let [idB, itemB] = _ref2;
          return callback(itemA, itemB, idA, idB);
        }));
      }
    });
  }
};
function ensureFullItem(item, idProp) {
  if (item[idProp] == null) {
    item[idProp] = v4();
  }
  return item;
}
var DataSet = class extends DataSetPart {
  /** @inheritDoc */
  get idProp() {
    return this._idProp;
  }
  /**
   * Construct a new DataSet.
   * @param data - Initial data or options.
   * @param options - Options (type error if data is also options).
   */
  constructor(data, options) {
    super();
    _defineProperty(this, "flush", void 0);
    _defineProperty(this, "length", void 0);
    _defineProperty(this, "_options", void 0);
    _defineProperty(this, "_data", void 0);
    _defineProperty(this, "_idProp", void 0);
    _defineProperty(this, "_queue", null);
    if (data && !_Array$isArray(data)) {
      options = data;
      data = [];
    }
    this._options = options || {};
    this._data = new _Map();
    this.length = 0;
    this._idProp = this._options.fieldId || "id";
    if (data && data.length) {
      this.add(data);
    }
    this.setOptions(options);
  }
  /**
   * Set new options.
   * @param options - The new options.
   */
  setOptions(options) {
    if (options && options.queue !== void 0) {
      if (options.queue === false) {
        if (this._queue) {
          this._queue.destroy();
          this._queue = null;
        }
      } else {
        if (!this._queue) {
          this._queue = Queue.extend(this, {
            replace: ["add", "update", "remove"]
          });
        }
        if (options.queue && typeof options.queue === "object") {
          this._queue.setOptions(options.queue);
        }
      }
    }
  }
  /**
   * Add a data item or an array with items.
   *
   * After the items are added to the DataSet, the DataSet will trigger an event `add`. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
   *
   * ## Example
   *
   * ```javascript
   * // create a DataSet
   * const data = new vis.DataSet()
   *
   * // add items
   * const ids = data.add([
   * { id: 1, text: 'item 1' },
   * { id: 2, text: 'item 2' },
   * { text: 'item without an id' }
   * ])
   *
   * console.log(ids) // [1, 2, '<UUIDv4>']
   * ```
   * @param data - Items to be added (ids will be generated if missing).
   * @param senderId - Sender id.
   * @returns addedIds - Array with the ids (generated if not present) of the added items.
   * @throws When an item with the same id as any of the added items already exists.
   */
  add(data, senderId) {
    const addedIds = [];
    let id;
    if (_Array$isArray(data)) {
      const idsToAdd = _mapInstanceProperty(data).call(data, (d) => d[this._idProp]);
      if (_someInstanceProperty(idsToAdd).call(idsToAdd, (id2) => this._data.has(id2))) {
        throw new Error("A duplicate id was found in the parameter array.");
      }
      for (let i = 0, len = data.length; i < len; i++) {
        id = this._addItem(data[i]);
        addedIds.push(id);
      }
    } else if (data && typeof data === "object") {
      id = this._addItem(data);
      addedIds.push(id);
    } else {
      throw new Error("Unknown dataType");
    }
    if (addedIds.length) {
      this._trigger("add", {
        items: addedIds
      }, senderId);
    }
    return addedIds;
  }
  /**
   * Update existing items. When an item does not exist, it will be created.
   * @remarks
   * The provided properties will be merged in the existing item. When an item does not exist, it will be created.
   *
   * After the items are updated, the DataSet will trigger an event `add` for the added items, and an event `update`. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
   *
   * ## Example
   *
   * ```javascript
   * // create a DataSet
   * const data = new vis.DataSet([
   *   { id: 1, text: 'item 1' },
   *   { id: 2, text: 'item 2' },
   *   { id: 3, text: 'item 3' }
   * ])
   *
   * // update items
   * const ids = data.update([
   *   { id: 2, text: 'item 2 (updated)' },
   *   { id: 4, text: 'item 4 (new)' }
   * ])
   *
   * console.log(ids) // [2, 4]
   * ```
   *
   * ## Warning for TypeScript users
   * This method may introduce partial items into the data set. Use add or updateOnly instead for better type safety.
   * @param data - Items to be updated (if the id is already present) or added (if the id is missing).
   * @param senderId - Sender id.
   * @returns updatedIds - The ids of the added (these may be newly generated if there was no id in the item from the data) or updated items.
   * @throws When the supplied data is neither an item nor an array of items.
   */
  update(data, senderId) {
    const addedIds = [];
    const updatedIds = [];
    const oldData = [];
    const updatedData = [];
    const idProp = this._idProp;
    const addOrUpdate = (item) => {
      const origId = item[idProp];
      if (origId != null && this._data.has(origId)) {
        const fullItem = item;
        const oldItem = _Object$assign({}, this._data.get(origId));
        const id = this._updateItem(fullItem);
        updatedIds.push(id);
        updatedData.push(fullItem);
        oldData.push(oldItem);
      } else {
        const id = this._addItem(item);
        addedIds.push(id);
      }
    };
    if (_Array$isArray(data)) {
      for (let i = 0, len = data.length; i < len; i++) {
        if (data[i] && typeof data[i] === "object") {
          addOrUpdate(data[i]);
        } else {
          console.warn("Ignoring input item, which is not an object at index " + i);
        }
      }
    } else if (data && typeof data === "object") {
      addOrUpdate(data);
    } else {
      throw new Error("Unknown dataType");
    }
    if (addedIds.length) {
      this._trigger("add", {
        items: addedIds
      }, senderId);
    }
    if (updatedIds.length) {
      const props = {
        items: updatedIds,
        oldData,
        data: updatedData
      };
      this._trigger("update", props, senderId);
    }
    return _concatInstanceProperty(addedIds).call(addedIds, updatedIds);
  }
  /**
   * Update existing items. When an item does not exist, an error will be thrown.
   * @remarks
   * The provided properties will be deeply merged into the existing item.
   * When an item does not exist (id not present in the data set or absent), an error will be thrown and nothing will be changed.
   *
   * After the items are updated, the DataSet will trigger an event `update`.
   * When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
   *
   * ## Example
   *
   * ```javascript
   * // create a DataSet
   * const data = new vis.DataSet([
   *   { id: 1, text: 'item 1' },
   *   { id: 2, text: 'item 2' },
   *   { id: 3, text: 'item 3' },
   * ])
   *
   * // update items
   * const ids = data.update([
   *   { id: 2, text: 'item 2 (updated)' }, // works
   *   // { id: 4, text: 'item 4 (new)' }, // would throw
   *   // { text: 'item 4 (new)' }, // would also throw
   * ])
   *
   * console.log(ids) // [2]
   * ```
   * @param data - Updates (the id and optionally other props) to the items in this data set.
   * @param senderId - Sender id.
   * @returns updatedIds - The ids of the updated items.
   * @throws When the supplied data is neither an item nor an array of items, when the ids are missing.
   */
  updateOnly(data, senderId) {
    var _context10;
    if (!_Array$isArray(data)) {
      data = [data];
    }
    const updateEventData = _mapInstanceProperty(_context10 = _mapInstanceProperty(data).call(data, (update) => {
      const oldData = this._data.get(update[this._idProp]);
      if (oldData == null) {
        throw new Error("Updating non-existent items is not allowed.");
      }
      return {
        oldData,
        update
      };
    })).call(_context10, (_ref3) => {
      let {
        oldData,
        update
      } = _ref3;
      const id = oldData[this._idProp];
      const updatedData = pureDeepObjectAssign(oldData, update);
      this._data.set(id, updatedData);
      return {
        id,
        oldData,
        updatedData
      };
    });
    if (updateEventData.length) {
      const props = {
        items: _mapInstanceProperty(updateEventData).call(updateEventData, (value) => value.id),
        oldData: _mapInstanceProperty(updateEventData).call(updateEventData, (value) => value.oldData),
        data: _mapInstanceProperty(updateEventData).call(updateEventData, (value) => value.updatedData)
      };
      this._trigger("update", props, senderId);
      return props.items;
    } else {
      return [];
    }
  }
  /** @inheritDoc */
  get(first, second) {
    let id = void 0;
    let ids = void 0;
    let options = void 0;
    if (isId(first)) {
      id = first;
      options = second;
    } else if (_Array$isArray(first)) {
      ids = first;
      options = second;
    } else {
      options = first;
    }
    const returnType = options && options.returnType === "Object" ? "Object" : "Array";
    const filter2 = options && _filterInstanceProperty(options);
    const items = [];
    let item = void 0;
    let itemIds = void 0;
    let itemId = void 0;
    if (id != null) {
      item = this._data.get(id);
      if (item && filter2 && !filter2(item)) {
        item = void 0;
      }
    } else if (ids != null) {
      for (let i = 0, len = ids.length; i < len; i++) {
        item = this._data.get(ids[i]);
        if (item != null && (!filter2 || filter2(item))) {
          items.push(item);
        }
      }
    } else {
      var _context11;
      itemIds = [..._keysInstanceProperty(_context11 = this._data).call(_context11)];
      for (let i = 0, len = itemIds.length; i < len; i++) {
        itemId = itemIds[i];
        item = this._data.get(itemId);
        if (item != null && (!filter2 || filter2(item))) {
          items.push(item);
        }
      }
    }
    if (options && options.order && id == void 0) {
      this._sort(items, options.order);
    }
    if (options && options.fields) {
      const fields = options.fields;
      if (id != void 0 && item != null) {
        item = this._filterFields(item, fields);
      } else {
        for (let i = 0, len = items.length; i < len; i++) {
          items[i] = this._filterFields(items[i], fields);
        }
      }
    }
    if (returnType == "Object") {
      const result = {};
      for (let i = 0, len = items.length; i < len; i++) {
        const resultant = items[i];
        const id2 = resultant[this._idProp];
        result[id2] = resultant;
      }
      return result;
    } else {
      if (id != null) {
        return item !== null && item !== void 0 ? item : null;
      } else {
        return items;
      }
    }
  }
  /** @inheritDoc */
  getIds(options) {
    const data = this._data;
    const filter2 = options && _filterInstanceProperty(options);
    const order = options && options.order;
    const itemIds = [..._keysInstanceProperty(data).call(data)];
    const ids = [];
    if (filter2) {
      if (order) {
        const items = [];
        for (let i = 0, len = itemIds.length; i < len; i++) {
          const id = itemIds[i];
          const item = this._data.get(id);
          if (item != null && filter2(item)) {
            items.push(item);
          }
        }
        this._sort(items, order);
        for (let i = 0, len = items.length; i < len; i++) {
          ids.push(items[i][this._idProp]);
        }
      } else {
        for (let i = 0, len = itemIds.length; i < len; i++) {
          const id = itemIds[i];
          const item = this._data.get(id);
          if (item != null && filter2(item)) {
            ids.push(item[this._idProp]);
          }
        }
      }
    } else {
      if (order) {
        const items = [];
        for (let i = 0, len = itemIds.length; i < len; i++) {
          const id = itemIds[i];
          items.push(data.get(id));
        }
        this._sort(items, order);
        for (let i = 0, len = items.length; i < len; i++) {
          ids.push(items[i][this._idProp]);
        }
      } else {
        for (let i = 0, len = itemIds.length; i < len; i++) {
          const id = itemIds[i];
          const item = data.get(id);
          if (item != null) {
            ids.push(item[this._idProp]);
          }
        }
      }
    }
    return ids;
  }
  /** @inheritDoc */
  getDataSet() {
    return this;
  }
  /** @inheritDoc */
  forEach(callback, options) {
    const filter2 = options && _filterInstanceProperty(options);
    const data = this._data;
    const itemIds = [..._keysInstanceProperty(data).call(data)];
    if (options && options.order) {
      const items = this.get(options);
      for (let i = 0, len = items.length; i < len; i++) {
        const item = items[i];
        const id = item[this._idProp];
        callback(item, id);
      }
    } else {
      for (let i = 0, len = itemIds.length; i < len; i++) {
        const id = itemIds[i];
        const item = this._data.get(id);
        if (item != null && (!filter2 || filter2(item))) {
          callback(item, id);
        }
      }
    }
  }
  /** @inheritDoc */
  map(callback, options) {
    const filter2 = options && _filterInstanceProperty(options);
    const mappedItems = [];
    const data = this._data;
    const itemIds = [..._keysInstanceProperty(data).call(data)];
    for (let i = 0, len = itemIds.length; i < len; i++) {
      const id = itemIds[i];
      const item = this._data.get(id);
      if (item != null && (!filter2 || filter2(item))) {
        mappedItems.push(callback(item, id));
      }
    }
    if (options && options.order) {
      this._sort(mappedItems, options.order);
    }
    return mappedItems;
  }
  /**
   * Filter the fields of an item.
   * @param item - The item whose fields should be filtered.
   * @param fields - The names of the fields that will be kept.
   * @typeParam K - Field name type.
   * @returns The item without any additional fields.
   */
  _filterFields(item, fields) {
    var _context12;
    if (!item) {
      return item;
    }
    return _reduceInstanceProperty(_context12 = _Array$isArray(fields) ? (
      // Use the supplied array
      fields
    ) : (
      // Use the keys of the supplied object
      _Object$keys(fields)
    )).call(_context12, (filteredItem, field) => {
      filteredItem[field] = item[field];
      return filteredItem;
    }, {});
  }
  /**
   * Sort the provided array with items.
   * @param items - Items to be sorted in place.
   * @param order - A field name or custom sort function.
   * @typeParam T - The type of the items in the items array.
   */
  _sort(items, order) {
    if (typeof order === "string") {
      const name = order;
      _sortInstanceProperty(items).call(items, (a, b) => {
        const av = a[name];
        const bv = b[name];
        return av > bv ? 1 : av < bv ? -1 : 0;
      });
    } else if (typeof order === "function") {
      _sortInstanceProperty(items).call(items, order);
    } else {
      throw new TypeError("Order must be a function or a string");
    }
  }
  /**
   * Remove an item or multiple items by reference (only the id is used) or by id.
   *
   * The method ignores removal of non-existing items, and returns an array containing the ids of the items which are actually removed from the DataSet.
   *
   * After the items are removed, the DataSet will trigger an event `remove` for the removed items. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
   *
   * ## Example
   * ```javascript
   * // create a DataSet
   * const data = new vis.DataSet([
   * { id: 1, text: 'item 1' },
   * { id: 2, text: 'item 2' },
   * { id: 3, text: 'item 3' }
   * ])
   *
   * // remove items
   * const ids = data.remove([2, { id: 3 }, 4])
   *
   * console.log(ids) // [2, 3]
   * ```
   * @param id - One or more items or ids of items to be removed.
   * @param senderId - Sender id.
   * @returns The ids of the removed items.
   */
  remove(id, senderId) {
    const removedIds = [];
    const removedItems = [];
    const ids = _Array$isArray(id) ? id : [id];
    for (let i = 0, len = ids.length; i < len; i++) {
      const item = this._remove(ids[i]);
      if (item) {
        const itemId = item[this._idProp];
        if (itemId != null) {
          removedIds.push(itemId);
          removedItems.push(item);
        }
      }
    }
    if (removedIds.length) {
      this._trigger("remove", {
        items: removedIds,
        oldData: removedItems
      }, senderId);
    }
    return removedIds;
  }
  /**
   * Remove an item by its id or reference.
   * @param id - Id of an item or the item itself.
   * @returns The removed item if removed, null otherwise.
   */
  _remove(id) {
    let ident;
    if (isId(id)) {
      ident = id;
    } else if (id && typeof id === "object") {
      ident = id[this._idProp];
    }
    if (ident != null && this._data.has(ident)) {
      const item = this._data.get(ident) || null;
      this._data.delete(ident);
      --this.length;
      return item;
    }
    return null;
  }
  /**
   * Clear the entire data set.
   *
   * After the items are removed, the {@link DataSet} will trigger an event `remove` for all removed items. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
   * @param senderId - Sender id.
   * @returns removedIds - The ids of all removed items.
   */
  clear(senderId) {
    var _context13;
    const ids = [..._keysInstanceProperty(_context13 = this._data).call(_context13)];
    const items = [];
    for (let i = 0, len = ids.length; i < len; i++) {
      items.push(this._data.get(ids[i]));
    }
    this._data.clear();
    this.length = 0;
    this._trigger("remove", {
      items: ids,
      oldData: items
    }, senderId);
    return ids;
  }
  /**
   * Find the item with maximum value of a specified field.
   * @param field - Name of the property that should be searched for max value.
   * @returns Item containing max value, or null if no items.
   */
  max(field) {
    let max = null;
    let maxField = null;
    for (const item of _valuesInstanceProperty(_context14 = this._data).call(_context14)) {
      var _context14;
      const itemField = item[field];
      if (typeof itemField === "number" && (maxField == null || itemField > maxField)) {
        max = item;
        maxField = itemField;
      }
    }
    return max || null;
  }
  /**
   * Find the item with minimum value of a specified field.
   * @param field - Name of the property that should be searched for min value.
   * @returns Item containing min value, or null if no items.
   */
  min(field) {
    let min = null;
    let minField = null;
    for (const item of _valuesInstanceProperty(_context15 = this._data).call(_context15)) {
      var _context15;
      const itemField = item[field];
      if (typeof itemField === "number" && (minField == null || itemField < minField)) {
        min = item;
        minField = itemField;
      }
    }
    return min || null;
  }
  /**
   * Find all distinct values of a specified field
   * @param prop - The property name whose distinct values should be returned.
   * @returns Unordered array containing all distinct values. Items without specified property are ignored.
   */
  distinct(prop) {
    const data = this._data;
    const itemIds = [..._keysInstanceProperty(data).call(data)];
    const values2 = [];
    let count = 0;
    for (let i = 0, len = itemIds.length; i < len; i++) {
      const id = itemIds[i];
      const item = data.get(id);
      const value = item[prop];
      let exists = false;
      for (let j = 0; j < count; j++) {
        if (values2[j] == value) {
          exists = true;
          break;
        }
      }
      if (!exists && value !== void 0) {
        values2[count] = value;
        count++;
      }
    }
    return values2;
  }
  /**
   * Add a single item. Will fail when an item with the same id already exists.
   * @param item - A new item to be added.
   * @returns Added item's id. An id is generated when it is not present in the item.
   */
  _addItem(item) {
    const fullItem = ensureFullItem(item, this._idProp);
    const id = fullItem[this._idProp];
    if (this._data.has(id)) {
      throw new Error("Cannot add item: item with id " + id + " already exists");
    }
    this._data.set(id, fullItem);
    ++this.length;
    return id;
  }
  /**
   * Update a single item: merge with existing item.
   * Will fail when the item has no id, or when there does not exist an item with the same id.
   * @param update - The new item
   * @returns The id of the updated item.
   */
  _updateItem(update) {
    const id = update[this._idProp];
    if (id == null) {
      throw new Error("Cannot update item: item has no id (item: " + _JSON$stringify(update) + ")");
    }
    const item = this._data.get(id);
    if (!item) {
      throw new Error("Cannot update item: no item with id " + id + " found");
    }
    this._data.set(id, _objectSpread$1(_objectSpread$1({}, item), update));
    return id;
  }
  /** @inheritDoc */
  stream(ids) {
    if (ids) {
      const data = this._data;
      return new DataStream({
        *[_Symbol$iterator]() {
          for (const id of ids) {
            const item = data.get(id);
            if (item != null) {
              yield [id, item];
            }
          }
        }
      });
    } else {
      var _context16;
      return new DataStream({
        [_Symbol$iterator]: _bindInstanceProperty(_context16 = _entriesInstanceProperty(this._data)).call(_context16, this._data)
      });
    }
  }
};
var DataView = class _DataView extends DataSetPart {
  /** @inheritDoc */
  get idProp() {
    return this.getDataSet().idProp;
  }
  /**
   * Create a DataView.
   * @param data - The instance containing data (directly or indirectly).
   * @param options - Options to configure this data view.
   */
  constructor(data, options) {
    var _context17;
    super();
    _defineProperty(this, "length", 0);
    _defineProperty(this, "_listener", void 0);
    _defineProperty(this, "_data", void 0);
    _defineProperty(this, "_ids", new _Set());
    _defineProperty(this, "_options", void 0);
    this._options = options || {};
    this._listener = _bindInstanceProperty(_context17 = this._onEvent).call(_context17, this);
    this.setData(data);
  }
  // TODO: implement a function .config() to dynamically update things like configured filter
  // and trigger changes accordingly
  /**
   * Set a data source for the view.
   * @param data - The instance containing data (directly or indirectly).
   * @remarks
   * Note that when the data view is bound to a data set it won't be garbage
   * collected unless the data set is too. Use `dataView.setData(null)` or
   * `dataView.dispose()` to enable garbage collection before you lose the last
   * reference.
   */
  setData(data) {
    if (this._data) {
      if (this._data.off) {
        this._data.off("*", this._listener);
      }
      const ids = this._data.getIds({
        filter: _filterInstanceProperty(this._options)
      });
      const items = this._data.get(ids);
      this._ids.clear();
      this.length = 0;
      this._trigger("remove", {
        items: ids,
        oldData: items
      });
    }
    if (data != null) {
      this._data = data;
      const ids = this._data.getIds({
        filter: _filterInstanceProperty(this._options)
      });
      for (let i = 0, len = ids.length; i < len; i++) {
        const id = ids[i];
        this._ids.add(id);
      }
      this.length = ids.length;
      this._trigger("add", {
        items: ids
      });
    } else {
      this._data = new DataSet();
    }
    if (this._data.on) {
      this._data.on("*", this._listener);
    }
  }
  /**
   * Refresh the DataView.
   * Useful when the DataView has a filter function containing a variable parameter.
   */
  refresh() {
    const ids = this._data.getIds({
      filter: _filterInstanceProperty(this._options)
    });
    const oldIds = [...this._ids];
    const newIds = {};
    const addedIds = [];
    const removedIds = [];
    const removedItems = [];
    for (let i = 0, len = ids.length; i < len; i++) {
      const id = ids[i];
      newIds[id] = true;
      if (!this._ids.has(id)) {
        addedIds.push(id);
        this._ids.add(id);
      }
    }
    for (let i = 0, len = oldIds.length; i < len; i++) {
      const id = oldIds[i];
      const item = this._data.get(id);
      if (item == null) {
        console.error("If you see this, report it please.");
      } else if (!newIds[id]) {
        removedIds.push(id);
        removedItems.push(item);
        this._ids.delete(id);
      }
    }
    this.length += addedIds.length - removedIds.length;
    if (addedIds.length) {
      this._trigger("add", {
        items: addedIds
      });
    }
    if (removedIds.length) {
      this._trigger("remove", {
        items: removedIds,
        oldData: removedItems
      });
    }
  }
  /** @inheritDoc */
  get(first, second) {
    if (this._data == null) {
      return null;
    }
    let ids = null;
    let options;
    if (isId(first) || _Array$isArray(first)) {
      ids = first;
      options = second;
    } else {
      options = first;
    }
    const viewOptions = _Object$assign({}, this._options, options);
    const thisFilter = _filterInstanceProperty(this._options);
    const optionsFilter = options && _filterInstanceProperty(options);
    if (thisFilter && optionsFilter) {
      viewOptions.filter = (item) => {
        return thisFilter(item) && optionsFilter(item);
      };
    }
    if (ids == null) {
      return this._data.get(viewOptions);
    } else {
      return this._data.get(ids, viewOptions);
    }
  }
  /** @inheritDoc */
  getIds(options) {
    if (this._data.length) {
      const defaultFilter = _filterInstanceProperty(this._options);
      const optionsFilter = options != null ? _filterInstanceProperty(options) : null;
      let filter2;
      if (optionsFilter) {
        if (defaultFilter) {
          filter2 = (item) => {
            return defaultFilter(item) && optionsFilter(item);
          };
        } else {
          filter2 = optionsFilter;
        }
      } else {
        filter2 = defaultFilter;
      }
      return this._data.getIds({
        filter: filter2,
        order: options && options.order
      });
    } else {
      return [];
    }
  }
  /** @inheritDoc */
  forEach(callback, options) {
    if (this._data) {
      var _context18;
      const defaultFilter = _filterInstanceProperty(this._options);
      const optionsFilter = options && _filterInstanceProperty(options);
      let filter2;
      if (optionsFilter) {
        if (defaultFilter) {
          filter2 = function(item) {
            return defaultFilter(item) && optionsFilter(item);
          };
        } else {
          filter2 = optionsFilter;
        }
      } else {
        filter2 = defaultFilter;
      }
      _forEachInstanceProperty(_context18 = this._data).call(_context18, callback, {
        filter: filter2,
        order: options && options.order
      });
    }
  }
  /** @inheritDoc */
  map(callback, options) {
    if (this._data) {
      var _context19;
      const defaultFilter = _filterInstanceProperty(this._options);
      const optionsFilter = options && _filterInstanceProperty(options);
      let filter2;
      if (optionsFilter) {
        if (defaultFilter) {
          filter2 = (item) => {
            return defaultFilter(item) && optionsFilter(item);
          };
        } else {
          filter2 = optionsFilter;
        }
      } else {
        filter2 = defaultFilter;
      }
      return _mapInstanceProperty(_context19 = this._data).call(_context19, callback, {
        filter: filter2,
        order: options && options.order
      });
    } else {
      return [];
    }
  }
  /** @inheritDoc */
  getDataSet() {
    return this._data.getDataSet();
  }
  /** @inheritDoc */
  stream(ids) {
    var _context20;
    return this._data.stream(ids || {
      [_Symbol$iterator]: _bindInstanceProperty(_context20 = _keysInstanceProperty(this._ids)).call(_context20, this._ids)
    });
  }
  /**
   * Render the instance unusable prior to garbage collection.
   * @remarks
   * The intention of this method is to help discover scenarios where the data
   * view is being used when the programmer thinks it has been garbage collected
   * already. It's stricter version of `dataView.setData(null)`.
   */
  dispose() {
    var _this$_data;
    if ((_this$_data = this._data) !== null && _this$_data !== void 0 && _this$_data.off) {
      this._data.off("*", this._listener);
    }
    const message = "This data view has already been disposed of.";
    const replacement = {
      get: () => {
        throw new Error(message);
      },
      set: () => {
        throw new Error(message);
      },
      configurable: false
    };
    for (const key of _Reflect$ownKeys(_DataView.prototype)) {
      _Object$defineProperty(this, key, replacement);
    }
  }
  /**
   * Event listener. Will propagate all events from the connected data set to the subscribers of the DataView, but will filter the items and only trigger when there are changes in the filtered data set.
   * @param event - The name of the event.
   * @param params - Parameters of the event.
   * @param senderId - Id supplied by the sender.
   */
  _onEvent(event2, params, senderId) {
    if (!params || !params.items || !this._data) {
      return;
    }
    const ids = params.items;
    const addedIds = [];
    const updatedIds = [];
    const removedIds = [];
    const oldItems = [];
    const updatedItems = [];
    const removedItems = [];
    switch (event2) {
      case "add":
        for (let i = 0, len = ids.length; i < len; i++) {
          const id = ids[i];
          const item = this.get(id);
          if (item) {
            this._ids.add(id);
            addedIds.push(id);
          }
        }
        break;
      case "update":
        for (let i = 0, len = ids.length; i < len; i++) {
          const id = ids[i];
          const item = this.get(id);
          if (item) {
            if (this._ids.has(id)) {
              updatedIds.push(id);
              updatedItems.push(params.data[i]);
              oldItems.push(params.oldData[i]);
            } else {
              this._ids.add(id);
              addedIds.push(id);
            }
          } else {
            if (this._ids.has(id)) {
              this._ids.delete(id);
              removedIds.push(id);
              removedItems.push(params.oldData[i]);
            }
          }
        }
        break;
      case "remove":
        for (let i = 0, len = ids.length; i < len; i++) {
          const id = ids[i];
          if (this._ids.has(id)) {
            this._ids.delete(id);
            removedIds.push(id);
            removedItems.push(params.oldData[i]);
          }
        }
        break;
    }
    this.length += addedIds.length - removedIds.length;
    if (addedIds.length) {
      this._trigger("add", {
        items: addedIds
      }, senderId);
    }
    if (updatedIds.length) {
      this._trigger("update", {
        items: updatedIds,
        oldData: oldItems,
        data: updatedItems
      }, senderId);
    }
    if (removedIds.length) {
      this._trigger("remove", {
        items: removedIds,
        oldData: removedItems
      }, senderId);
    }
  }
};
function isDataSetLike(idProp, v) {
  return typeof v === "object" && v !== null && idProp === v.idProp && typeof v.add === "function" && typeof v.clear === "function" && typeof v.distinct === "function" && typeof _forEachInstanceProperty(v) === "function" && typeof v.get === "function" && typeof v.getDataSet === "function" && typeof v.getIds === "function" && typeof v.length === "number" && typeof _mapInstanceProperty(v) === "function" && typeof v.max === "function" && typeof v.min === "function" && typeof v.off === "function" && typeof v.on === "function" && typeof v.remove === "function" && typeof v.setOptions === "function" && typeof v.stream === "function" && typeof v.update === "function" && typeof v.updateOnly === "function";
}
function isDataViewLike$1(idProp, v) {
  return typeof v === "object" && v !== null && idProp === v.idProp && typeof _forEachInstanceProperty(v) === "function" && typeof v.get === "function" && typeof v.getDataSet === "function" && typeof v.getIds === "function" && typeof v.length === "number" && typeof _mapInstanceProperty(v) === "function" && typeof v.off === "function" && typeof v.on === "function" && typeof v.stream === "function" && isDataSetLike(idProp, v.getDataSet());
}
var momentExports = requireMoment();
var moment$3 = getDefaultExportFromCjs(momentExports);
var moment$2 = typeof window !== "undefined" && window["moment"] || moment$3;
var lib$1 = { exports: {} };
var _default$1 = {};
var lib = { exports: {} };
var _default = {};
var hasRequired_default$1;
function require_default$1() {
  if (hasRequired_default$1) return _default;
  hasRequired_default$1 = 1;
  function getDefaultWhiteList() {
    var whiteList = {};
    whiteList["align-content"] = false;
    whiteList["align-items"] = false;
    whiteList["align-self"] = false;
    whiteList["alignment-adjust"] = false;
    whiteList["alignment-baseline"] = false;
    whiteList["all"] = false;
    whiteList["anchor-point"] = false;
    whiteList["animation"] = false;
    whiteList["animation-delay"] = false;
    whiteList["animation-direction"] = false;
    whiteList["animation-duration"] = false;
    whiteList["animation-fill-mode"] = false;
    whiteList["animation-iteration-count"] = false;
    whiteList["animation-name"] = false;
    whiteList["animation-play-state"] = false;
    whiteList["animation-timing-function"] = false;
    whiteList["azimuth"] = false;
    whiteList["backface-visibility"] = false;
    whiteList["background"] = true;
    whiteList["background-attachment"] = true;
    whiteList["background-clip"] = true;
    whiteList["background-color"] = true;
    whiteList["background-image"] = true;
    whiteList["background-origin"] = true;
    whiteList["background-position"] = true;
    whiteList["background-repeat"] = true;
    whiteList["background-size"] = true;
    whiteList["baseline-shift"] = false;
    whiteList["binding"] = false;
    whiteList["bleed"] = false;
    whiteList["bookmark-label"] = false;
    whiteList["bookmark-level"] = false;
    whiteList["bookmark-state"] = false;
    whiteList["border"] = true;
    whiteList["border-bottom"] = true;
    whiteList["border-bottom-color"] = true;
    whiteList["border-bottom-left-radius"] = true;
    whiteList["border-bottom-right-radius"] = true;
    whiteList["border-bottom-style"] = true;
    whiteList["border-bottom-width"] = true;
    whiteList["border-collapse"] = true;
    whiteList["border-color"] = true;
    whiteList["border-image"] = true;
    whiteList["border-image-outset"] = true;
    whiteList["border-image-repeat"] = true;
    whiteList["border-image-slice"] = true;
    whiteList["border-image-source"] = true;
    whiteList["border-image-width"] = true;
    whiteList["border-left"] = true;
    whiteList["border-left-color"] = true;
    whiteList["border-left-style"] = true;
    whiteList["border-left-width"] = true;
    whiteList["border-radius"] = true;
    whiteList["border-right"] = true;
    whiteList["border-right-color"] = true;
    whiteList["border-right-style"] = true;
    whiteList["border-right-width"] = true;
    whiteList["border-spacing"] = true;
    whiteList["border-style"] = true;
    whiteList["border-top"] = true;
    whiteList["border-top-color"] = true;
    whiteList["border-top-left-radius"] = true;
    whiteList["border-top-right-radius"] = true;
    whiteList["border-top-style"] = true;
    whiteList["border-top-width"] = true;
    whiteList["border-width"] = true;
    whiteList["bottom"] = false;
    whiteList["box-decoration-break"] = true;
    whiteList["box-shadow"] = true;
    whiteList["box-sizing"] = true;
    whiteList["box-snap"] = true;
    whiteList["box-suppress"] = true;
    whiteList["break-after"] = true;
    whiteList["break-before"] = true;
    whiteList["break-inside"] = true;
    whiteList["caption-side"] = false;
    whiteList["chains"] = false;
    whiteList["clear"] = true;
    whiteList["clip"] = false;
    whiteList["clip-path"] = false;
    whiteList["clip-rule"] = false;
    whiteList["color"] = true;
    whiteList["color-interpolation-filters"] = true;
    whiteList["column-count"] = false;
    whiteList["column-fill"] = false;
    whiteList["column-gap"] = false;
    whiteList["column-rule"] = false;
    whiteList["column-rule-color"] = false;
    whiteList["column-rule-style"] = false;
    whiteList["column-rule-width"] = false;
    whiteList["column-span"] = false;
    whiteList["column-width"] = false;
    whiteList["columns"] = false;
    whiteList["contain"] = false;
    whiteList["content"] = false;
    whiteList["counter-increment"] = false;
    whiteList["counter-reset"] = false;
    whiteList["counter-set"] = false;
    whiteList["crop"] = false;
    whiteList["cue"] = false;
    whiteList["cue-after"] = false;
    whiteList["cue-before"] = false;
    whiteList["cursor"] = false;
    whiteList["direction"] = false;
    whiteList["display"] = true;
    whiteList["display-inside"] = true;
    whiteList["display-list"] = true;
    whiteList["display-outside"] = true;
    whiteList["dominant-baseline"] = false;
    whiteList["elevation"] = false;
    whiteList["empty-cells"] = false;
    whiteList["filter"] = false;
    whiteList["flex"] = false;
    whiteList["flex-basis"] = false;
    whiteList["flex-direction"] = false;
    whiteList["flex-flow"] = false;
    whiteList["flex-grow"] = false;
    whiteList["flex-shrink"] = false;
    whiteList["flex-wrap"] = false;
    whiteList["float"] = false;
    whiteList["float-offset"] = false;
    whiteList["flood-color"] = false;
    whiteList["flood-opacity"] = false;
    whiteList["flow-from"] = false;
    whiteList["flow-into"] = false;
    whiteList["font"] = true;
    whiteList["font-family"] = true;
    whiteList["font-feature-settings"] = true;
    whiteList["font-kerning"] = true;
    whiteList["font-language-override"] = true;
    whiteList["font-size"] = true;
    whiteList["font-size-adjust"] = true;
    whiteList["font-stretch"] = true;
    whiteList["font-style"] = true;
    whiteList["font-synthesis"] = true;
    whiteList["font-variant"] = true;
    whiteList["font-variant-alternates"] = true;
    whiteList["font-variant-caps"] = true;
    whiteList["font-variant-east-asian"] = true;
    whiteList["font-variant-ligatures"] = true;
    whiteList["font-variant-numeric"] = true;
    whiteList["font-variant-position"] = true;
    whiteList["font-weight"] = true;
    whiteList["grid"] = false;
    whiteList["grid-area"] = false;
    whiteList["grid-auto-columns"] = false;
    whiteList["grid-auto-flow"] = false;
    whiteList["grid-auto-rows"] = false;
    whiteList["grid-column"] = false;
    whiteList["grid-column-end"] = false;
    whiteList["grid-column-start"] = false;
    whiteList["grid-row"] = false;
    whiteList["grid-row-end"] = false;
    whiteList["grid-row-start"] = false;
    whiteList["grid-template"] = false;
    whiteList["grid-template-areas"] = false;
    whiteList["grid-template-columns"] = false;
    whiteList["grid-template-rows"] = false;
    whiteList["hanging-punctuation"] = false;
    whiteList["height"] = true;
    whiteList["hyphens"] = false;
    whiteList["icon"] = false;
    whiteList["image-orientation"] = false;
    whiteList["image-resolution"] = false;
    whiteList["ime-mode"] = false;
    whiteList["initial-letters"] = false;
    whiteList["inline-box-align"] = false;
    whiteList["justify-content"] = false;
    whiteList["justify-items"] = false;
    whiteList["justify-self"] = false;
    whiteList["left"] = false;
    whiteList["letter-spacing"] = true;
    whiteList["lighting-color"] = true;
    whiteList["line-box-contain"] = false;
    whiteList["line-break"] = false;
    whiteList["line-grid"] = false;
    whiteList["line-height"] = false;
    whiteList["line-snap"] = false;
    whiteList["line-stacking"] = false;
    whiteList["line-stacking-ruby"] = false;
    whiteList["line-stacking-shift"] = false;
    whiteList["line-stacking-strategy"] = false;
    whiteList["list-style"] = true;
    whiteList["list-style-image"] = true;
    whiteList["list-style-position"] = true;
    whiteList["list-style-type"] = true;
    whiteList["margin"] = true;
    whiteList["margin-bottom"] = true;
    whiteList["margin-left"] = true;
    whiteList["margin-right"] = true;
    whiteList["margin-top"] = true;
    whiteList["marker-offset"] = false;
    whiteList["marker-side"] = false;
    whiteList["marks"] = false;
    whiteList["mask"] = false;
    whiteList["mask-box"] = false;
    whiteList["mask-box-outset"] = false;
    whiteList["mask-box-repeat"] = false;
    whiteList["mask-box-slice"] = false;
    whiteList["mask-box-source"] = false;
    whiteList["mask-box-width"] = false;
    whiteList["mask-clip"] = false;
    whiteList["mask-image"] = false;
    whiteList["mask-origin"] = false;
    whiteList["mask-position"] = false;
    whiteList["mask-repeat"] = false;
    whiteList["mask-size"] = false;
    whiteList["mask-source-type"] = false;
    whiteList["mask-type"] = false;
    whiteList["max-height"] = true;
    whiteList["max-lines"] = false;
    whiteList["max-width"] = true;
    whiteList["min-height"] = true;
    whiteList["min-width"] = true;
    whiteList["move-to"] = false;
    whiteList["nav-down"] = false;
    whiteList["nav-index"] = false;
    whiteList["nav-left"] = false;
    whiteList["nav-right"] = false;
    whiteList["nav-up"] = false;
    whiteList["object-fit"] = false;
    whiteList["object-position"] = false;
    whiteList["opacity"] = false;
    whiteList["order"] = false;
    whiteList["orphans"] = false;
    whiteList["outline"] = false;
    whiteList["outline-color"] = false;
    whiteList["outline-offset"] = false;
    whiteList["outline-style"] = false;
    whiteList["outline-width"] = false;
    whiteList["overflow"] = false;
    whiteList["overflow-wrap"] = false;
    whiteList["overflow-x"] = false;
    whiteList["overflow-y"] = false;
    whiteList["padding"] = true;
    whiteList["padding-bottom"] = true;
    whiteList["padding-left"] = true;
    whiteList["padding-right"] = true;
    whiteList["padding-top"] = true;
    whiteList["page"] = false;
    whiteList["page-break-after"] = false;
    whiteList["page-break-before"] = false;
    whiteList["page-break-inside"] = false;
    whiteList["page-policy"] = false;
    whiteList["pause"] = false;
    whiteList["pause-after"] = false;
    whiteList["pause-before"] = false;
    whiteList["perspective"] = false;
    whiteList["perspective-origin"] = false;
    whiteList["pitch"] = false;
    whiteList["pitch-range"] = false;
    whiteList["play-during"] = false;
    whiteList["position"] = false;
    whiteList["presentation-level"] = false;
    whiteList["quotes"] = false;
    whiteList["region-fragment"] = false;
    whiteList["resize"] = false;
    whiteList["rest"] = false;
    whiteList["rest-after"] = false;
    whiteList["rest-before"] = false;
    whiteList["richness"] = false;
    whiteList["right"] = false;
    whiteList["rotation"] = false;
    whiteList["rotation-point"] = false;
    whiteList["ruby-align"] = false;
    whiteList["ruby-merge"] = false;
    whiteList["ruby-position"] = false;
    whiteList["shape-image-threshold"] = false;
    whiteList["shape-outside"] = false;
    whiteList["shape-margin"] = false;
    whiteList["size"] = false;
    whiteList["speak"] = false;
    whiteList["speak-as"] = false;
    whiteList["speak-header"] = false;
    whiteList["speak-numeral"] = false;
    whiteList["speak-punctuation"] = false;
    whiteList["speech-rate"] = false;
    whiteList["stress"] = false;
    whiteList["string-set"] = false;
    whiteList["tab-size"] = false;
    whiteList["table-layout"] = false;
    whiteList["text-align"] = true;
    whiteList["text-align-last"] = true;
    whiteList["text-combine-upright"] = true;
    whiteList["text-decoration"] = true;
    whiteList["text-decoration-color"] = true;
    whiteList["text-decoration-line"] = true;
    whiteList["text-decoration-skip"] = true;
    whiteList["text-decoration-style"] = true;
    whiteList["text-emphasis"] = true;
    whiteList["text-emphasis-color"] = true;
    whiteList["text-emphasis-position"] = true;
    whiteList["text-emphasis-style"] = true;
    whiteList["text-height"] = true;
    whiteList["text-indent"] = true;
    whiteList["text-justify"] = true;
    whiteList["text-orientation"] = true;
    whiteList["text-overflow"] = true;
    whiteList["text-shadow"] = true;
    whiteList["text-space-collapse"] = true;
    whiteList["text-transform"] = true;
    whiteList["text-underline-position"] = true;
    whiteList["text-wrap"] = true;
    whiteList["top"] = false;
    whiteList["transform"] = false;
    whiteList["transform-origin"] = false;
    whiteList["transform-style"] = false;
    whiteList["transition"] = false;
    whiteList["transition-delay"] = false;
    whiteList["transition-duration"] = false;
    whiteList["transition-property"] = false;
    whiteList["transition-timing-function"] = false;
    whiteList["unicode-bidi"] = false;
    whiteList["vertical-align"] = false;
    whiteList["visibility"] = false;
    whiteList["voice-balance"] = false;
    whiteList["voice-duration"] = false;
    whiteList["voice-family"] = false;
    whiteList["voice-pitch"] = false;
    whiteList["voice-range"] = false;
    whiteList["voice-rate"] = false;
    whiteList["voice-stress"] = false;
    whiteList["voice-volume"] = false;
    whiteList["volume"] = false;
    whiteList["white-space"] = false;
    whiteList["widows"] = false;
    whiteList["width"] = true;
    whiteList["will-change"] = false;
    whiteList["word-break"] = true;
    whiteList["word-spacing"] = true;
    whiteList["word-wrap"] = true;
    whiteList["wrap-flow"] = false;
    whiteList["wrap-through"] = false;
    whiteList["writing-mode"] = false;
    whiteList["z-index"] = false;
    return whiteList;
  }
  function onAttr(name, value, options) {
  }
  function onIgnoreAttr(name, value, options) {
  }
  var REGEXP_URL_JAVASCRIPT = /javascript\s*\:/img;
  function safeAttrValue(name, value) {
    if (REGEXP_URL_JAVASCRIPT.test(value)) return "";
    return value;
  }
  _default.whiteList = getDefaultWhiteList();
  _default.getDefaultWhiteList = getDefaultWhiteList;
  _default.onAttr = onAttr;
  _default.onIgnoreAttr = onIgnoreAttr;
  _default.safeAttrValue = safeAttrValue;
  return _default;
}
var util$1;
var hasRequiredUtil$1;
function requireUtil$1() {
  if (hasRequiredUtil$1) return util$1;
  hasRequiredUtil$1 = 1;
  util$1 = {
    indexOf: function(arr, item) {
      var i, j;
      if (Array.prototype.indexOf) {
        return arr.indexOf(item);
      }
      for (i = 0, j = arr.length; i < j; i++) {
        if (arr[i] === item) {
          return i;
        }
      }
      return -1;
    },
    forEach: function(arr, fn, scope) {
      var i, j;
      if (Array.prototype.forEach) {
        return arr.forEach(fn, scope);
      }
      for (i = 0, j = arr.length; i < j; i++) {
        fn.call(scope, arr[i], i, arr);
      }
    },
    trim: function(str) {
      if (String.prototype.trim) {
        return str.trim();
      }
      return str.replace(/(^\s*)|(\s*$)/g, "");
    },
    trimRight: function(str) {
      if (String.prototype.trimRight) {
        return str.trimRight();
      }
      return str.replace(/(\s*$)/g, "");
    }
  };
  return util$1;
}
var parser$1;
var hasRequiredParser$1;
function requireParser$1() {
  if (hasRequiredParser$1) return parser$1;
  hasRequiredParser$1 = 1;
  var _ = requireUtil$1();
  function parseStyle(css2, onAttr) {
    css2 = _.trimRight(css2);
    if (css2[css2.length - 1] !== ";") css2 += ";";
    var cssLength = css2.length;
    var isParenthesisOpen = false;
    var lastPos = 0;
    var i = 0;
    var retCSS = "";
    function addNewAttr() {
      if (!isParenthesisOpen) {
        var source = _.trim(css2.slice(lastPos, i));
        var j2 = source.indexOf(":");
        if (j2 !== -1) {
          var name = _.trim(source.slice(0, j2));
          var value = _.trim(source.slice(j2 + 1));
          if (name) {
            var ret = onAttr(lastPos, retCSS.length, name, value, source);
            if (ret) retCSS += ret + "; ";
          }
        }
      }
      lastPos = i + 1;
    }
    for (; i < cssLength; i++) {
      var c = css2[i];
      if (c === "/" && css2[i + 1] === "*") {
        var j = css2.indexOf("*/", i + 2);
        if (j === -1) break;
        i = j + 1;
        lastPos = i + 1;
        isParenthesisOpen = false;
      } else if (c === "(") {
        isParenthesisOpen = true;
      } else if (c === ")") {
        isParenthesisOpen = false;
      } else if (c === ";") {
        if (isParenthesisOpen) ;
        else {
          addNewAttr();
        }
      } else if (c === "\n") {
        addNewAttr();
      }
    }
    return _.trim(retCSS);
  }
  parser$1 = parseStyle;
  return parser$1;
}
var css;
var hasRequiredCss;
function requireCss() {
  if (hasRequiredCss) return css;
  hasRequiredCss = 1;
  var DEFAULT = require_default$1();
  var parseStyle = requireParser$1();
  requireUtil$1();
  function isNull(obj) {
    return obj === void 0 || obj === null;
  }
  function shallowCopyObject(obj) {
    var ret = {};
    for (var i in obj) {
      ret[i] = obj[i];
    }
    return ret;
  }
  function FilterCSS(options) {
    options = shallowCopyObject(options || {});
    options.whiteList = options.whiteList || DEFAULT.whiteList;
    options.onAttr = options.onAttr || DEFAULT.onAttr;
    options.onIgnoreAttr = options.onIgnoreAttr || DEFAULT.onIgnoreAttr;
    options.safeAttrValue = options.safeAttrValue || DEFAULT.safeAttrValue;
    this.options = options;
  }
  FilterCSS.prototype.process = function(css2) {
    css2 = css2 || "";
    css2 = css2.toString();
    if (!css2) return "";
    var me = this;
    var options = me.options;
    var whiteList = options.whiteList;
    var onAttr = options.onAttr;
    var onIgnoreAttr = options.onIgnoreAttr;
    var safeAttrValue = options.safeAttrValue;
    var retCSS = parseStyle(css2, function(sourcePosition, position, name, value, source) {
      var check = whiteList[name];
      var isWhite = false;
      if (check === true) isWhite = check;
      else if (typeof check === "function") isWhite = check(value);
      else if (check instanceof RegExp) isWhite = check.test(value);
      if (isWhite !== true) isWhite = false;
      value = safeAttrValue(name, value);
      if (!value) return;
      var opts = {
        position,
        sourcePosition,
        source,
        isWhite
      };
      if (isWhite) {
        var ret = onAttr(name, value, opts);
        if (isNull(ret)) {
          return name + ":" + value;
        } else {
          return ret;
        }
      } else {
        var ret = onIgnoreAttr(name, value, opts);
        if (!isNull(ret)) {
          return ret;
        }
      }
    });
    return retCSS;
  };
  css = FilterCSS;
  return css;
}
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib.exports;
  hasRequiredLib$1 = 1;
  (function(module, exports) {
    var DEFAULT = require_default$1();
    var FilterCSS = requireCss();
    function filterCSS(html2, options) {
      var xss2 = new FilterCSS(options);
      return xss2.process(html2);
    }
    exports = module.exports = filterCSS;
    exports.FilterCSS = FilterCSS;
    for (var i in DEFAULT) exports[i] = DEFAULT[i];
    if (typeof window !== "undefined") {
      window.filterCSS = module.exports;
    }
  })(lib, lib.exports);
  return lib.exports;
}
var util;
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  util = {
    indexOf: function(arr, item) {
      var i, j;
      if (Array.prototype.indexOf) {
        return arr.indexOf(item);
      }
      for (i = 0, j = arr.length; i < j; i++) {
        if (arr[i] === item) {
          return i;
        }
      }
      return -1;
    },
    forEach: function(arr, fn, scope) {
      var i, j;
      if (Array.prototype.forEach) {
        return arr.forEach(fn, scope);
      }
      for (i = 0, j = arr.length; i < j; i++) {
        fn.call(scope, arr[i], i, arr);
      }
    },
    trim: function(str) {
      if (String.prototype.trim) {
        return str.trim();
      }
      return str.replace(/(^\s*)|(\s*$)/g, "");
    },
    spaceIndex: function(str) {
      var reg = /\s|\n|\t/;
      var match = reg.exec(str);
      return match ? match.index : -1;
    }
  };
  return util;
}
var hasRequired_default;
function require_default() {
  if (hasRequired_default) return _default$1;
  hasRequired_default = 1;
  var FilterCSS = requireLib$1().FilterCSS;
  var getDefaultCSSWhiteList = requireLib$1().getDefaultWhiteList;
  var _ = requireUtil();
  function getDefaultWhiteList() {
    return {
      a: ["target", "href", "title"],
      abbr: ["title"],
      address: [],
      area: ["shape", "coords", "href", "alt"],
      article: [],
      aside: [],
      audio: [
        "autoplay",
        "controls",
        "crossorigin",
        "loop",
        "muted",
        "preload",
        "src"
      ],
      b: [],
      bdi: ["dir"],
      bdo: ["dir"],
      big: [],
      blockquote: ["cite"],
      br: [],
      caption: [],
      center: [],
      cite: [],
      code: [],
      col: ["align", "valign", "span", "width"],
      colgroup: ["align", "valign", "span", "width"],
      dd: [],
      del: ["datetime"],
      details: ["open"],
      div: [],
      dl: [],
      dt: [],
      em: [],
      figcaption: [],
      figure: [],
      font: ["color", "size", "face"],
      footer: [],
      h1: [],
      h2: [],
      h3: [],
      h4: [],
      h5: [],
      h6: [],
      header: [],
      hr: [],
      i: [],
      img: ["src", "alt", "title", "width", "height", "loading"],
      ins: ["datetime"],
      kbd: [],
      li: [],
      mark: [],
      nav: [],
      ol: [],
      p: [],
      pre: [],
      s: [],
      section: [],
      small: [],
      span: [],
      sub: [],
      summary: [],
      sup: [],
      strong: [],
      strike: [],
      table: ["width", "border", "align", "valign"],
      tbody: ["align", "valign"],
      td: ["width", "rowspan", "colspan", "align", "valign"],
      tfoot: ["align", "valign"],
      th: ["width", "rowspan", "colspan", "align", "valign"],
      thead: ["align", "valign"],
      tr: ["rowspan", "align", "valign"],
      tt: [],
      u: [],
      ul: [],
      video: [
        "autoplay",
        "controls",
        "crossorigin",
        "loop",
        "muted",
        "playsinline",
        "poster",
        "preload",
        "src",
        "height",
        "width"
      ]
    };
  }
  var defaultCSSFilter = new FilterCSS();
  function onTag(tag, html2, options) {
  }
  function onIgnoreTag(tag, html2, options) {
  }
  function onTagAttr(tag, name, value) {
  }
  function onIgnoreTagAttr(tag, name, value) {
  }
  function escapeHtml(html2) {
    return html2.replace(REGEXP_LT, "&lt;").replace(REGEXP_GT, "&gt;");
  }
  function safeAttrValue(tag, name, value, cssFilter) {
    value = friendlyAttrValue(value);
    if (name === "href" || name === "src") {
      value = _.trim(value);
      if (value === "#") return "#";
      if (!(value.substr(0, 7) === "http://" || value.substr(0, 8) === "https://" || value.substr(0, 7) === "mailto:" || value.substr(0, 4) === "tel:" || value.substr(0, 11) === "data:image/" || value.substr(0, 6) === "ftp://" || value.substr(0, 2) === "./" || value.substr(0, 3) === "../" || value[0] === "#" || value[0] === "/")) {
        return "";
      }
    } else if (name === "background") {
      REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;
      if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
        return "";
      }
    } else if (name === "style") {
      REGEXP_DEFAULT_ON_TAG_ATTR_7.lastIndex = 0;
      if (REGEXP_DEFAULT_ON_TAG_ATTR_7.test(value)) {
        return "";
      }
      REGEXP_DEFAULT_ON_TAG_ATTR_8.lastIndex = 0;
      if (REGEXP_DEFAULT_ON_TAG_ATTR_8.test(value)) {
        REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;
        if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
          return "";
        }
      }
      if (cssFilter !== false) {
        cssFilter = cssFilter || defaultCSSFilter;
        value = cssFilter.process(value);
      }
    }
    value = escapeAttrValue(value);
    return value;
  }
  var REGEXP_LT = /</g;
  var REGEXP_GT = />/g;
  var REGEXP_QUOTE = /"/g;
  var REGEXP_QUOTE_2 = /&quot;/g;
  var REGEXP_ATTR_VALUE_1 = /&#([a-zA-Z0-9]*);?/gim;
  var REGEXP_ATTR_VALUE_COLON = /&colon;?/gim;
  var REGEXP_ATTR_VALUE_NEWLINE = /&newline;?/gim;
  var REGEXP_DEFAULT_ON_TAG_ATTR_4 = /((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a):/gi;
  var REGEXP_DEFAULT_ON_TAG_ATTR_7 = /e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi;
  var REGEXP_DEFAULT_ON_TAG_ATTR_8 = /u\s*r\s*l\s*\(.*/gi;
  function escapeQuote(str) {
    return str.replace(REGEXP_QUOTE, "&quot;");
  }
  function unescapeQuote(str) {
    return str.replace(REGEXP_QUOTE_2, '"');
  }
  function escapeHtmlEntities(str) {
    return str.replace(REGEXP_ATTR_VALUE_1, function replaceUnicode(str2, code) {
      return code[0] === "x" || code[0] === "X" ? String.fromCharCode(parseInt(code.substr(1), 16)) : String.fromCharCode(parseInt(code, 10));
    });
  }
  function escapeDangerHtml5Entities(str) {
    return str.replace(REGEXP_ATTR_VALUE_COLON, ":").replace(REGEXP_ATTR_VALUE_NEWLINE, " ");
  }
  function clearNonPrintableCharacter(str) {
    var str2 = "";
    for (var i = 0, len = str.length; i < len; i++) {
      str2 += str.charCodeAt(i) < 32 ? " " : str.charAt(i);
    }
    return _.trim(str2);
  }
  function friendlyAttrValue(str) {
    str = unescapeQuote(str);
    str = escapeHtmlEntities(str);
    str = escapeDangerHtml5Entities(str);
    str = clearNonPrintableCharacter(str);
    return str;
  }
  function escapeAttrValue(str) {
    str = escapeQuote(str);
    str = escapeHtml(str);
    return str;
  }
  function onIgnoreTagStripAll() {
    return "";
  }
  function StripTagBody(tags, next) {
    if (typeof next !== "function") {
      next = function() {
      };
    }
    var isRemoveAllTag = !Array.isArray(tags);
    function isRemoveTag(tag) {
      if (isRemoveAllTag) return true;
      return _.indexOf(tags, tag) !== -1;
    }
    var removeList = [];
    var posStart = false;
    return {
      onIgnoreTag: function(tag, html2, options) {
        if (isRemoveTag(tag)) {
          if (options.isClosing) {
            var ret = "[/removed]";
            var end = options.position + ret.length;
            removeList.push([
              posStart !== false ? posStart : options.position,
              end
            ]);
            posStart = false;
            return ret;
          } else {
            if (!posStart) {
              posStart = options.position;
            }
            return "[removed]";
          }
        } else {
          return next(tag, html2, options);
        }
      },
      remove: function(html2) {
        var rethtml = "";
        var lastPos = 0;
        _.forEach(removeList, function(pos) {
          rethtml += html2.slice(lastPos, pos[0]);
          lastPos = pos[1];
        });
        rethtml += html2.slice(lastPos);
        return rethtml;
      }
    };
  }
  function stripCommentTag(html2) {
    var retHtml = "";
    var lastPos = 0;
    while (lastPos < html2.length) {
      var i = html2.indexOf("<!--", lastPos);
      if (i === -1) {
        retHtml += html2.slice(lastPos);
        break;
      }
      retHtml += html2.slice(lastPos, i);
      var j = html2.indexOf("-->", i);
      if (j === -1) {
        break;
      }
      lastPos = j + 3;
    }
    return retHtml;
  }
  function stripBlankChar(html2) {
    var chars = html2.split("");
    chars = chars.filter(function(char) {
      var c = char.charCodeAt(0);
      if (c === 127) return false;
      if (c <= 31) {
        if (c === 10 || c === 13) return true;
        return false;
      }
      return true;
    });
    return chars.join("");
  }
  _default$1.whiteList = getDefaultWhiteList();
  _default$1.getDefaultWhiteList = getDefaultWhiteList;
  _default$1.onTag = onTag;
  _default$1.onIgnoreTag = onIgnoreTag;
  _default$1.onTagAttr = onTagAttr;
  _default$1.onIgnoreTagAttr = onIgnoreTagAttr;
  _default$1.safeAttrValue = safeAttrValue;
  _default$1.escapeHtml = escapeHtml;
  _default$1.escapeQuote = escapeQuote;
  _default$1.unescapeQuote = unescapeQuote;
  _default$1.escapeHtmlEntities = escapeHtmlEntities;
  _default$1.escapeDangerHtml5Entities = escapeDangerHtml5Entities;
  _default$1.clearNonPrintableCharacter = clearNonPrintableCharacter;
  _default$1.friendlyAttrValue = friendlyAttrValue;
  _default$1.escapeAttrValue = escapeAttrValue;
  _default$1.onIgnoreTagStripAll = onIgnoreTagStripAll;
  _default$1.StripTagBody = StripTagBody;
  _default$1.stripCommentTag = stripCommentTag;
  _default$1.stripBlankChar = stripBlankChar;
  _default$1.attributeWrapSign = '"';
  _default$1.cssFilter = defaultCSSFilter;
  _default$1.getDefaultCSSWhiteList = getDefaultCSSWhiteList;
  return _default$1;
}
var parser = {};
var hasRequiredParser;
function requireParser() {
  if (hasRequiredParser) return parser;
  hasRequiredParser = 1;
  var _ = requireUtil();
  function getTagName(html2) {
    var i = _.spaceIndex(html2);
    var tagName;
    if (i === -1) {
      tagName = html2.slice(1, -1);
    } else {
      tagName = html2.slice(1, i + 1);
    }
    tagName = _.trim(tagName).toLowerCase();
    if (tagName.slice(0, 1) === "/") tagName = tagName.slice(1);
    if (tagName.slice(-1) === "/") tagName = tagName.slice(0, -1);
    return tagName;
  }
  function isClosing(html2) {
    return html2.slice(0, 2) === "</";
  }
  function parseTag(html2, onTag, escapeHtml) {
    var rethtml = "";
    var lastPos = 0;
    var tagStart = false;
    var quoteStart = false;
    var currentPos = 0;
    var len = html2.length;
    var currentTagName = "";
    var currentHtml = "";
    chariterator: for (currentPos = 0; currentPos < len; currentPos++) {
      var c = html2.charAt(currentPos);
      if (tagStart === false) {
        if (c === "<") {
          tagStart = currentPos;
          continue;
        }
      } else {
        if (quoteStart === false) {
          if (c === "<") {
            rethtml += escapeHtml(html2.slice(lastPos, currentPos));
            tagStart = currentPos;
            lastPos = currentPos;
            continue;
          }
          if (c === ">" || currentPos === len - 1) {
            rethtml += escapeHtml(html2.slice(lastPos, tagStart));
            currentHtml = html2.slice(tagStart, currentPos + 1);
            currentTagName = getTagName(currentHtml);
            rethtml += onTag(
              tagStart,
              rethtml.length,
              currentTagName,
              currentHtml,
              isClosing(currentHtml)
            );
            lastPos = currentPos + 1;
            tagStart = false;
            continue;
          }
          if (c === '"' || c === "'") {
            var i = 1;
            var ic = html2.charAt(currentPos - i);
            while (ic.trim() === "" || ic === "=") {
              if (ic === "=") {
                quoteStart = c;
                continue chariterator;
              }
              ic = html2.charAt(currentPos - ++i);
            }
          }
        } else {
          if (c === quoteStart) {
            quoteStart = false;
            continue;
          }
        }
      }
    }
    if (lastPos < len) {
      rethtml += escapeHtml(html2.substr(lastPos));
    }
    return rethtml;
  }
  var REGEXP_ILLEGAL_ATTR_NAME = /[^a-zA-Z0-9\\_:.-]/gim;
  function parseAttr(html2, onAttr) {
    var lastPos = 0;
    var lastMarkPos = 0;
    var retAttrs = [];
    var tmpName = false;
    var len = html2.length;
    function addAttr(name, value) {
      name = _.trim(name);
      name = name.replace(REGEXP_ILLEGAL_ATTR_NAME, "").toLowerCase();
      if (name.length < 1) return;
      var ret = onAttr(name, value || "");
      if (ret) retAttrs.push(ret);
    }
    for (var i = 0; i < len; i++) {
      var c = html2.charAt(i);
      var v, j;
      if (tmpName === false && c === "=") {
        tmpName = html2.slice(lastPos, i);
        lastPos = i + 1;
        lastMarkPos = html2.charAt(lastPos) === '"' || html2.charAt(lastPos) === "'" ? lastPos : findNextQuotationMark(html2, i + 1);
        continue;
      }
      if (tmpName !== false) {
        if (i === lastMarkPos) {
          j = html2.indexOf(c, i + 1);
          if (j === -1) {
            break;
          } else {
            v = _.trim(html2.slice(lastMarkPos + 1, j));
            addAttr(tmpName, v);
            tmpName = false;
            i = j;
            lastPos = i + 1;
            continue;
          }
        }
      }
      if (/\s|\n|\t/.test(c)) {
        html2 = html2.replace(/\s|\n|\t/g, " ");
        if (tmpName === false) {
          j = findNextEqual(html2, i);
          if (j === -1) {
            v = _.trim(html2.slice(lastPos, i));
            addAttr(v);
            tmpName = false;
            lastPos = i + 1;
            continue;
          } else {
            i = j - 1;
            continue;
          }
        } else {
          j = findBeforeEqual(html2, i - 1);
          if (j === -1) {
            v = _.trim(html2.slice(lastPos, i));
            v = stripQuoteWrap(v);
            addAttr(tmpName, v);
            tmpName = false;
            lastPos = i + 1;
            continue;
          } else {
            continue;
          }
        }
      }
    }
    if (lastPos < html2.length) {
      if (tmpName === false) {
        addAttr(html2.slice(lastPos));
      } else {
        addAttr(tmpName, stripQuoteWrap(_.trim(html2.slice(lastPos))));
      }
    }
    return _.trim(retAttrs.join(" "));
  }
  function findNextEqual(str, i) {
    for (; i < str.length; i++) {
      var c = str[i];
      if (c === " ") continue;
      if (c === "=") return i;
      return -1;
    }
  }
  function findNextQuotationMark(str, i) {
    for (; i < str.length; i++) {
      var c = str[i];
      if (c === " ") continue;
      if (c === "'" || c === '"') return i;
      return -1;
    }
  }
  function findBeforeEqual(str, i) {
    for (; i > 0; i--) {
      var c = str[i];
      if (c === " ") continue;
      if (c === "=") return i;
      return -1;
    }
  }
  function isQuoteWrapString(text) {
    if (text[0] === '"' && text[text.length - 1] === '"' || text[0] === "'" && text[text.length - 1] === "'") {
      return true;
    } else {
      return false;
    }
  }
  function stripQuoteWrap(text) {
    if (isQuoteWrapString(text)) {
      return text.substr(1, text.length - 2);
    } else {
      return text;
    }
  }
  parser.parseTag = parseTag;
  parser.parseAttr = parseAttr;
  return parser;
}
var xss;
var hasRequiredXss;
function requireXss() {
  if (hasRequiredXss) return xss;
  hasRequiredXss = 1;
  var FilterCSS = requireLib$1().FilterCSS;
  var DEFAULT = require_default();
  var parser2 = requireParser();
  var parseTag = parser2.parseTag;
  var parseAttr = parser2.parseAttr;
  var _ = requireUtil();
  function isNull(obj) {
    return obj === void 0 || obj === null;
  }
  function getAttrs(html2) {
    var i = _.spaceIndex(html2);
    if (i === -1) {
      return {
        html: "",
        closing: html2[html2.length - 2] === "/"
      };
    }
    html2 = _.trim(html2.slice(i + 1, -1));
    var isClosing = html2[html2.length - 1] === "/";
    if (isClosing) html2 = _.trim(html2.slice(0, -1));
    return {
      html: html2,
      closing: isClosing
    };
  }
  function shallowCopyObject(obj) {
    var ret = {};
    for (var i in obj) {
      ret[i] = obj[i];
    }
    return ret;
  }
  function keysToLowerCase(obj) {
    var ret = {};
    for (var i in obj) {
      if (Array.isArray(obj[i])) {
        ret[i.toLowerCase()] = obj[i].map(function(item) {
          return item.toLowerCase();
        });
      } else {
        ret[i.toLowerCase()] = obj[i];
      }
    }
    return ret;
  }
  function FilterXSS(options) {
    options = shallowCopyObject(options || {});
    if (options.stripIgnoreTag) {
      if (options.onIgnoreTag) {
        console.error(
          'Notes: cannot use these two options "stripIgnoreTag" and "onIgnoreTag" at the same time'
        );
      }
      options.onIgnoreTag = DEFAULT.onIgnoreTagStripAll;
    }
    if (options.whiteList || options.allowList) {
      options.whiteList = keysToLowerCase(options.whiteList || options.allowList);
    } else {
      options.whiteList = DEFAULT.whiteList;
    }
    this.attributeWrapSign = options.singleQuotedAttributeValue === true ? "'" : DEFAULT.attributeWrapSign;
    options.onTag = options.onTag || DEFAULT.onTag;
    options.onTagAttr = options.onTagAttr || DEFAULT.onTagAttr;
    options.onIgnoreTag = options.onIgnoreTag || DEFAULT.onIgnoreTag;
    options.onIgnoreTagAttr = options.onIgnoreTagAttr || DEFAULT.onIgnoreTagAttr;
    options.safeAttrValue = options.safeAttrValue || DEFAULT.safeAttrValue;
    options.escapeHtml = options.escapeHtml || DEFAULT.escapeHtml;
    this.options = options;
    if (options.css === false) {
      this.cssFilter = false;
    } else {
      options.css = options.css || {};
      this.cssFilter = new FilterCSS(options.css);
    }
  }
  FilterXSS.prototype.process = function(html2) {
    html2 = html2 || "";
    html2 = html2.toString();
    if (!html2) return "";
    var me = this;
    var options = me.options;
    var whiteList = options.whiteList;
    var onTag = options.onTag;
    var onIgnoreTag = options.onIgnoreTag;
    var onTagAttr = options.onTagAttr;
    var onIgnoreTagAttr = options.onIgnoreTagAttr;
    var safeAttrValue = options.safeAttrValue;
    var escapeHtml = options.escapeHtml;
    var attributeWrapSign = me.attributeWrapSign;
    var cssFilter = me.cssFilter;
    if (options.stripBlankChar) {
      html2 = DEFAULT.stripBlankChar(html2);
    }
    if (!options.allowCommentTag) {
      html2 = DEFAULT.stripCommentTag(html2);
    }
    var stripIgnoreTagBody = false;
    if (options.stripIgnoreTagBody) {
      stripIgnoreTagBody = DEFAULT.StripTagBody(
        options.stripIgnoreTagBody,
        onIgnoreTag
      );
      onIgnoreTag = stripIgnoreTagBody.onIgnoreTag;
    }
    var retHtml = parseTag(
      html2,
      function(sourcePosition, position, tag, html3, isClosing) {
        var info = {
          sourcePosition,
          position,
          isClosing,
          isWhite: Object.prototype.hasOwnProperty.call(whiteList, tag)
        };
        var ret = onTag(tag, html3, info);
        if (!isNull(ret)) return ret;
        if (info.isWhite) {
          if (info.isClosing) {
            return "</" + tag + ">";
          }
          var attrs = getAttrs(html3);
          var whiteAttrList = whiteList[tag];
          var attrsHtml = parseAttr(attrs.html, function(name, value) {
            var isWhiteAttr = _.indexOf(whiteAttrList, name) !== -1;
            var ret2 = onTagAttr(tag, name, value, isWhiteAttr);
            if (!isNull(ret2)) return ret2;
            if (isWhiteAttr) {
              value = safeAttrValue(tag, name, value, cssFilter);
              if (value) {
                return name + "=" + attributeWrapSign + value + attributeWrapSign;
              } else {
                return name;
              }
            } else {
              ret2 = onIgnoreTagAttr(tag, name, value, isWhiteAttr);
              if (!isNull(ret2)) return ret2;
              return;
            }
          });
          html3 = "<" + tag;
          if (attrsHtml) html3 += " " + attrsHtml;
          if (attrs.closing) html3 += " /";
          html3 += ">";
          return html3;
        } else {
          ret = onIgnoreTag(tag, html3, info);
          if (!isNull(ret)) return ret;
          return escapeHtml(html3);
        }
      },
      escapeHtml
    );
    if (stripIgnoreTagBody) {
      retHtml = stripIgnoreTagBody.remove(retHtml);
    }
    return retHtml;
  };
  xss = FilterXSS;
  return xss;
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib$1.exports;
  hasRequiredLib = 1;
  (function(module, exports) {
    var DEFAULT = require_default();
    var parser2 = requireParser();
    var FilterXSS = requireXss();
    function filterXSS(html2, options) {
      var xss2 = new FilterXSS(options);
      return xss2.process(html2);
    }
    exports = module.exports = filterXSS;
    exports.filterXSS = filterXSS;
    exports.FilterXSS = FilterXSS;
    (function() {
      for (var i in DEFAULT) {
        exports[i] = DEFAULT[i];
      }
      for (var j in parser2) {
        exports[j] = parser2[j];
      }
    })();
    if (typeof window !== "undefined") {
      window.filterXSS = module.exports;
    }
    function isWorkerEnv() {
      return typeof self !== "undefined" && typeof DedicatedWorkerGlobalScope !== "undefined" && self instanceof DedicatedWorkerGlobalScope;
    }
    if (isWorkerEnv()) {
      self.filterXSS = module.exports;
    }
  })(lib$1, lib$1.exports);
  return lib$1.exports;
}
var libExports = requireLib();
var xssFilter = getDefaultExportFromCjs(libExports);
function ownKeys(e, r) {
  var t = _Object$keys(e);
  if (_Object$getOwnPropertySymbols) {
    var o = _Object$getOwnPropertySymbols(e);
    r && (o = _filterInstanceProperty(o).call(o, function(r2) {
      return _Object$getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var _context8, _context9;
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? _forEachInstanceProperty(_context8 = ownKeys(Object(t), true)).call(_context8, function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : _forEachInstanceProperty(_context9 = ownKeys(Object(t))).call(_context9, function(r2) {
      _Object$defineProperty(e, r2, _Object$getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function isDataViewLike(obj) {
  var _obj$idProp;
  if (!obj) {
    return false;
  }
  let idProp = (_obj$idProp = obj.idProp) !== null && _obj$idProp !== void 0 ? _obj$idProp : obj._idProp;
  if (!idProp) {
    return false;
  }
  return isDataViewLike$1(idProp, obj);
}
var ASPDateRegex = /^\/?Date\((-?\d+)/i;
var NumericRegex = /^\d+$/;
function convert(object2, type) {
  let match;
  if (object2 === void 0) {
    return void 0;
  }
  if (object2 === null) {
    return null;
  }
  if (!type) {
    return object2;
  }
  if (!(typeof type === "string") && !(type instanceof String)) {
    throw new Error("Type must be a string");
  }
  switch (type) {
    case "boolean":
    case "Boolean":
      return Boolean(object2);
    case "number":
    case "Number":
      if (isString(object2) && !isNaN(Date.parse(object2))) {
        return moment$3(object2).valueOf();
      } else {
        return Number(object2.valueOf());
      }
    case "string":
    case "String":
      return String(object2);
    case "Date":
      try {
        return convert(object2, "Moment").toDate();
      } catch (e) {
        if (e instanceof TypeError) {
          throw new TypeError("Cannot convert object of type " + getType(object2) + " to type " + type);
        } else {
          throw e;
        }
      }
    case "Moment":
      if (isNumber(object2)) {
        return moment$3(object2);
      }
      if (object2 instanceof Date) {
        return moment$3(object2.valueOf());
      } else if (moment$3.isMoment(object2)) {
        return moment$3(object2);
      }
      if (isString(object2)) {
        match = ASPDateRegex.exec(object2);
        if (match) {
          return moment$3(Number(match[1]));
        }
        match = NumericRegex.exec(object2);
        if (match) {
          return moment$3(Number(object2));
        }
        return moment$3(object2);
      } else {
        throw new TypeError("Cannot convert object of type " + getType(object2) + " to type " + type);
      }
    case "ISODate":
      if (isNumber(object2)) {
        return new Date(object2);
      } else if (object2 instanceof Date) {
        return object2.toISOString();
      } else if (moment$3.isMoment(object2)) {
        return object2.toDate().toISOString();
      } else if (isString(object2)) {
        match = ASPDateRegex.exec(object2);
        if (match) {
          return new Date(Number(match[1])).toISOString();
        } else {
          return moment$3(object2).format();
        }
      } else {
        throw new Error("Cannot convert object of type " + getType(object2) + " to type ISODate");
      }
    case "ASPDate":
      if (isNumber(object2)) {
        return "/Date(" + object2 + ")/";
      } else if (object2 instanceof Date || moment$3.isMoment(object2)) {
        return "/Date(" + object2.valueOf() + ")/";
      } else if (isString(object2)) {
        match = ASPDateRegex.exec(object2);
        let value;
        if (match) {
          value = new Date(Number(match[1])).valueOf();
        } else {
          value = new Date(object2).valueOf();
        }
        return "/Date(" + value + ")/";
      } else {
        throw new Error("Cannot convert object of type " + getType(object2) + " to type ASPDate");
      }
    default:
      throw new Error("Unknown type ".concat(type));
  }
}
function typeCoerceDataSet(rawDS) {
  var _context, _context3, _context4, _context5, _context6, _context7;
  let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    start: "Date",
    end: "Date"
  };
  const idProp = rawDS._idProp;
  const coercedDS = new DataSet({
    fieldId: idProp
  });
  const pipe = _mapInstanceProperty(_context = createNewDataPipeFrom(rawDS)).call(_context, (item) => {
    var _context2;
    return _reduceInstanceProperty(_context2 = _Object$keys(item)).call(_context2, (acc, key) => {
      acc[key] = convert(item[key], type[key]);
      return acc;
    }, {});
  }).to(coercedDS);
  pipe.all().start();
  return {
    // Write only.
    add: function() {
      return rawDS.getDataSet().add(...arguments);
    },
    remove: function() {
      return rawDS.getDataSet().remove(...arguments);
    },
    update: function() {
      return rawDS.getDataSet().update(...arguments);
    },
    updateOnly: function() {
      return rawDS.getDataSet().updateOnly(...arguments);
    },
    clear: function() {
      return rawDS.getDataSet().clear(...arguments);
    },
    // Read only.
    forEach: _bindInstanceProperty(_context3 = _forEachInstanceProperty(coercedDS)).call(_context3, coercedDS),
    get: _bindInstanceProperty(_context4 = coercedDS.get).call(_context4, coercedDS),
    getIds: _bindInstanceProperty(_context5 = coercedDS.getIds).call(_context5, coercedDS),
    off: _bindInstanceProperty(_context6 = coercedDS.off).call(_context6, coercedDS),
    on: _bindInstanceProperty(_context7 = coercedDS.on).call(_context7, coercedDS),
    get length() {
      return coercedDS.length;
    },
    // Non standard.
    idProp,
    type,
    rawDS,
    coercedDS,
    dispose: () => pipe.stop()
  };
}
var setupXSSCleaner = (options) => {
  const customXSS = new xssFilter.FilterXSS(options);
  return (input) => {
    if (typeof input === "string") {
      return customXSS.process(input);
    }
    return input;
  };
};
var setupNoOpCleaner = (string2) => string2;
var configuredXSSProtection = setupXSSCleaner();
var setupXSSProtection = (options) => {
  if (!options) {
    return;
  }
  if (options.disabled === true) {
    configuredXSSProtection = setupNoOpCleaner;
    console.warn("You disabled XSS protection for vis-Timeline. I sure hope you know what you're doing!");
  } else {
    if (options.filterOptions) {
      configuredXSSProtection = setupXSSCleaner(options.filterOptions);
    }
  }
};
var availableUtils = _objectSpread(_objectSpread({}, util$2), {}, {
  convert,
  setupXSSProtection
});
_Object$defineProperty(availableUtils, "xss", {
  get: function() {
    return configuredXSSProtection;
  }
});
var es_parseFloat = {};
var numberParseFloat;
var hasRequiredNumberParseFloat;
function requireNumberParseFloat() {
  if (hasRequiredNumberParseFloat) return numberParseFloat;
  hasRequiredNumberParseFloat = 1;
  var globalThis2 = requireGlobalThis();
  var fails2 = requireFails();
  var uncurryThis = requireFunctionUncurryThis();
  var toString2 = requireToString();
  var trim = requireStringTrim().trim;
  var whitespaces2 = requireWhitespaces();
  var charAt = uncurryThis("".charAt);
  var $parseFloat = globalThis2.parseFloat;
  var Symbol2 = globalThis2.Symbol;
  var ITERATOR = Symbol2 && Symbol2.iterator;
  var FORCED = 1 / $parseFloat(whitespaces2 + "-0") !== -Infinity || ITERATOR && !fails2(function() {
    $parseFloat(Object(ITERATOR));
  });
  numberParseFloat = FORCED ? function parseFloat2(string2) {
    var trimmedString = trim(toString2(string2));
    var result = $parseFloat(trimmedString);
    return result === 0 && charAt(trimmedString, 0) === "-" ? -0 : result;
  } : $parseFloat;
  return numberParseFloat;
}
var hasRequiredEs_parseFloat;
function requireEs_parseFloat() {
  if (hasRequiredEs_parseFloat) return es_parseFloat;
  hasRequiredEs_parseFloat = 1;
  var $ = require_export();
  var $parseFloat = requireNumberParseFloat();
  $({ global: true, forced: parseFloat !== $parseFloat }, {
    parseFloat: $parseFloat
  });
  return es_parseFloat;
}
var _parseFloat$3;
var hasRequired_parseFloat$2;
function require_parseFloat$2() {
  if (hasRequired_parseFloat$2) return _parseFloat$3;
  hasRequired_parseFloat$2 = 1;
  requireEs_parseFloat();
  var path2 = requirePath();
  _parseFloat$3 = path2.parseFloat;
  return _parseFloat$3;
}
var _parseFloat$2;
var hasRequired_parseFloat$1;
function require_parseFloat$1() {
  if (hasRequired_parseFloat$1) return _parseFloat$2;
  hasRequired_parseFloat$1 = 1;
  var parent = require_parseFloat$2();
  _parseFloat$2 = parent;
  return _parseFloat$2;
}
var _parseFloat$1;
var hasRequired_parseFloat;
function require_parseFloat() {
  if (hasRequired_parseFloat) return _parseFloat$1;
  hasRequired_parseFloat = 1;
  _parseFloat$1 = require_parseFloat$1();
  return _parseFloat$1;
}
var _parseFloatExports = require_parseFloat();
var _parseFloat = getDefaultExportFromCjs(_parseFloatExports);
var Component = class {
  /**
   */
  constructor() {
    this.options = null;
    this.props = null;
  }
  /**
   * Set options for the component. The new options will be merged into the
   * current options.
   * @param {Object} options
   */
  setOptions(options) {
    if (options) {
      availableUtils.extend(this.options, options);
    }
  }
  /**
   * Repaint the component
   * @return {boolean} Returns true if the component is resized
   */
  redraw() {
    return false;
  }
  /**
   * Destroy the component. Cleanup DOM and event listeners
   */
  destroy() {
  }
  /**
   * Test whether the component is resized since the last time _isResized() was
   * called.
   * @return {Boolean} Returns true if the component is resized
   * @protected
   */
  _isResized() {
    const resized = this.props._previousWidth !== this.props.width || this.props._previousHeight !== this.props.height;
    this.props._previousWidth = this.props.width;
    this.props._previousHeight = this.props.height;
    return resized;
  }
};
var es_string_repeat = {};
var hasRequiredEs_string_repeat;
function requireEs_string_repeat() {
  if (hasRequiredEs_string_repeat) return es_string_repeat;
  hasRequiredEs_string_repeat = 1;
  var $ = require_export();
  var repeat2 = requireStringRepeat();
  $({ target: "String", proto: true }, {
    repeat: repeat2
  });
  return es_string_repeat;
}
var repeat$3;
var hasRequiredRepeat$3;
function requireRepeat$3() {
  if (hasRequiredRepeat$3) return repeat$3;
  hasRequiredRepeat$3 = 1;
  requireEs_string_repeat();
  var getBuiltInPrototypeMethod2 = requireGetBuiltInPrototypeMethod();
  repeat$3 = getBuiltInPrototypeMethod2("String", "repeat");
  return repeat$3;
}
var repeat$2;
var hasRequiredRepeat$2;
function requireRepeat$2() {
  if (hasRequiredRepeat$2) return repeat$2;
  hasRequiredRepeat$2 = 1;
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var method = requireRepeat$3();
  var StringPrototype = String.prototype;
  repeat$2 = function(it2) {
    var own = it2.repeat;
    return typeof it2 == "string" || it2 === StringPrototype || isPrototypeOf(StringPrototype, it2) && own === StringPrototype.repeat ? method : own;
  };
  return repeat$2;
}
var repeat$1;
var hasRequiredRepeat$1;
function requireRepeat$1() {
  if (hasRequiredRepeat$1) return repeat$1;
  hasRequiredRepeat$1 = 1;
  var parent = requireRepeat$2();
  repeat$1 = parent;
  return repeat$1;
}
var repeat;
var hasRequiredRepeat;
function requireRepeat() {
  if (hasRequiredRepeat) return repeat;
  hasRequiredRepeat = 1;
  repeat = requireRepeat$1();
  return repeat;
}
var repeatExports = requireRepeat();
var _repeatInstanceProperty = getDefaultExportFromCjs(repeatExports);
function convertHiddenOptions(moment2, body, hiddenDates) {
  if (hiddenDates && !_Array$isArray(hiddenDates)) {
    return convertHiddenOptions(moment2, body, [hiddenDates]);
  }
  body.hiddenDates = [];
  if (hiddenDates) {
    if (_Array$isArray(hiddenDates) == true) {
      var _context;
      for (let i = 0; i < hiddenDates.length; i++) {
        if (_repeatInstanceProperty(hiddenDates[i]) === void 0) {
          const dateItem = {};
          dateItem.start = moment2(hiddenDates[i].start).toDate().valueOf();
          dateItem.end = moment2(hiddenDates[i].end).toDate().valueOf();
          body.hiddenDates.push(dateItem);
        }
      }
      _sortInstanceProperty(_context = body.hiddenDates).call(_context, (a, b) => a.start - b.start);
    }
  }
}
function updateHiddenDates(moment2, body, hiddenDates) {
  if (hiddenDates && !_Array$isArray(hiddenDates)) {
    return updateHiddenDates(moment2, body, [hiddenDates]);
  }
  if (hiddenDates && body.domProps.centerContainer.width !== void 0) {
    convertHiddenOptions(moment2, body, hiddenDates);
    const start = moment2(body.range.start);
    const end = moment2(body.range.end);
    const totalRange = body.range.end - body.range.start;
    const pixelTime = totalRange / body.domProps.centerContainer.width;
    for (let i = 0; i < hiddenDates.length; i++) {
      if (_repeatInstanceProperty(hiddenDates[i]) !== void 0) {
        let startDate = moment2(hiddenDates[i].start);
        let endDate = moment2(hiddenDates[i].end);
        if (startDate._d == "Invalid Date") {
          throw new Error("Supplied start date is not valid: ".concat(hiddenDates[i].start));
        }
        if (endDate._d == "Invalid Date") {
          throw new Error("Supplied end date is not valid: ".concat(hiddenDates[i].end));
        }
        const duration = endDate - startDate;
        if (duration >= 4 * pixelTime) {
          let offset = 0;
          let runUntil = end.clone();
          switch (_repeatInstanceProperty(hiddenDates[i])) {
            case "daily":
              if (startDate.day() != endDate.day()) {
                offset = 1;
              }
              startDate = startDate.dayOfYear(start.dayOfYear()).year(start.year()).subtract(7, "days");
              endDate = endDate.dayOfYear(start.dayOfYear()).year(start.year()).subtract(7 - offset, "days");
              runUntil.add(1, "weeks");
              break;
            case "weekly": {
              const dayOffset = endDate.diff(startDate, "days");
              const day = startDate.day();
              startDate = startDate.date(start.date()).month(start.month()).year(start.year());
              endDate = startDate.clone();
              startDate = startDate.day(day).subtract(1, "weeks");
              endDate = endDate.day(day).add(dayOffset, "days").subtract(1, "weeks");
              runUntil.add(1, "weeks");
              break;
            }
            case "monthly":
              if (startDate.month() != endDate.month()) {
                offset = 1;
              }
              startDate = startDate.month(start.month()).year(start.year()).subtract(1, "months");
              endDate = endDate.month(start.month()).year(start.year()).subtract(1, "months").add(offset, "months");
              runUntil.add(1, "months");
              break;
            case "yearly":
              if (startDate.year() != endDate.year()) {
                offset = 1;
              }
              startDate = startDate.year(start.year()).subtract(1, "years");
              endDate = endDate.year(start.year()).subtract(1, "years").add(offset, "years");
              runUntil.add(1, "years");
              break;
            default:
              console.log("Wrong repeat format, allowed are: daily, weekly, monthly, yearly. Given:", _repeatInstanceProperty(hiddenDates[i]));
              return;
          }
          while (startDate < runUntil) {
            body.hiddenDates.push({
              start: startDate.valueOf(),
              end: endDate.valueOf()
            });
            switch (_repeatInstanceProperty(hiddenDates[i])) {
              case "daily":
                startDate = startDate.add(1, "days");
                endDate = endDate.add(1, "days");
                break;
              case "weekly":
                startDate = startDate.add(1, "weeks");
                endDate = endDate.add(1, "weeks");
                break;
              case "monthly":
                startDate = startDate.add(1, "months");
                endDate = endDate.add(1, "months");
                break;
              case "yearly":
                startDate = startDate.add(1, "y");
                endDate = endDate.add(1, "y");
                break;
              default:
                console.log("Wrong repeat format, allowed are: daily, weekly, monthly, yearly. Given:", _repeatInstanceProperty(hiddenDates[i]));
                return;
            }
          }
          body.hiddenDates.push({
            start: startDate.valueOf(),
            end: endDate.valueOf()
          });
        }
      }
    }
    removeDuplicates(body);
    const startHidden = getIsHidden(body.range.start, body.hiddenDates);
    const endHidden = getIsHidden(body.range.end, body.hiddenDates);
    let rangeStart = body.range.start;
    let rangeEnd = body.range.end;
    if (startHidden.hidden == true) {
      rangeStart = body.range.startToFront == true ? startHidden.startDate - 1 : startHidden.endDate + 1;
    }
    if (endHidden.hidden == true) {
      rangeEnd = body.range.endToFront == true ? endHidden.startDate - 1 : endHidden.endDate + 1;
    }
    if (startHidden.hidden == true || endHidden.hidden == true) {
      body.range._applyRange(rangeStart, rangeEnd);
    }
  }
}
function removeDuplicates(body) {
  var _context2;
  const hiddenDates = body.hiddenDates;
  const safeDates = [];
  for (var i = 0; i < hiddenDates.length; i++) {
    for (let j = 0; j < hiddenDates.length; j++) {
      if (i != j && hiddenDates[j].remove != true && hiddenDates[i].remove != true) {
        if (hiddenDates[j].start >= hiddenDates[i].start && hiddenDates[j].end <= hiddenDates[i].end) {
          hiddenDates[j].remove = true;
        } else if (hiddenDates[j].start >= hiddenDates[i].start && hiddenDates[j].start <= hiddenDates[i].end) {
          hiddenDates[i].end = hiddenDates[j].end;
          hiddenDates[j].remove = true;
        } else if (hiddenDates[j].end >= hiddenDates[i].start && hiddenDates[j].end <= hiddenDates[i].end) {
          hiddenDates[i].start = hiddenDates[j].start;
          hiddenDates[j].remove = true;
        }
      }
    }
  }
  for (i = 0; i < hiddenDates.length; i++) {
    if (hiddenDates[i].remove !== true) {
      safeDates.push(hiddenDates[i]);
    }
  }
  body.hiddenDates = safeDates;
  _sortInstanceProperty(_context2 = body.hiddenDates).call(_context2, (a, b) => a.start - b.start);
}
function printDates(dates) {
  for (let i = 0; i < dates.length; i++) {
    console.log(i, new Date(dates[i].start), new Date(dates[i].end), dates[i].start, dates[i].end, dates[i].remove);
  }
}
function stepOverHiddenDates(moment2, timeStep, previousTime) {
  let stepInHidden = false;
  const currentValue = timeStep.current.valueOf();
  for (let i = 0; i < timeStep.hiddenDates.length; i++) {
    const startDate = timeStep.hiddenDates[i].start;
    var endDate = timeStep.hiddenDates[i].end;
    if (currentValue >= startDate && currentValue < endDate) {
      stepInHidden = true;
      break;
    }
  }
  if (stepInHidden == true && currentValue < timeStep._end.valueOf() && currentValue != previousTime) {
    const prevValue = moment2(previousTime);
    const newValue = moment2(endDate);
    if (prevValue.year() != newValue.year()) {
      timeStep.switchedYear = true;
    } else if (prevValue.month() != newValue.month()) {
      timeStep.switchedMonth = true;
    } else if (prevValue.dayOfYear() != newValue.dayOfYear()) {
      timeStep.switchedDay = true;
    }
    timeStep.current = newValue;
  }
}
function toScreen(Core2, time, width) {
  let conversion;
  if (Core2.body.hiddenDates.length == 0) {
    conversion = Core2.range.conversion(width);
    return (time.valueOf() - conversion.offset) * conversion.scale;
  } else {
    const hidden = getIsHidden(time, Core2.body.hiddenDates);
    if (hidden.hidden == true) {
      time = hidden.startDate;
    }
    const duration = getHiddenDurationBetween(Core2.body.hiddenDates, Core2.range.start, Core2.range.end);
    if (time < Core2.range.start) {
      conversion = Core2.range.conversion(width, duration);
      const hiddenBeforeStart = getHiddenDurationBeforeStart(Core2.body.hiddenDates, time, conversion.offset);
      time = Core2.options.moment(time).toDate().valueOf();
      time = time + hiddenBeforeStart;
      return -(conversion.offset - time.valueOf()) * conversion.scale;
    } else if (time > Core2.range.end) {
      const rangeAfterEnd = {
        start: Core2.range.start,
        end: time
      };
      time = correctTimeForHidden(Core2.options.moment, Core2.body.hiddenDates, rangeAfterEnd, time);
      conversion = Core2.range.conversion(width, duration);
      return (time.valueOf() - conversion.offset) * conversion.scale;
    } else {
      time = correctTimeForHidden(Core2.options.moment, Core2.body.hiddenDates, Core2.range, time);
      conversion = Core2.range.conversion(width, duration);
      return (time.valueOf() - conversion.offset) * conversion.scale;
    }
  }
}
function toTime(Core2, x, width) {
  if (Core2.body.hiddenDates.length == 0) {
    const conversion = Core2.range.conversion(width);
    return new Date(x / conversion.scale + conversion.offset);
  } else {
    const hiddenDuration = getHiddenDurationBetween(Core2.body.hiddenDates, Core2.range.start, Core2.range.end);
    const totalDuration = Core2.range.end - Core2.range.start - hiddenDuration;
    const partialDuration = totalDuration * x / width;
    const accumulatedHiddenDuration = getAccumulatedHiddenDuration(Core2.body.hiddenDates, Core2.range, partialDuration);
    return new Date(accumulatedHiddenDuration + partialDuration + Core2.range.start);
  }
}
function getHiddenDurationBetween(hiddenDates, start, end) {
  let duration = 0;
  for (let i = 0; i < hiddenDates.length; i++) {
    const startDate = hiddenDates[i].start;
    const endDate = hiddenDates[i].end;
    if (startDate >= start && endDate < end) {
      duration += endDate - startDate;
    }
  }
  return duration;
}
function getHiddenDurationBeforeStart(hiddenDates, start, end) {
  let duration = 0;
  for (let i = 0; i < hiddenDates.length; i++) {
    const startDate = hiddenDates[i].start;
    const endDate = hiddenDates[i].end;
    if (startDate >= start && endDate <= end) {
      duration += endDate - startDate;
    }
  }
  return duration;
}
function correctTimeForHidden(moment2, hiddenDates, range, time) {
  time = moment2(time).toDate().valueOf();
  time -= getHiddenDurationBefore(moment2, hiddenDates, range, time);
  return time;
}
function getHiddenDurationBefore(moment2, hiddenDates, range, time) {
  let timeOffset = 0;
  time = moment2(time).toDate().valueOf();
  for (let i = 0; i < hiddenDates.length; i++) {
    const startDate = hiddenDates[i].start;
    const endDate = hiddenDates[i].end;
    if (startDate >= range.start && endDate < range.end) {
      if (time >= endDate) {
        timeOffset += endDate - startDate;
      }
    }
  }
  return timeOffset;
}
function getAccumulatedHiddenDuration(hiddenDates, range, requiredDuration) {
  let hiddenDuration = 0;
  let duration = 0;
  let previousPoint = range.start;
  for (let i = 0; i < hiddenDates.length; i++) {
    const startDate = hiddenDates[i].start;
    const endDate = hiddenDates[i].end;
    if (startDate >= range.start && endDate < range.end) {
      duration += startDate - previousPoint;
      previousPoint = endDate;
      if (duration >= requiredDuration) {
        break;
      } else {
        hiddenDuration += endDate - startDate;
      }
    }
  }
  return hiddenDuration;
}
function snapAwayFromHidden(hiddenDates, time, direction, correctionEnabled) {
  const isHidden = getIsHidden(time, hiddenDates);
  if (isHidden.hidden == true) {
    if (direction < 0) {
      if (correctionEnabled == true) {
        return isHidden.startDate - (isHidden.endDate - time) - 1;
      } else {
        return isHidden.startDate - 1;
      }
    } else {
      if (correctionEnabled == true) {
        return isHidden.endDate + (time - isHidden.startDate) + 1;
      } else {
        return isHidden.endDate + 1;
      }
    }
  } else {
    return time;
  }
}
function getIsHidden(time, hiddenDates) {
  for (let i = 0; i < hiddenDates.length; i++) {
    var startDate = hiddenDates[i].start;
    var endDate = hiddenDates[i].end;
    if (time >= startDate && time < endDate) {
      return {
        hidden: true,
        startDate,
        endDate
      };
    }
  }
  return {
    hidden: false,
    startDate,
    endDate
  };
}
var DateUtil = Object.freeze({
  __proto__: null,
  convertHiddenOptions,
  correctTimeForHidden,
  getAccumulatedHiddenDuration,
  getHiddenDurationBefore,
  getHiddenDurationBeforeStart,
  getHiddenDurationBetween,
  getIsHidden,
  printDates,
  removeDuplicates,
  snapAwayFromHidden,
  stepOverHiddenDates,
  toScreen,
  toTime,
  updateHiddenDates
});
var Range = class _Range extends Component {
  /**
   * @param {{dom: Object, domProps: Object, emitter: Emitter}} body
   * @param {Object} [options]    See description at Range.setOptions
   * @constructor Range
   * @extends Component
   */
  constructor(body, options) {
    var _context, _context2, _context3, _context4, _context5, _context6, _context7;
    super();
    const now2 = moment$2().hours(0).minutes(0).seconds(0).milliseconds(0);
    const start = now2.clone().add(-3, "days").valueOf();
    const end = now2.clone().add(3, "days").valueOf();
    this.millisecondsPerPixelCache = void 0;
    if (options === void 0) {
      this.start = start;
      this.end = end;
    } else {
      this.start = options.start || start;
      this.end = options.end || end;
    }
    this.rolling = false;
    this.body = body;
    this.deltaDifference = 0;
    this.scaleOffset = 0;
    this.startToFront = false;
    this.endToFront = true;
    this.defaultOptions = {
      rtl: false,
      start: null,
      end: null,
      moment: moment$2,
      direction: "horizontal",
      // 'horizontal' or 'vertical'
      moveable: true,
      zoomable: true,
      min: null,
      max: null,
      zoomMin: 10,
      // milliseconds
      zoomMax: 1e3 * 60 * 60 * 24 * 365 * 1e4,
      // milliseconds
      rollingMode: {
        follow: false,
        offset: 0.5
      }
    };
    this.options = availableUtils.extend({}, this.defaultOptions);
    this.props = {
      touch: {}
    };
    this.animationTimer = null;
    this.body.emitter.on("panstart", _bindInstanceProperty(_context = this._onDragStart).call(_context, this));
    this.body.emitter.on("panmove", _bindInstanceProperty(_context2 = this._onDrag).call(_context2, this));
    this.body.emitter.on("panend", _bindInstanceProperty(_context3 = this._onDragEnd).call(_context3, this));
    this.body.emitter.on("mousewheel", _bindInstanceProperty(_context4 = this._onMouseWheel).call(_context4, this));
    this.body.emitter.on("touch", _bindInstanceProperty(_context5 = this._onTouch).call(_context5, this));
    this.body.emitter.on("pinch", _bindInstanceProperty(_context6 = this._onPinch).call(_context6, this));
    this.body.dom.rollingModeBtn.addEventListener("click", _bindInstanceProperty(_context7 = this.startRolling).call(_context7, this));
    this.setOptions(options);
  }
  /**
   * Set options for the range controller
   * @param {Object} options      Available options:
   *                              {number | Date | String} start  Start date for the range
   *                              {number | Date | String} end    End date for the range
   *                              {number} min    Minimum value for start
   *                              {number} max    Maximum value for end
   *                              {number} zoomMin    Set a minimum value for
   *                                                  (end - start).
   *                              {number} zoomMax    Set a maximum value for
   *                                                  (end - start).
   *                              {boolean} moveable Enable moving of the range
   *                                                 by dragging. True by default
   *                              {boolean} zoomable Enable zooming of the range
   *                                                 by pinching/scrolling. True by default
   */
  setOptions(options) {
    if (options) {
      const fields = ["animation", "direction", "min", "max", "zoomMin", "zoomMax", "moveable", "zoomable", "moment", "activate", "hiddenDates", "zoomKey", "zoomFriction", "rtl", "showCurrentTime", "rollingMode", "horizontalScroll", "horizontalScrollKey", "horizontalScrollInvert", "verticalScroll"];
      availableUtils.selectiveExtend(fields, this.options, options);
      if (options.rollingMode && options.rollingMode.follow) {
        this.startRolling();
      }
      if ("start" in options || "end" in options) {
        this.setRange(options.start, options.end);
      }
    }
  }
  /**
   * Start auto refreshing the current time bar
   */
  startRolling() {
    const me = this;
    function update() {
      me.stopRolling();
      me.rolling = true;
      let interval = me.end - me.start;
      const t = availableUtils.convert(/* @__PURE__ */ new Date(), "Date").valueOf();
      const rollingModeOffset = me.options.rollingMode && me.options.rollingMode.offset || 0.5;
      const start = t - interval * rollingModeOffset;
      const end = t + interval * (1 - rollingModeOffset);
      const options = {
        animation: false
      };
      me.setRange(start, end, options);
      const scale = me.conversion(me.body.domProps.center.width).scale;
      interval = 1 / scale / 10;
      if (interval < 30) interval = 30;
      if (interval > 1e3) interval = 1e3;
      me.body.dom.rollingModeBtn.style.visibility = "hidden";
      me.currentTimeTimer = _setTimeout(update, interval);
    }
    update();
  }
  /**
   * Stop auto refreshing the current time bar
   */
  stopRolling() {
    if (this.currentTimeTimer !== void 0) {
      clearTimeout(this.currentTimeTimer);
      this.rolling = false;
      this.body.dom.rollingModeBtn.style.visibility = "visible";
    }
  }
  /**
   * Set a new start and end range
   * @param {Date | number | string} start
   * @param {Date | number | string} end
   * @param {Object} options      Available options:
   *                              {boolean | {duration: number, easingFunction: string}} [animation=false]
   *                                    If true, the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   *                              {boolean} [byUser=false]
   *                              {Event}  event  Mouse event
   * @param {Function} callback     a callback function to be executed at the end of this function
   * @param {Function} frameCallback    a callback function executed each frame of the range animation.
   *                                    The callback will be passed three parameters:
   *                                    {number} easeCoefficient    an easing coefficent
   *                                    {boolean} willDraw          If true the caller will redraw after the callback completes
   *                                    {boolean} done              If true then animation is ending after the current frame
   * @return {void}
   */
  setRange(start, end, options, callback, frameCallback) {
    if (!options) {
      options = {};
    }
    if (options.byUser !== true) {
      options.byUser = false;
    }
    const me = this;
    const finalStart = start != void 0 ? availableUtils.convert(start, "Date").valueOf() : null;
    const finalEnd = end != void 0 ? availableUtils.convert(end, "Date").valueOf() : null;
    this._cancelAnimation();
    this.millisecondsPerPixelCache = void 0;
    if (options.animation) {
      const initStart = this.start;
      const initEnd = this.end;
      const duration = typeof options.animation === "object" && "duration" in options.animation ? options.animation.duration : 500;
      const easingName = typeof options.animation === "object" && "easingFunction" in options.animation ? options.animation.easingFunction : "easeInOutQuad";
      const easingFunction = availableUtils.easingFunctions[easingName];
      if (!easingFunction) {
        var _context8;
        throw new Error(_concatInstanceProperty(_context8 = "Unknown easing function ".concat(_JSON$stringify(easingName), ". Choose from: ")).call(_context8, _Object$keys(availableUtils.easingFunctions).join(", ")));
      }
      const initTime = _Date$now();
      let anyChanged = false;
      const next = () => {
        if (!me.props.touch.dragging) {
          const now2 = _Date$now();
          const time = now2 - initTime;
          const ease = easingFunction(time / duration);
          const done = time > duration;
          const s = done || finalStart === null ? finalStart : initStart + (finalStart - initStart) * ease;
          const e = done || finalEnd === null ? finalEnd : initEnd + (finalEnd - initEnd) * ease;
          changed = me._applyRange(s, e);
          updateHiddenDates(me.options.moment, me.body, me.options.hiddenDates);
          anyChanged = anyChanged || changed;
          const params = {
            start: new Date(me.start),
            end: new Date(me.end),
            byUser: options.byUser,
            event: options.event
          };
          if (frameCallback) {
            frameCallback(ease, changed, done);
          }
          if (changed) {
            me.body.emitter.emit("rangechange", params);
          }
          if (done) {
            if (anyChanged) {
              me.body.emitter.emit("rangechanged", params);
              if (callback) {
                return callback();
              }
            }
          } else {
            me.animationTimer = _setTimeout(next, 20);
          }
        }
      };
      return next();
    } else {
      var changed = this._applyRange(finalStart, finalEnd);
      updateHiddenDates(this.options.moment, this.body, this.options.hiddenDates);
      if (changed) {
        const params = {
          start: new Date(this.start),
          end: new Date(this.end),
          byUser: options.byUser,
          event: options.event
        };
        this.body.emitter.emit("rangechange", params);
        clearTimeout(me.timeoutID);
        me.timeoutID = _setTimeout(() => {
          me.body.emitter.emit("rangechanged", params);
        }, 200);
        if (callback) {
          return callback();
        }
      }
    }
  }
  /**
   * Get the number of milliseconds per pixel.
   *
   * @returns {undefined|number}
   */
  getMillisecondsPerPixel() {
    if (this.millisecondsPerPixelCache === void 0) {
      this.millisecondsPerPixelCache = (this.end - this.start) / this.body.dom.center.clientWidth;
    }
    return this.millisecondsPerPixelCache;
  }
  /**
   * Stop an animation
   * @private
   */
  _cancelAnimation() {
    if (this.animationTimer) {
      clearTimeout(this.animationTimer);
      this.animationTimer = null;
    }
  }
  /**
   * Set a new start and end range. This method is the same as setRange, but
   * does not trigger a range change and range changed event, and it returns
   * true when the range is changed
   * @param {number} [start]
   * @param {number} [end]
   * @return {boolean} changed
   * @private
   */
  _applyRange(start, end) {
    let newStart = start != null ? availableUtils.convert(start, "Date").valueOf() : this.start;
    let newEnd = end != null ? availableUtils.convert(end, "Date").valueOf() : this.end;
    const max = this.options.max != null ? availableUtils.convert(this.options.max, "Date").valueOf() : null;
    const min = this.options.min != null ? availableUtils.convert(this.options.min, "Date").valueOf() : null;
    let diff;
    if (isNaN(newStart) || newStart === null) {
      throw new Error('Invalid start "'.concat(start, '"'));
    }
    if (isNaN(newEnd) || newEnd === null) {
      throw new Error('Invalid end "'.concat(end, '"'));
    }
    if (newEnd < newStart) {
      newEnd = newStart;
    }
    if (min !== null) {
      if (newStart < min) {
        diff = min - newStart;
        newStart += diff;
        newEnd += diff;
        if (max != null) {
          if (newEnd > max) {
            newEnd = max;
          }
        }
      }
    }
    if (max !== null) {
      if (newEnd > max) {
        diff = newEnd - max;
        newStart -= diff;
        newEnd -= diff;
        if (min != null) {
          if (newStart < min) {
            newStart = min;
          }
        }
      }
    }
    if (this.options.zoomMin !== null) {
      let zoomMin = _parseFloat(this.options.zoomMin);
      if (zoomMin < 0) {
        zoomMin = 0;
      }
      if (newEnd - newStart < zoomMin) {
        const compensation = 0.5;
        if (this.end - this.start === zoomMin && newStart >= this.start - compensation && newEnd <= this.end) {
          newStart = this.start;
          newEnd = this.end;
        } else {
          diff = zoomMin - (newEnd - newStart);
          newStart -= diff / 2;
          newEnd += diff / 2;
        }
      }
    }
    if (this.options.zoomMax !== null) {
      let zoomMax = _parseFloat(this.options.zoomMax);
      if (zoomMax < 0) {
        zoomMax = 0;
      }
      if (newEnd - newStart > zoomMax) {
        if (this.end - this.start === zoomMax && newStart < this.start && newEnd > this.end) {
          newStart = this.start;
          newEnd = this.end;
        } else {
          diff = newEnd - newStart - zoomMax;
          newStart += diff / 2;
          newEnd -= diff / 2;
        }
      }
    }
    const changed = this.start != newStart || this.end != newEnd;
    if (!(newStart >= this.start && newStart <= this.end || newEnd >= this.start && newEnd <= this.end) && !(this.start >= newStart && this.start <= newEnd || this.end >= newStart && this.end <= newEnd)) {
      this.body.emitter.emit("checkRangedItems");
    }
    this.start = newStart;
    this.end = newEnd;
    return changed;
  }
  /**
   * Retrieve the current range.
   * @return {Object} An object with start and end properties
   */
  getRange() {
    return {
      start: this.start,
      end: this.end
    };
  }
  /**
   * Calculate the conversion offset and scale for current range, based on
   * the provided width
   * @param {number} width
   * @param {number} [totalHidden=0]
   * @returns {{offset: number, scale: number}} conversion
   */
  conversion(width, totalHidden) {
    return _Range.conversion(this.start, this.end, width, totalHidden);
  }
  /**
   * Static method to calculate the conversion offset and scale for a range,
   * based on the provided start, end, and width
   * @param {number} start
   * @param {number} end
   * @param {number} width
   * @param {number} [totalHidden=0]
   * @returns {{offset: number, scale: number}} conversion
   */
  static conversion(start, end, width, totalHidden) {
    if (totalHidden === void 0) {
      totalHidden = 0;
    }
    if (width != 0 && end - start != 0) {
      return {
        offset: start,
        scale: width / (end - start - totalHidden)
      };
    } else {
      return {
        offset: 0,
        scale: 1
      };
    }
  }
  /**
   * Start dragging horizontally or vertically
   * @param {Event} event
   * @private
   */
  _onDragStart(event2) {
    this.deltaDifference = 0;
    this.previousDelta = 0;
    if (!this.options.moveable) return;
    if (!this._isInsideRange(event2)) return;
    if (!this.props.touch.allowDragging) return;
    this.stopRolling();
    this.props.touch.start = this.start;
    this.props.touch.end = this.end;
    this.props.touch.dragging = true;
    if (this.body.dom.root) {
      this.body.dom.root.style.cursor = "move";
    }
  }
  /**
   * Perform dragging operation
   * @param {Event} event
   * @private
   */
  _onDrag(event2) {
    if (!event2) return;
    if (!this.props.touch.dragging) return;
    if (!this.options.moveable) return;
    if (!this.props.touch.allowDragging) return;
    const direction = this.options.direction;
    validateDirection(direction);
    let delta = direction == "horizontal" ? event2.deltaX : event2.deltaY;
    delta -= this.deltaDifference;
    let interval = this.props.touch.end - this.props.touch.start;
    const duration = getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
    interval -= duration;
    const width = direction == "horizontal" ? this.body.domProps.center.width : this.body.domProps.center.height;
    let diffRange;
    if (this.options.rtl) {
      diffRange = delta / width * interval;
    } else {
      diffRange = -delta / width * interval;
    }
    const newStart = this.props.touch.start + diffRange;
    const newEnd = this.props.touch.end + diffRange;
    const safeStart = snapAwayFromHidden(this.body.hiddenDates, newStart, this.previousDelta - delta, true);
    const safeEnd = snapAwayFromHidden(this.body.hiddenDates, newEnd, this.previousDelta - delta, true);
    if (safeStart != newStart || safeEnd != newEnd) {
      this.deltaDifference += delta;
      this.props.touch.start = safeStart;
      this.props.touch.end = safeEnd;
      this._onDrag(event2);
      return;
    }
    this.previousDelta = delta;
    this._applyRange(newStart, newEnd);
    const startDate = new Date(this.start);
    const endDate = new Date(this.end);
    this.body.emitter.emit("rangechange", {
      start: startDate,
      end: endDate,
      byUser: true,
      event: event2
    });
    this.body.emitter.emit("panmove");
  }
  /**
   * Stop dragging operation
   * @param {event} event
   * @private
   */
  _onDragEnd(event2) {
    if (!this.props.touch.dragging) return;
    if (!this.options.moveable) return;
    if (!this.props.touch.allowDragging) return;
    this.props.touch.dragging = false;
    if (this.body.dom.root) {
      this.body.dom.root.style.cursor = "auto";
    }
    this.body.emitter.emit("rangechanged", {
      start: new Date(this.start),
      end: new Date(this.end),
      byUser: true,
      event: event2
    });
  }
  /**
   * Event handler for mouse wheel event, used to zoom
   * Code from http://adomas.org/javascript-mouse-wheel/
   * @param {Event} event
   * @private
   */
  _onMouseWheel(event2) {
    let delta = 0;
    if (event2.wheelDelta) {
      delta = event2.wheelDelta / 120;
    } else if (event2.detail) {
      delta = -event2.detail / 3;
    } else if (event2.deltaY) {
      delta = -event2.deltaY / 3;
    }
    if (this.options.zoomKey && !event2[this.options.zoomKey] && this.options.zoomable || !this.options.zoomable && this.options.moveable) {
      return;
    }
    if (!(this.options.zoomable && this.options.moveable)) return;
    if (!this._isInsideRange(event2)) return;
    if (delta) {
      const zoomFriction = this.options.zoomFriction || 5;
      let scale;
      if (delta < 0) {
        scale = 1 - delta / zoomFriction;
      } else {
        scale = 1 / (1 + delta / zoomFriction);
      }
      let pointerDate;
      if (this.rolling) {
        const rollingModeOffset = this.options.rollingMode && this.options.rollingMode.offset || 0.5;
        pointerDate = this.start + (this.end - this.start) * rollingModeOffset;
      } else {
        const pointer = this.getPointer({
          x: event2.clientX,
          y: event2.clientY
        }, this.body.dom.center);
        pointerDate = this._pointerToDate(pointer);
      }
      this.zoom(scale, pointerDate, delta, event2);
      event2.preventDefault();
    }
  }
  /**
   * Start of a touch gesture
   * @param {Event} event
   * @private
   */
  _onTouch(event2) {
    this.props.touch.start = this.start;
    this.props.touch.end = this.end;
    this.props.touch.allowDragging = true;
    this.props.touch.center = null;
    this.props.touch.centerDate = null;
    this.scaleOffset = 0;
    this.deltaDifference = 0;
    availableUtils.preventDefault(event2);
  }
  /**
   * Handle pinch event
   * @param {Event} event
   * @private
   */
  _onPinch(event2) {
    if (!(this.options.zoomable && this.options.moveable)) return;
    availableUtils.preventDefault(event2);
    this.props.touch.allowDragging = false;
    if (!this.props.touch.center) {
      this.props.touch.center = this.getPointer(event2.center, this.body.dom.center);
      this.props.touch.centerDate = this._pointerToDate(this.props.touch.center);
    }
    this.stopRolling();
    const scale = 1 / (event2.scale + this.scaleOffset);
    const centerDate = this.props.touch.centerDate;
    const hiddenDuration = getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
    const hiddenDurationBefore = getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this, centerDate);
    const hiddenDurationAfter = hiddenDuration - hiddenDurationBefore;
    let newStart = centerDate - hiddenDurationBefore + (this.props.touch.start - (centerDate - hiddenDurationBefore)) * scale;
    let newEnd = centerDate + hiddenDurationAfter + (this.props.touch.end - (centerDate + hiddenDurationAfter)) * scale;
    this.startToFront = 1 - scale <= 0;
    this.endToFront = scale - 1 <= 0;
    const safeStart = snapAwayFromHidden(this.body.hiddenDates, newStart, 1 - scale, true);
    const safeEnd = snapAwayFromHidden(this.body.hiddenDates, newEnd, scale - 1, true);
    if (safeStart != newStart || safeEnd != newEnd) {
      this.props.touch.start = safeStart;
      this.props.touch.end = safeEnd;
      this.scaleOffset = 1 - event2.scale;
      newStart = safeStart;
      newEnd = safeEnd;
    }
    const options = {
      animation: false,
      byUser: true,
      event: event2
    };
    this.setRange(newStart, newEnd, options);
    this.startToFront = false;
    this.endToFront = true;
  }
  /**
   * Test whether the mouse from a mouse event is inside the visible window,
   * between the current start and end date
   * @param {Object} event
   * @return {boolean} Returns true when inside the visible window
   * @private
   */
  _isInsideRange(event2) {
    const clientX = event2.center ? event2.center.x : event2.clientX;
    const centerContainerRect = this.body.dom.centerContainer.getBoundingClientRect();
    const x = this.options.rtl ? clientX - centerContainerRect.left : centerContainerRect.right - clientX;
    const time = this.body.util.toTime(x);
    return time >= this.start && time <= this.end;
  }
  /**
   * Helper function to calculate the center date for zooming
   * @param {{x: number, y: number}} pointer
   * @return {number} date
   * @private
   */
  _pointerToDate(pointer) {
    let conversion;
    const direction = this.options.direction;
    validateDirection(direction);
    if (direction == "horizontal") {
      return this.body.util.toTime(pointer.x).valueOf();
    } else {
      const height = this.body.domProps.center.height;
      conversion = this.conversion(height);
      return pointer.y / conversion.scale + conversion.offset;
    }
  }
  /**
   * Get the pointer location relative to the location of the dom element
   * @param {{x: number, y: number}} touch
   * @param {Element} element   HTML DOM element
   * @return {{x: number, y: number}} pointer
   * @private
   */
  getPointer(touch, element) {
    const elementRect = element.getBoundingClientRect();
    if (this.options.rtl) {
      return {
        x: elementRect.right - touch.x,
        y: touch.y - elementRect.top
      };
    } else {
      return {
        x: touch.x - elementRect.left,
        y: touch.y - elementRect.top
      };
    }
  }
  /**
   * Zoom the range the given scale in or out. Start and end date will
   * be adjusted, and the timeline will be redrawn. You can optionally give a
   * date around which to zoom.
   * For example, try scale = 0.9 or 1.1
   * @param {number} scale      Scaling factor. Values above 1 will zoom out,
   *                            values below 1 will zoom in.
   * @param {number} [center]   Value representing a date around which will
   *                            be zoomed.
   * @param {number} delta
   * @param {Event} event
   */
  zoom(scale, center, delta, event2) {
    if (center == null) {
      center = (this.start + this.end) / 2;
    }
    const hiddenDuration = getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
    const hiddenDurationBefore = getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this, center);
    const hiddenDurationAfter = hiddenDuration - hiddenDurationBefore;
    let newStart = center - hiddenDurationBefore + (this.start - (center - hiddenDurationBefore)) * scale;
    let newEnd = center + hiddenDurationAfter + (this.end - (center + hiddenDurationAfter)) * scale;
    this.startToFront = delta > 0 ? false : true;
    this.endToFront = -delta > 0 ? false : true;
    const safeStart = snapAwayFromHidden(this.body.hiddenDates, newStart, delta, true);
    const safeEnd = snapAwayFromHidden(this.body.hiddenDates, newEnd, -delta, true);
    if (safeStart != newStart || safeEnd != newEnd) {
      newStart = safeStart;
      newEnd = safeEnd;
    }
    const options = {
      animation: false,
      byUser: true,
      event: event2
    };
    this.setRange(newStart, newEnd, options);
    this.startToFront = false;
    this.endToFront = true;
  }
  /**
   * Move the range with a given delta to the left or right. Start and end
   * value will be adjusted. For example, try delta = 0.1 or -0.1
   * @param {number}  delta     Moving amount. Positive value will move right,
   *                            negative value will move left
   */
  move(delta) {
    const diff = this.end - this.start;
    const newStart = this.start + diff * delta;
    const newEnd = this.end + diff * delta;
    this.start = newStart;
    this.end = newEnd;
  }
  /**
   * Move the range to a new center point
   * @param {number} moveTo      New center point of the range
   */
  moveTo(moveTo) {
    const center = (this.start + this.end) / 2;
    const diff = center - moveTo;
    const newStart = this.start - diff;
    const newEnd = this.end - diff;
    const options = {
      animation: false,
      byUser: true,
      event: null
    };
    this.setRange(newStart, newEnd, options);
  }
  /**
   * Destroy the Range
   */
  destroy() {
    this.stopRolling();
  }
};
function validateDirection(direction) {
  if (direction != "horizontal" && direction != "vertical") {
    throw new TypeError('Unknown direction "'.concat(direction, '". Choose "horizontal" or "vertical".'));
  }
}
var setInterval$1;
var hasRequiredSetInterval$1;
function requireSetInterval$1() {
  if (hasRequiredSetInterval$1) return setInterval$1;
  hasRequiredSetInterval$1 = 1;
  requireWeb_timers();
  var path2 = requirePath();
  setInterval$1 = path2.setInterval;
  return setInterval$1;
}
var setInterval;
var hasRequiredSetInterval;
function requireSetInterval() {
  if (hasRequiredSetInterval) return setInterval;
  hasRequiredSetInterval = 1;
  setInterval = requireSetInterval$1();
  return setInterval;
}
var setIntervalExports = requireSetInterval();
var _setInterval = getDefaultExportFromCjs(setIntervalExports);
var _firstTarget = null;
function propagating(hammer, options) {
  var _options = options || {
    preventDefault: false
  };
  if (hammer.Manager) {
    var Hammer2 = hammer;
    var PropagatingHammer = function(element2, options2) {
      var o = Object.create(_options);
      if (options2) Hammer2.assign(o, options2);
      return propagating(new Hammer2(element2, o), o);
    };
    Hammer2.assign(PropagatingHammer, Hammer2);
    PropagatingHammer.Manager = function(element2, options2) {
      var o = Object.create(_options);
      if (options2) Hammer2.assign(o, options2);
      return propagating(new Hammer2.Manager(element2, o), o);
    };
    return PropagatingHammer;
  }
  var wrapper = Object.create(hammer);
  var element = hammer.element;
  if (!element.hammer) element.hammer = [];
  element.hammer.push(wrapper);
  hammer.on("hammer.input", function(event2) {
    if (_options.preventDefault === true || _options.preventDefault === event2.pointerType) {
      event2.preventDefault();
    }
    if (event2.isFirst) {
      _firstTarget = event2.target;
    }
  });
  wrapper._handlers = {};
  wrapper.on = function(events, handler) {
    split(events).forEach(function(event2) {
      var _handlers = wrapper._handlers[event2];
      if (!_handlers) {
        wrapper._handlers[event2] = _handlers = [];
        hammer.on(event2, propagatedHandler);
      }
      _handlers.push(handler);
    });
    return wrapper;
  };
  wrapper.off = function(events, handler) {
    split(events).forEach(function(event2) {
      var _handlers = wrapper._handlers[event2];
      if (_handlers) {
        _handlers = handler ? _handlers.filter(function(h) {
          return h !== handler;
        }) : [];
        if (_handlers.length > 0) {
          wrapper._handlers[event2] = _handlers;
        } else {
          hammer.off(event2, propagatedHandler);
          delete wrapper._handlers[event2];
        }
      }
    });
    return wrapper;
  };
  wrapper.emit = function(eventType, event2) {
    _firstTarget = event2.target;
    hammer.emit(eventType, event2);
  };
  wrapper.destroy = function() {
    var hammers = hammer.element.hammer;
    var idx = hammers.indexOf(wrapper);
    if (idx !== -1) hammers.splice(idx, 1);
    if (!hammers.length) delete hammer.element.hammer;
    wrapper._handlers = {};
    hammer.destroy();
  };
  function split(events) {
    return events.match(/[^ ]+/g);
  }
  function propagatedHandler(event2) {
    if (event2.type !== "hammer.input") {
      if (!event2.srcEvent._handled) {
        event2.srcEvent._handled = {};
      }
      if (event2.srcEvent._handled[event2.type]) {
        return;
      } else {
        event2.srcEvent._handled[event2.type] = true;
      }
    }
    var stopped = false;
    event2.stopPropagation = function() {
      stopped = true;
    };
    var srcStop = event2.srcEvent.stopPropagation.bind(event2.srcEvent);
    if (typeof srcStop == "function") {
      event2.srcEvent.stopPropagation = function() {
        srcStop();
        event2.stopPropagation();
      };
    }
    event2.firstTarget = _firstTarget;
    var elem = _firstTarget.isConnected ? _firstTarget : event2.target;
    while (elem && !stopped) {
      var elemHammer = elem.hammer;
      if (elemHammer) {
        var _handlers;
        for (var k = 0; k < elemHammer.length; k++) {
          _handlers = elemHammer[k]._handlers[event2.type];
          if (_handlers) for (var i = 0; i < _handlers.length && !stopped; i++) {
            _handlers[i](event2);
          }
        }
      }
      elem = elem.parentNode;
    }
  }
  return wrapper;
}
function hammerMock() {
  const noop = () => {
  };
  return {
    on: noop,
    off: noop,
    destroy: noop,
    emit: noop,
    get() {
      return {
        set: noop
      };
    }
  };
}
var modifiedHammer;
if (typeof window !== "undefined") {
  const OurHammer = window["Hammer"] || Hammer$3;
  modifiedHammer = propagating(OurHammer, {
    preventDefault: "mouse"
  });
} else {
  modifiedHammer = function() {
    return hammerMock();
  };
}
var Hammer = modifiedHammer;
function onTouch(hammer, callback) {
  callback.inputHandler = function(event2) {
    if (event2.isFirst) {
      callback(event2);
    }
  };
  hammer.on("hammer.input", callback.inputHandler);
}
function onRelease(hammer, callback) {
  callback.inputHandler = function(event2) {
    if (event2.isFinal) {
      callback(event2);
    }
  };
  return hammer.on("hammer.input", callback.inputHandler);
}
function disablePreventDefaultVertically(pinchRecognizer) {
  const TOUCH_ACTION_PAN_Y2 = "pan-y";
  pinchRecognizer.getTouchAction = function() {
    return [TOUCH_ACTION_PAN_Y2];
  };
  return pinchRecognizer;
}
var TimeStep = class _TimeStep {
  /**
   * @param {Date} [start]         The start date, for example new Date(2010, 9, 21)
   *                               or new Date(2010, 9, 21, 23, 45, 00)
   * @param {Date} [end]           The end date
   * @param {number} [minimumStep] Optional. Minimum step size in milliseconds
   * @param {Date|Array.<Date>} [hiddenDates] Optional.
   * @param {{showMajorLabels: boolean, showWeekScale: boolean}} [options] Optional.
   * @constructor  TimeStep
   */
  constructor(start, end, minimumStep, hiddenDates, options) {
    this.moment = options && options.moment || moment$2;
    this.options = options ? options : {};
    this.current = this.moment();
    this._start = this.moment();
    this._end = this.moment();
    this.autoScale = true;
    this.scale = "day";
    this.step = 1;
    this.setRange(start, end, minimumStep);
    this.switchedDay = false;
    this.switchedMonth = false;
    this.switchedYear = false;
    if (_Array$isArray(hiddenDates)) {
      this.hiddenDates = hiddenDates;
    } else if (hiddenDates != void 0) {
      this.hiddenDates = [hiddenDates];
    } else {
      this.hiddenDates = [];
    }
    this.format = _TimeStep.FORMAT;
  }
  /**
   * Set custom constructor function for moment. Can be used to set dates
   * to UTC or to set a utcOffset.
   * @param {function} moment
   */
  setMoment(moment2) {
    this.moment = moment2;
    this.current = this.moment(this.current.valueOf());
    this._start = this.moment(this._start.valueOf());
    this._end = this.moment(this._end.valueOf());
  }
  /**
   * Set custom formatting for the minor an major labels of the TimeStep.
   * Both `minorLabels` and `majorLabels` are an Object with properties:
   * 'millisecond', 'second', 'minute', 'hour', 'weekday', 'day', 'week', 'month', 'year'.
   * @param {{minorLabels: Object, majorLabels: Object}} format
   */
  setFormat(format) {
    const defaultFormat = availableUtils.deepExtend({}, _TimeStep.FORMAT);
    this.format = availableUtils.deepExtend(defaultFormat, format);
  }
  /**
   * Set a new range
   * If minimumStep is provided, the step size is chosen as close as possible
   * to the minimumStep but larger than minimumStep. If minimumStep is not
   * provided, the scale is set to 1 DAY.
   * The minimumStep should correspond with the onscreen size of about 6 characters
   * @param {Date} [start]      The start date and time.
   * @param {Date} [end]        The end date and time.
   * @param {int} [minimumStep] Optional. Minimum step size in milliseconds
   */
  setRange(start, end, minimumStep) {
    if (!(start instanceof Date) || !(end instanceof Date)) {
      throw "No legal start or end date in method setRange";
    }
    this._start = start != void 0 ? this.moment(start.valueOf()) : _Date$now();
    this._end = end != void 0 ? this.moment(end.valueOf()) : _Date$now();
    if (this.autoScale) {
      this.setMinimumStep(minimumStep);
    }
  }
  /**
   * Set the range iterator to the start date.
   */
  start() {
    this.current = this._start.clone();
    this.roundToMinor();
  }
  /**
   * Round the current date to the first minor date value
   * This must be executed once when the current date is set to start Date
   */
  roundToMinor() {
    if (this.scale == "week") {
      this.current.weekday(0);
    }
    switch (this.scale) {
      case "year":
        this.current = this.current.year(this.step * Math.floor(this.current.year() / this.step)).month(0);
      // eslint-disable-next-line no-fallthrough
      case "month":
        this.current = this.current.date(1);
      // eslint-disable-next-line no-fallthrough
      case "week":
      case "day":
      case "weekday":
        this.current = this.current.hours(0);
      // eslint-disable-next-line no-fallthrough
      case "hour":
        this.current = this.current.minutes(0);
      // eslint-disable-next-line no-fallthrough
      case "minute":
        this.current = this.current.seconds(0);
      // eslint-disable-next-line no-fallthrough
      case "second":
        this.current = this.current.milliseconds(0);
    }
    if (this.step != 1) {
      let priorCurrent = this.current.clone();
      switch (this.scale) {
        case "millisecond":
          this.current = this.current.subtract(this.current.milliseconds() % this.step, "milliseconds");
          break;
        case "second":
          this.current = this.current.subtract(this.current.seconds() % this.step, "seconds");
          break;
        case "minute":
          this.current = this.current.subtract(this.current.minutes() % this.step, "minutes");
          break;
        case "hour":
          this.current = this.current.subtract(this.current.hours() % this.step, "hours");
          break;
        case "weekday":
        // intentional fall through
        case "day":
          this.current = this.current.subtract((this.current.date() - 1) % this.step, "day");
          break;
        case "week":
          this.current = this.current.subtract(this.current.week() % this.step, "week");
          break;
        case "month":
          this.current = this.current.subtract(this.current.month() % this.step, "month");
          break;
        case "year":
          this.current = this.current.subtract(this.current.year() % this.step, "year");
          break;
      }
      if (!priorCurrent.isSame(this.current)) {
        this.current = this.moment(snapAwayFromHidden(this.hiddenDates, this.current.valueOf(), -1, true));
      }
    }
  }
  /**
   * Check if the there is a next step
   * @return {boolean}  true if the current date has not passed the end date
   */
  hasNext() {
    return this.current.valueOf() <= this._end.valueOf();
  }
  /**
   * Do the next step
   */
  next() {
    const prev = this.current.valueOf();
    switch (this.scale) {
      case "millisecond":
        this.current = this.current.add(this.step, "millisecond");
        break;
      case "second":
        this.current = this.current.add(this.step, "second");
        break;
      case "minute":
        this.current = this.current.add(this.step, "minute");
        break;
      case "hour":
        this.current = this.current.add(this.step, "hour");
        if (this.current.month() < 6) {
          this.current = this.current.subtract(this.current.hours() % this.step, "hour");
        } else {
          if (this.current.hours() % this.step !== 0) {
            this.current = this.current.add(this.step - this.current.hours() % this.step, "hour");
          }
        }
        break;
      case "weekday":
      // intentional fall through
      case "day":
        this.current = this.current.add(this.step, "day");
        break;
      case "week":
        if (this.current.weekday() !== 0) {
          this.current = this.current.weekday(0).add(this.step, "week");
        } else if (this.options.showMajorLabels === false) {
          this.current = this.current.add(this.step, "week");
        } else {
          const nextWeek = this.current.clone();
          nextWeek.add(1, "week");
          if (nextWeek.isSame(this.current, "month")) {
            this.current = this.current.add(this.step, "week");
          } else {
            this.current = this.current.add(this.step, "week").date(1);
          }
        }
        break;
      case "month":
        this.current = this.current.add(this.step, "month");
        break;
      case "year":
        this.current = this.current.add(this.step, "year");
        break;
    }
    if (this.step != 1) {
      switch (this.scale) {
        case "millisecond":
          if (this.current.milliseconds() > 0 && this.current.milliseconds() < this.step) this.current = this.current.milliseconds(0);
          break;
        case "second":
          if (this.current.seconds() > 0 && this.current.seconds() < this.step) this.current = this.current.seconds(0);
          break;
        case "minute":
          if (this.current.minutes() > 0 && this.current.minutes() < this.step) this.current = this.current.minutes(0);
          break;
        case "hour":
          if (this.current.hours() > 0 && this.current.hours() < this.step) this.current = this.current.hours(0);
          break;
        case "weekday":
        // intentional fall through
        case "day":
          if (this.current.date() < this.step + 1) this.current = this.current.date(1);
          break;
        case "week":
          if (this.current.week() < this.step) this.current = this.current.week(1);
          break;
        case "month":
          if (this.current.month() < this.step) this.current = this.current.month(0);
          break;
      }
    }
    if (this.current.valueOf() == prev) {
      this.current = this._end.clone();
    }
    this.switchedDay = false;
    this.switchedMonth = false;
    this.switchedYear = false;
    stepOverHiddenDates(this.moment, this, prev);
  }
  /**
   * Get the current datetime
   * @return {Moment}  current The current date
   */
  getCurrent() {
    return this.current.clone();
  }
  /**
   * Set a custom scale. Autoscaling will be disabled.
   * For example setScale('minute', 5) will result
   * in minor steps of 5 minutes, and major steps of an hour.
   *
   * @param {{scale: string, step: number}} params
   *                               An object containing two properties:
   *                               - A string 'scale'. Choose from 'millisecond', 'second',
   *                                 'minute', 'hour', 'weekday', 'day', 'week', 'month', 'year'.
   *                               - A number 'step'. A step size, by default 1.
   *                                 Choose for example 1, 2, 5, or 10.
   */
  setScale(params) {
    if (params && typeof params.scale == "string") {
      this.scale = params.scale;
      this.step = params.step > 0 ? params.step : 1;
      this.autoScale = false;
    }
  }
  /**
   * Enable or disable autoscaling
   * @param {boolean} enable  If true, autoascaling is set true
   */
  setAutoScale(enable) {
    this.autoScale = enable;
  }
  /**
   * Automatically determine the scale that bests fits the provided minimum step
   * @param {number} [minimumStep]  The minimum step size in milliseconds
   */
  setMinimumStep(minimumStep) {
    if (minimumStep == void 0) {
      return;
    }
    const stepYear = 1e3 * 60 * 60 * 24 * 30 * 12;
    const stepMonth = 1e3 * 60 * 60 * 24 * 30;
    const stepDay = 1e3 * 60 * 60 * 24;
    const stepHour = 1e3 * 60 * 60;
    const stepMinute = 1e3 * 60;
    const stepSecond = 1e3;
    const stepMillisecond = 1;
    if (stepYear * 1e3 > minimumStep) {
      this.scale = "year";
      this.step = 1e3;
    }
    if (stepYear * 500 > minimumStep) {
      this.scale = "year";
      this.step = 500;
    }
    if (stepYear * 100 > minimumStep) {
      this.scale = "year";
      this.step = 100;
    }
    if (stepYear * 50 > minimumStep) {
      this.scale = "year";
      this.step = 50;
    }
    if (stepYear * 10 > minimumStep) {
      this.scale = "year";
      this.step = 10;
    }
    if (stepYear * 5 > minimumStep) {
      this.scale = "year";
      this.step = 5;
    }
    if (stepYear > minimumStep) {
      this.scale = "year";
      this.step = 1;
    }
    if (stepMonth * 3 > minimumStep) {
      this.scale = "month";
      this.step = 3;
    }
    if (stepMonth > minimumStep) {
      this.scale = "month";
      this.step = 1;
    }
    if (stepDay * 7 > minimumStep && this.options.showWeekScale) {
      this.scale = "week";
      this.step = 1;
    }
    if (stepDay * 2 > minimumStep) {
      this.scale = "day";
      this.step = 2;
    }
    if (stepDay > minimumStep) {
      this.scale = "day";
      this.step = 1;
    }
    if (stepDay / 2 > minimumStep) {
      this.scale = "weekday";
      this.step = 1;
    }
    if (stepHour * 4 > minimumStep) {
      this.scale = "hour";
      this.step = 4;
    }
    if (stepHour > minimumStep) {
      this.scale = "hour";
      this.step = 1;
    }
    if (stepMinute * 15 > minimumStep) {
      this.scale = "minute";
      this.step = 15;
    }
    if (stepMinute * 10 > minimumStep) {
      this.scale = "minute";
      this.step = 10;
    }
    if (stepMinute * 5 > minimumStep) {
      this.scale = "minute";
      this.step = 5;
    }
    if (stepMinute > minimumStep) {
      this.scale = "minute";
      this.step = 1;
    }
    if (stepSecond * 15 > minimumStep) {
      this.scale = "second";
      this.step = 15;
    }
    if (stepSecond * 10 > minimumStep) {
      this.scale = "second";
      this.step = 10;
    }
    if (stepSecond * 5 > minimumStep) {
      this.scale = "second";
      this.step = 5;
    }
    if (stepSecond > minimumStep) {
      this.scale = "second";
      this.step = 1;
    }
    if (stepMillisecond * 200 > minimumStep) {
      this.scale = "millisecond";
      this.step = 200;
    }
    if (stepMillisecond * 100 > minimumStep) {
      this.scale = "millisecond";
      this.step = 100;
    }
    if (stepMillisecond * 50 > minimumStep) {
      this.scale = "millisecond";
      this.step = 50;
    }
    if (stepMillisecond * 10 > minimumStep) {
      this.scale = "millisecond";
      this.step = 10;
    }
    if (stepMillisecond * 5 > minimumStep) {
      this.scale = "millisecond";
      this.step = 5;
    }
    if (stepMillisecond > minimumStep) {
      this.scale = "millisecond";
      this.step = 1;
    }
  }
  /**
   * Snap a date to a rounded value.
   * The snap intervals are dependent on the current scale and step.
   * Static function
   * @param {Date} date    the date to be snapped.
   * @param {string} scale Current scale, can be 'millisecond', 'second',
   *                       'minute', 'hour', 'weekday, 'day', 'week', 'month', 'year'.
   * @param {number} step  Current step (1, 2, 4, 5, ...
   * @return {Date} snappedDate
   */
  static snap(date2, scale, step) {
    let clone2 = moment$2(date2);
    if (scale == "year") {
      const year = clone2.year() + Math.round(clone2.month() / 12);
      clone2 = clone2.year(Math.round(year / step) * step).month(0).date(0).hours(0).minutes(0).seconds(0).milliseconds(0);
    } else if (scale == "month") {
      if (clone2.date() > 15) {
        clone2 = clone2.date(1).add(1, "month");
      } else {
        clone2 = clone2.date(1);
      }
      clone2 = clone2.hours(0).minutes(0).seconds(0).milliseconds(0);
    } else if (scale == "week") {
      if (clone2.weekday() > 2) {
        clone2 = clone2.weekday(0).add(1, "week");
      } else {
        clone2 = clone2.weekday(0);
      }
      clone2 = clone2.hours(0).minutes(0).seconds(0).milliseconds(0);
    } else if (scale == "day") {
      switch (step) {
        case 5:
        case 2:
          clone2 = clone2.hours(Math.round(clone2.hours() / 24) * 24);
          break;
        default:
          clone2 = clone2.hours(Math.round(clone2.hours() / 12) * 12);
          break;
      }
      clone2 = clone2.minutes(0).seconds(0).milliseconds(0);
    } else if (scale == "weekday") {
      switch (step) {
        case 5:
        case 2:
          clone2 = clone2.hours(Math.round(clone2.hours() / 12) * 12);
          break;
        default:
          clone2 = clone2.hours(Math.round(clone2.hours() / 6) * 6);
          break;
      }
      clone2 = clone2.minutes(0).seconds(0).milliseconds(0);
    } else if (scale == "hour") {
      switch (step) {
        case 4:
          clone2 = clone2.minutes(Math.round(clone2.minutes() / 60) * 60);
          break;
        default:
          clone2 = clone2.minutes(Math.round(clone2.minutes() / 30) * 30);
          break;
      }
      clone2 = clone2.seconds(0).milliseconds(0);
    } else if (scale == "minute") {
      switch (step) {
        case 15:
        case 10:
          clone2 = clone2.minutes(Math.round(clone2.minutes() / 5) * 5).seconds(0);
          break;
        case 5:
          clone2 = clone2.seconds(Math.round(clone2.seconds() / 60) * 60);
          break;
        default:
          clone2 = clone2.seconds(Math.round(clone2.seconds() / 30) * 30);
          break;
      }
      clone2 = clone2.milliseconds(0);
    } else if (scale == "second") {
      switch (step) {
        case 15:
        case 10:
          clone2 = clone2.seconds(Math.round(clone2.seconds() / 5) * 5).milliseconds(0);
          break;
        case 5:
          clone2 = clone2.milliseconds(Math.round(clone2.milliseconds() / 1e3) * 1e3);
          break;
        default:
          clone2 = clone2.milliseconds(Math.round(clone2.milliseconds() / 500) * 500);
          break;
      }
    } else if (scale == "millisecond") {
      const _step = step > 5 ? step / 2 : 1;
      clone2 = clone2.milliseconds(Math.round(clone2.milliseconds() / _step) * _step);
    }
    return clone2;
  }
  /**
   * Check if the current value is a major value (for example when the step
   * is DAY, a major value is each first day of the MONTH)
   * @return {boolean} true if current date is major, else false.
   */
  isMajor() {
    if (this.switchedYear == true) {
      switch (this.scale) {
        case "year":
        case "month":
        case "week":
        case "weekday":
        case "day":
        case "hour":
        case "minute":
        case "second":
        case "millisecond":
          return true;
        default:
          return false;
      }
    } else if (this.switchedMonth == true) {
      switch (this.scale) {
        case "week":
        case "weekday":
        case "day":
        case "hour":
        case "minute":
        case "second":
        case "millisecond":
          return true;
        default:
          return false;
      }
    } else if (this.switchedDay == true) {
      switch (this.scale) {
        case "millisecond":
        case "second":
        case "minute":
        case "hour":
          return true;
        default:
          return false;
      }
    }
    const date2 = this.moment(this.current);
    switch (this.scale) {
      case "millisecond":
        return date2.milliseconds() == 0;
      case "second":
        return date2.seconds() == 0;
      case "minute":
        return date2.hours() == 0 && date2.minutes() == 0;
      case "hour":
        return date2.hours() == 0;
      case "weekday":
      // intentional fall through
      case "day":
        return this.options.showWeekScale ? date2.isoWeekday() == 1 : date2.date() == 1;
      case "week":
        return date2.date() == 1;
      case "month":
        return date2.month() == 0;
      case "year":
        return false;
      default:
        return false;
    }
  }
  /**
   * Returns formatted text for the minor axislabel, depending on the current
   * date and the scale. For example when scale is MINUTE, the current time is
   * formatted as "hh:mm".
   * @param {Date} [date=this.current] custom date. if not provided, current date is taken
   * @returns {String}
   */
  getLabelMinor(date2) {
    if (date2 == void 0) {
      date2 = this.current;
    }
    if (date2 instanceof Date) {
      date2 = this.moment(date2);
    }
    if (typeof this.format.minorLabels === "function") {
      return this.format.minorLabels(date2, this.scale, this.step);
    }
    const format = this.format.minorLabels[this.scale];
    switch (this.scale) {
      case "week":
        if (date2.date() === 1 && date2.weekday() !== 0) {
          return "";
        }
      // eslint-disable-next-line no-fallthrough
      default:
        return format && format.length > 0 ? this.moment(date2).format(format) : "";
    }
  }
  /**
   * Returns formatted text for the major axis label, depending on the current
   * date and the scale. For example when scale is MINUTE, the major scale is
   * hours, and the hour will be formatted as "hh".
   * @param {Date} [date=this.current] custom date. if not provided, current date is taken
   * @returns {String}
   */
  getLabelMajor(date2) {
    if (date2 == void 0) {
      date2 = this.current;
    }
    if (date2 instanceof Date) {
      date2 = this.moment(date2);
    }
    if (typeof this.format.majorLabels === "function") {
      return this.format.majorLabels(date2, this.scale, this.step);
    }
    const format = this.format.majorLabels[this.scale];
    return format && format.length > 0 ? this.moment(date2).format(format) : "";
  }
  /**
   * get class name
   * @return {string} class name
   */
  getClassName() {
    var _context;
    const _moment = this.moment;
    const m = this.moment(this.current);
    const current = m.locale ? m.locale("en") : m.lang("en");
    const step = this.step;
    const classNames = [];
    function even(value) {
      return value / step % 2 == 0 ? " vis-even" : " vis-odd";
    }
    function today(date2) {
      if (date2.isSame(_Date$now(), "day")) {
        return " vis-today";
      }
      if (date2.isSame(_moment().add(1, "day"), "day")) {
        return " vis-tomorrow";
      }
      if (date2.isSame(_moment().add(-1, "day"), "day")) {
        return " vis-yesterday";
      }
      return "";
    }
    function currentWeek(date2) {
      return date2.isSame(_Date$now(), "week") ? " vis-current-week" : "";
    }
    function currentMonth(date2) {
      return date2.isSame(_Date$now(), "month") ? " vis-current-month" : "";
    }
    function currentYear(date2) {
      return date2.isSame(_Date$now(), "year") ? " vis-current-year" : "";
    }
    switch (this.scale) {
      case "millisecond":
        classNames.push(today(current));
        classNames.push(even(current.milliseconds()));
        break;
      case "second":
        classNames.push(today(current));
        classNames.push(even(current.seconds()));
        break;
      case "minute":
        classNames.push(today(current));
        classNames.push(even(current.minutes()));
        break;
      case "hour":
        classNames.push(_concatInstanceProperty(_context = "vis-h".concat(current.hours())).call(_context, this.step == 4 ? "-h" + (current.hours() + 4) : ""));
        classNames.push(today(current));
        classNames.push(even(current.hours()));
        break;
      case "weekday":
        classNames.push("vis-".concat(current.format("dddd").toLowerCase()));
        classNames.push(today(current));
        classNames.push(currentWeek(current));
        classNames.push(even(current.date()));
        break;
      case "day":
        classNames.push("vis-day".concat(current.date()));
        classNames.push("vis-".concat(current.format("MMMM").toLowerCase()));
        classNames.push(today(current));
        classNames.push(currentMonth(current));
        classNames.push(this.step <= 2 ? today(current) : "");
        classNames.push(this.step <= 2 ? "vis-".concat(current.format("dddd").toLowerCase()) : "");
        classNames.push(even(current.date() - 1));
        break;
      case "week":
        classNames.push("vis-week".concat(current.format("w")));
        classNames.push(currentWeek(current));
        classNames.push(even(current.week()));
        break;
      case "month":
        classNames.push("vis-".concat(current.format("MMMM").toLowerCase()));
        classNames.push(currentMonth(current));
        classNames.push(even(current.month()));
        break;
      case "year":
        classNames.push("vis-year".concat(current.year()));
        classNames.push(currentYear(current));
        classNames.push(even(current.year()));
        break;
    }
    return _filterInstanceProperty(classNames).call(classNames, String).join(" ");
  }
};
TimeStep.FORMAT = {
  minorLabels: {
    millisecond: "SSS",
    second: "s",
    minute: "HH:mm",
    hour: "HH:mm",
    weekday: "ddd D",
    day: "D",
    week: "w",
    month: "MMM",
    year: "YYYY"
  },
  majorLabels: {
    millisecond: "HH:mm:ss",
    second: "D MMMM HH:mm",
    minute: "ddd D MMMM",
    hour: "ddd D MMMM",
    weekday: "MMMM YYYY",
    day: "MMMM YYYY",
    week: "MMMM YYYY",
    month: "YYYY",
    year: ""
  }
};
var TimeAxis = class extends Component {
  /**
   * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} body
   * @param {Object} [options]        See TimeAxis.setOptions for the available
   *                                  options.
   * @constructor TimeAxis
   * @extends Component
   */
  constructor(body, options) {
    super();
    this.dom = {
      foreground: null,
      lines: [],
      majorTexts: [],
      minorTexts: [],
      redundant: {
        lines: [],
        majorTexts: [],
        minorTexts: []
      }
    };
    this.props = {
      range: {
        start: 0,
        end: 0,
        minimumStep: 0
      },
      lineTop: 0
    };
    this.defaultOptions = {
      orientation: {
        axis: "bottom"
      },
      // axis orientation: 'top' or 'bottom'
      showMinorLabels: true,
      showMajorLabels: true,
      showWeekScale: false,
      maxMinorChars: 7,
      format: availableUtils.extend({}, TimeStep.FORMAT),
      moment: moment$2,
      timeAxis: null
    };
    this.options = availableUtils.extend({}, this.defaultOptions);
    this.body = body;
    this._create();
    this.setOptions(options);
  }
  /**
   * Set options for the TimeAxis.
   * Parameters will be merged in current options.
   * @param {Object} options  Available options:
   *                          {string} [orientation.axis]
   *                          {boolean} [showMinorLabels]
   *                          {boolean} [showMajorLabels]
   *                          {boolean} [showWeekScale]
   */
  setOptions(options) {
    if (options) {
      availableUtils.selectiveExtend(["showMinorLabels", "showMajorLabels", "showWeekScale", "maxMinorChars", "hiddenDates", "timeAxis", "moment", "rtl"], this.options, options);
      availableUtils.selectiveDeepExtend(["format"], this.options, options);
      if ("orientation" in options) {
        if (typeof options.orientation === "string") {
          this.options.orientation.axis = options.orientation;
        } else if (typeof options.orientation === "object" && "axis" in options.orientation) {
          this.options.orientation.axis = options.orientation.axis;
        }
      }
      if ("locale" in options) {
        if (typeof moment$2.locale === "function") {
          moment$2.locale(options.locale);
        } else {
          moment$2.lang(options.locale);
        }
      }
    }
  }
  /**
   * Create the HTML DOM for the TimeAxis
   */
  _create() {
    this.dom.foreground = document.createElement("div");
    this.dom.background = document.createElement("div");
    this.dom.foreground.className = "vis-time-axis vis-foreground";
    this.dom.background.className = "vis-time-axis vis-background";
  }
  /**
   * Destroy the TimeAxis
   */
  destroy() {
    if (this.dom.foreground.parentNode) {
      this.dom.foreground.parentNode.removeChild(this.dom.foreground);
    }
    if (this.dom.background.parentNode) {
      this.dom.background.parentNode.removeChild(this.dom.background);
    }
    this.body = null;
  }
  /**
   * Repaint the component
   * @return {boolean} Returns true if the component is resized
   */
  redraw() {
    const props = this.props;
    const foreground = this.dom.foreground;
    const background = this.dom.background;
    const parent = this.options.orientation.axis == "top" ? this.body.dom.top : this.body.dom.bottom;
    const parentChanged = foreground.parentNode !== parent;
    this._calculateCharSize();
    const showMinorLabels = this.options.showMinorLabels && this.options.orientation.axis !== "none";
    const showMajorLabels = this.options.showMajorLabels && this.options.orientation.axis !== "none";
    props.minorLabelHeight = showMinorLabels ? props.minorCharHeight : 0;
    props.majorLabelHeight = showMajorLabels ? props.majorCharHeight : 0;
    props.height = props.minorLabelHeight + props.majorLabelHeight;
    props.width = foreground.offsetWidth;
    props.minorLineHeight = this.body.domProps.root.height - props.majorLabelHeight - (this.options.orientation.axis == "top" ? this.body.domProps.bottom.height : this.body.domProps.top.height);
    props.minorLineWidth = 1;
    props.majorLineHeight = props.minorLineHeight + props.majorLabelHeight;
    props.majorLineWidth = 1;
    const foregroundNextSibling = foreground.nextSibling;
    const backgroundNextSibling = background.nextSibling;
    foreground.parentNode && foreground.parentNode.removeChild(foreground);
    background.parentNode && background.parentNode.removeChild(background);
    foreground.style.height = "".concat(this.props.height, "px");
    this._repaintLabels();
    if (foregroundNextSibling) {
      parent.insertBefore(foreground, foregroundNextSibling);
    } else {
      parent.appendChild(foreground);
    }
    if (backgroundNextSibling) {
      this.body.dom.backgroundVertical.insertBefore(background, backgroundNextSibling);
    } else {
      this.body.dom.backgroundVertical.appendChild(background);
    }
    return this._isResized() || parentChanged;
  }
  /**
   * Repaint major and minor text labels and vertical grid lines
   * @private
   */
  _repaintLabels() {
    const orientation = this.options.orientation.axis;
    const start = availableUtils.convert(this.body.range.start, "Number");
    const end = availableUtils.convert(this.body.range.end, "Number");
    const timeLabelsize = this.body.util.toTime((this.props.minorCharWidth || 10) * this.options.maxMinorChars).valueOf();
    let minimumStep = timeLabelsize - getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this.body.range, timeLabelsize);
    minimumStep -= this.body.util.toTime(0).valueOf();
    const step = new TimeStep(new Date(start), new Date(end), minimumStep, this.body.hiddenDates, this.options);
    step.setMoment(this.options.moment);
    if (this.options.format) {
      step.setFormat(this.options.format);
    }
    if (this.options.timeAxis) {
      step.setScale(this.options.timeAxis);
    }
    this.step = step;
    const dom2 = this.dom;
    dom2.redundant.lines = dom2.lines;
    dom2.redundant.majorTexts = dom2.majorTexts;
    dom2.redundant.minorTexts = dom2.minorTexts;
    dom2.lines = [];
    dom2.majorTexts = [];
    dom2.minorTexts = [];
    let current;
    let next;
    let x;
    let xNext;
    let isMajor;
    let showMinorGrid;
    let width = 0;
    let prevWidth;
    let line;
    let xFirstMajorLabel = void 0;
    let count = 0;
    const MAX = 1e3;
    let className;
    step.start();
    next = step.getCurrent();
    xNext = this.body.util.toScreen(next);
    while (step.hasNext() && count < MAX) {
      count++;
      isMajor = step.isMajor();
      className = step.getClassName();
      current = next;
      x = xNext;
      step.next();
      next = step.getCurrent();
      xNext = this.body.util.toScreen(next);
      prevWidth = width;
      width = xNext - x;
      switch (step.scale) {
        case "week":
          showMinorGrid = true;
          break;
        default:
          showMinorGrid = width >= prevWidth * 0.4;
          break;
      }
      if (this.options.showMinorLabels && showMinorGrid) {
        var label = this._repaintMinorText(x, step.getLabelMinor(current), orientation, className);
        label.style.width = "".concat(width, "px");
      }
      if (isMajor && this.options.showMajorLabels) {
        if (x > 0) {
          if (xFirstMajorLabel == void 0) {
            xFirstMajorLabel = x;
          }
          label = this._repaintMajorText(x, step.getLabelMajor(current), orientation, className);
        }
        line = this._repaintMajorLine(x, width, orientation, className);
      } else {
        if (showMinorGrid) {
          line = this._repaintMinorLine(x, width, orientation, className);
        } else {
          if (line) {
            line.style.width = "".concat(_parseInt(line.style.width) + width, "px");
          }
        }
      }
    }
    if (count === MAX && !warnedForOverflow) {
      console.warn("Something is wrong with the Timeline scale. Limited drawing of grid lines to ".concat(MAX, " lines."));
      warnedForOverflow = true;
    }
    if (this.options.showMajorLabels) {
      const leftTime = this.body.util.toTime(0);
      const leftText = step.getLabelMajor(leftTime);
      const widthText = leftText.length * (this.props.majorCharWidth || 10) + 10;
      if (xFirstMajorLabel == void 0 || widthText < xFirstMajorLabel) {
        this._repaintMajorText(0, leftText, orientation, className);
      }
    }
    _forEachInstanceProperty(availableUtils).call(availableUtils, this.dom.redundant, (arr) => {
      while (arr.length) {
        const elem = arr.pop();
        if (elem && elem.parentNode) {
          elem.parentNode.removeChild(elem);
        }
      }
    });
  }
  /**
   * Create a minor label for the axis at position x
   * @param {number} x
   * @param {string} text
   * @param {string} orientation   "top" or "bottom" (default)
   * @param {string} className
   * @return {Element} Returns the HTML element of the created label
   * @private
   */
  _repaintMinorText(x, text, orientation, className) {
    let label = this.dom.redundant.minorTexts.shift();
    if (!label) {
      const content = document.createTextNode("");
      label = document.createElement("div");
      label.appendChild(content);
      this.dom.foreground.appendChild(label);
    }
    this.dom.minorTexts.push(label);
    label.innerHTML = availableUtils.xss(text);
    let y = orientation == "top" ? this.props.majorLabelHeight : 0;
    this._setXY(label, x, y);
    label.className = "vis-text vis-minor ".concat(className);
    return label;
  }
  /**
   * Create a Major label for the axis at position x
   * @param {number} x
   * @param {string} text
   * @param {string} orientation   "top" or "bottom" (default)
   * @param {string} className
   * @return {Element} Returns the HTML element of the created label
   * @private
   */
  _repaintMajorText(x, text, orientation, className) {
    let label = this.dom.redundant.majorTexts.shift();
    if (!label) {
      const content = document.createElement("div");
      label = document.createElement("div");
      label.appendChild(content);
      this.dom.foreground.appendChild(label);
    }
    label.childNodes[0].innerHTML = availableUtils.xss(text);
    label.className = "vis-text vis-major ".concat(className);
    let y = orientation == "top" ? 0 : this.props.minorLabelHeight;
    this._setXY(label, x, y);
    this.dom.majorTexts.push(label);
    return label;
  }
  /**
   * sets xy
   * @param {string} label
   * @param {number} x
   * @param {number} y
   * @private
   */
  _setXY(label, x, y) {
    var _context;
    const directionX = this.options.rtl ? x * -1 : x;
    label.style.transform = _concatInstanceProperty(_context = "translate(".concat(directionX, "px, ")).call(_context, y, "px)");
  }
  /**
   * Create a minor line for the axis at position x
   * @param {number} left
   * @param {number} width
   * @param {string} orientation   "top" or "bottom" (default)
   * @param {string} className
   * @return {Element} Returns the created line
   * @private
   */
  _repaintMinorLine(left, width, orientation, className) {
    var _context2;
    let line = this.dom.redundant.lines.shift();
    if (!line) {
      line = document.createElement("div");
      this.dom.background.appendChild(line);
    }
    this.dom.lines.push(line);
    const props = this.props;
    line.style.width = "".concat(width, "px");
    line.style.height = "".concat(props.minorLineHeight, "px");
    let y = orientation == "top" ? props.majorLabelHeight : this.body.domProps.top.height;
    let x = left - props.minorLineWidth / 2;
    this._setXY(line, x, y);
    line.className = _concatInstanceProperty(_context2 = "vis-grid ".concat(this.options.rtl ? "vis-vertical-rtl" : "vis-vertical", " vis-minor ")).call(_context2, className);
    return line;
  }
  /**
   * Create a Major line for the axis at position x
   * @param {number} left
   * @param {number} width
   * @param {string} orientation   "top" or "bottom" (default)
   * @param {string} className
   * @return {Element} Returns the created line
   * @private
   */
  _repaintMajorLine(left, width, orientation, className) {
    var _context3;
    let line = this.dom.redundant.lines.shift();
    if (!line) {
      line = document.createElement("div");
      this.dom.background.appendChild(line);
    }
    this.dom.lines.push(line);
    const props = this.props;
    line.style.width = "".concat(width, "px");
    line.style.height = "".concat(props.majorLineHeight, "px");
    let y = orientation == "top" ? 0 : this.body.domProps.top.height;
    let x = left - props.majorLineWidth / 2;
    this._setXY(line, x, y);
    line.className = _concatInstanceProperty(_context3 = "vis-grid ".concat(this.options.rtl ? "vis-vertical-rtl" : "vis-vertical", " vis-major ")).call(_context3, className);
    return line;
  }
  /**
   * Determine the size of text on the axis (both major and minor axis).
   * The size is calculated only once and then cached in this.props.
   * @private
   */
  _calculateCharSize() {
    if (!this.dom.measureCharMinor) {
      this.dom.measureCharMinor = document.createElement("DIV");
      this.dom.measureCharMinor.className = "vis-text vis-minor vis-measure";
      this.dom.measureCharMinor.style.position = "absolute";
      this.dom.measureCharMinor.appendChild(document.createTextNode("0"));
      this.dom.foreground.appendChild(this.dom.measureCharMinor);
    }
    this.props.minorCharHeight = this.dom.measureCharMinor.clientHeight;
    this.props.minorCharWidth = this.dom.measureCharMinor.clientWidth;
    if (!this.dom.measureCharMajor) {
      this.dom.measureCharMajor = document.createElement("DIV");
      this.dom.measureCharMajor.className = "vis-text vis-major vis-measure";
      this.dom.measureCharMajor.style.position = "absolute";
      this.dom.measureCharMajor.appendChild(document.createTextNode("0"));
      this.dom.foreground.appendChild(this.dom.measureCharMajor);
    }
    this.props.majorCharHeight = this.dom.measureCharMajor.clientHeight;
    this.props.majorCharWidth = this.dom.measureCharMajor.clientWidth;
  }
};
var warnedForOverflow = false;
function keycharm(options) {
  var preventDefault2 = options && options.preventDefault || false;
  var container = options && options.container || window;
  var _exportFunctions = {};
  var _bound = { keydown: {}, keyup: {} };
  var _keys = {};
  var i;
  for (i = 97; i <= 122; i++) {
    _keys[String.fromCharCode(i)] = { code: 65 + (i - 97), shift: false };
  }
  for (i = 65; i <= 90; i++) {
    _keys[String.fromCharCode(i)] = { code: i, shift: true };
  }
  for (i = 0; i <= 9; i++) {
    _keys["" + i] = { code: 48 + i, shift: false };
  }
  for (i = 1; i <= 12; i++) {
    _keys["F" + i] = { code: 111 + i, shift: false };
  }
  for (i = 0; i <= 9; i++) {
    _keys["num" + i] = { code: 96 + i, shift: false };
  }
  _keys["num*"] = { code: 106, shift: false };
  _keys["num+"] = { code: 107, shift: false };
  _keys["num-"] = { code: 109, shift: false };
  _keys["num/"] = { code: 111, shift: false };
  _keys["num."] = { code: 110, shift: false };
  _keys["left"] = { code: 37, shift: false };
  _keys["up"] = { code: 38, shift: false };
  _keys["right"] = { code: 39, shift: false };
  _keys["down"] = { code: 40, shift: false };
  _keys["space"] = { code: 32, shift: false };
  _keys["enter"] = { code: 13, shift: false };
  _keys["shift"] = { code: 16, shift: void 0 };
  _keys["esc"] = { code: 27, shift: false };
  _keys["backspace"] = { code: 8, shift: false };
  _keys["tab"] = { code: 9, shift: false };
  _keys["ctrl"] = { code: 17, shift: false };
  _keys["alt"] = { code: 18, shift: false };
  _keys["delete"] = { code: 46, shift: false };
  _keys["pageup"] = { code: 33, shift: false };
  _keys["pagedown"] = { code: 34, shift: false };
  _keys["="] = { code: 187, shift: false };
  _keys["-"] = { code: 189, shift: false };
  _keys["]"] = { code: 221, shift: false };
  _keys["["] = { code: 219, shift: false };
  var down = function(event2) {
    handleEvent(event2, "keydown");
  };
  var up = function(event2) {
    handleEvent(event2, "keyup");
  };
  var handleEvent = function(event2, type) {
    if (_bound[type][event2.keyCode] !== void 0) {
      var bound = _bound[type][event2.keyCode];
      for (var i2 = 0; i2 < bound.length; i2++) {
        if (bound[i2].shift === void 0) {
          bound[i2].fn(event2);
        } else if (bound[i2].shift == true && event2.shiftKey == true) {
          bound[i2].fn(event2);
        } else if (bound[i2].shift == false && event2.shiftKey == false) {
          bound[i2].fn(event2);
        }
      }
      if (preventDefault2 == true) {
        event2.preventDefault();
      }
    }
  };
  _exportFunctions.bind = function(key, callback, type) {
    if (type === void 0) {
      type = "keydown";
    }
    if (_keys[key] === void 0) {
      throw new Error("unsupported key: " + key);
    }
    if (_bound[type][_keys[key].code] === void 0) {
      _bound[type][_keys[key].code] = [];
    }
    _bound[type][_keys[key].code].push({ fn: callback, shift: _keys[key].shift });
  };
  _exportFunctions.bindAll = function(callback, type) {
    if (type === void 0) {
      type = "keydown";
    }
    for (var key in _keys) {
      if (_keys.hasOwnProperty(key)) {
        _exportFunctions.bind(key, callback, type);
      }
    }
  };
  _exportFunctions.getKey = function(event2) {
    for (var key in _keys) {
      if (_keys.hasOwnProperty(key)) {
        if (event2.shiftKey == true && _keys[key].shift == true && event2.keyCode == _keys[key].code) {
          return key;
        } else if (event2.shiftKey == false && _keys[key].shift == false && event2.keyCode == _keys[key].code) {
          return key;
        } else if (event2.keyCode == _keys[key].code && key == "shift") {
          return key;
        }
      }
    }
    return "unknown key, currently not supported";
  };
  _exportFunctions.unbind = function(key, callback, type) {
    if (type === void 0) {
      type = "keydown";
    }
    if (_keys[key] === void 0) {
      throw new Error("unsupported key: " + key);
    }
    if (callback !== void 0) {
      var newBindings = [];
      var bound = _bound[type][_keys[key].code];
      if (bound !== void 0) {
        for (var i2 = 0; i2 < bound.length; i2++) {
          if (!(bound[i2].fn == callback && bound[i2].shift == _keys[key].shift)) {
            newBindings.push(_bound[type][_keys[key].code][i2]);
          }
        }
      }
      _bound[type][_keys[key].code] = newBindings;
    } else {
      _bound[type][_keys[key].code] = [];
    }
  };
  _exportFunctions.reset = function() {
    _bound = { keydown: {}, keyup: {} };
  };
  _exportFunctions.destroy = function() {
    _bound = { keydown: {}, keyup: {} };
    container.removeEventListener("keydown", down, true);
    container.removeEventListener("keyup", up, true);
  };
  container.addEventListener("keydown", down, true);
  container.addEventListener("keyup", up, true);
  return _exportFunctions;
}
function Activator(container) {
  var _context, _context2;
  this.active = false;
  this.dom = {
    container
  };
  this.dom.overlay = document.createElement("div");
  this.dom.overlay.className = "vis-overlay";
  this.dom.container.appendChild(this.dom.overlay);
  this.hammer = Hammer(this.dom.overlay);
  this.hammer.on("tap", _bindInstanceProperty(_context = this._onTapOverlay).call(_context, this));
  var me = this;
  var events = ["tap", "doubletap", "press", "pinch", "pan", "panstart", "panmove", "panend"];
  _forEachInstanceProperty(events).call(events, function(event2) {
    me.hammer.on(event2, function(event3) {
      event3.stopPropagation();
    });
  });
  if (document && document.body) {
    this.onClick = function(event2) {
      if (!_hasParent(event2.target, container)) {
        me.deactivate();
      }
    };
    document.body.addEventListener("click", this.onClick);
  }
  if (this.keycharm !== void 0) {
    this.keycharm.destroy();
  }
  this.keycharm = keycharm();
  this.escListener = _bindInstanceProperty(_context2 = this.deactivate).call(_context2, this);
}
Emitter(Activator.prototype);
Activator.current = null;
Activator.prototype.destroy = function() {
  this.deactivate();
  this.dom.overlay.parentNode.removeChild(this.dom.overlay);
  if (this.onClick) {
    document.body.removeEventListener("click", this.onClick);
  }
  if (this.keycharm !== void 0) {
    this.keycharm.destroy();
  }
  this.keycharm = null;
  this.hammer.destroy();
  this.hammer = null;
};
Activator.prototype.activate = function() {
  var _context3;
  if (Activator.current) {
    Activator.current.deactivate();
  }
  Activator.current = this;
  this.active = true;
  this.dom.overlay.style.display = "none";
  availableUtils.addClassName(this.dom.container, "vis-active");
  this.emit("change");
  this.emit("activate");
  _bindInstanceProperty(_context3 = this.keycharm).call(_context3, "esc", this.escListener);
};
Activator.prototype.deactivate = function() {
  if (Activator.current === this) {
    Activator.current = null;
  }
  this.active = false;
  this.dom.overlay.style.display = "";
  availableUtils.removeClassName(this.dom.container, "vis-active");
  this.keycharm.unbind("esc", this.escListener);
  this.emit("change");
  this.emit("deactivate");
};
Activator.prototype._onTapOverlay = function(event2) {
  this.activate();
  event2.stopPropagation();
};
function _hasParent(element, parent) {
  while (element) {
    if (element === parent) {
      return true;
    }
    element = element.parentNode;
  }
  return false;
}
var en = {
  current: "current",
  time: "time",
  deleteSelected: "Delete selected"
};
var en_EN = en;
var en_US = en;
var it = {
  current: "attuale",
  time: "tempo",
  deleteSelected: "Cancella la selezione"
};
var it_IT = it;
var it_CH = it;
var nl = {
  current: "huidige",
  time: "tijd",
  deleteSelected: "Selectie verwijderen"
};
var nl_NL = nl;
var nl_BE = nl;
var de = {
  current: "Aktuelle",
  time: "Zeit",
  deleteSelected: "Lsche Auswahl"
};
var de_DE = de;
var de_CH = de;
var fr = {
  current: "actuel",
  time: "heure",
  deleteSelected: "Effacer la selection"
};
var fr_FR = fr;
var fr_CA = fr;
var fr_BE = fr;
var fr_CH = fr;
var es = {
  current: "actual",
  time: "hora",
  deleteSelected: "Eliminar seleccin"
};
var es_ES = es;
var uk = {
  current: "",
  time: "",
  deleteSelected: " "
};
var uk_UA = uk;
var ru = {
  current: "",
  time: "",
  deleteSelected: " "
};
var ru_RU = ru;
var pl = {
  current: "aktualny",
  time: "czas",
  deleteSelected: "Usu wybrane"
};
var pl_PL = pl;
var pt = {
  current: "atual",
  time: "data",
  deleteSelected: "Apagar selecionado"
};
var pt_BR = pt;
var pt_PT = pt;
var tr = {
  current: "gncel",
  time: "zaman",
  deleteSelected: "Seileni sil"
};
var tr_TR = tr;
var ja = {
  current: "",
  time: "",
  deleteSelected: ""
};
var ja_JP = ja;
var sv = {
  current: "nuvarande",
  time: "tid",
  deleteSelected: "Radera valda"
};
var sv_SE = sv;
var nb = {
  current: "nvrende",
  time: "tid",
  deleteSelected: "Slett valgte"
};
var nb_NO = nb;
var nn = nb;
var nn_NO = nb;
var lt = {
  current: "einamas",
  time: "laikas",
  deleteSelected: "Paalinti pasirinkt"
};
var lt_LT = lt;
var locales = {
  en,
  en_EN,
  en_US,
  it,
  it_IT,
  it_CH,
  nl,
  nl_NL,
  nl_BE,
  de,
  de_DE,
  de_CH,
  fr,
  fr_FR,
  fr_CA,
  fr_BE,
  fr_CH,
  es,
  es_ES,
  uk,
  uk_UA,
  ru,
  ru_RU,
  pl,
  pl_PL,
  pt,
  pt_BR,
  pt_PT,
  tr,
  tr_TR,
  ja,
  ja_JP,
  lt,
  lt_LT,
  sv,
  sv_SE,
  nb,
  nn,
  nb_NO,
  nn_NO
};
var CustomTime = class extends Component {
  /**
   * @param {{range: Range, dom: Object}} body
   * @param {Object} [options]        Available parameters:
   *                                  {number | string} id
   *                                  {string} locales
   *                                  {string} locale
   * @constructor CustomTime
   * @extends Component
   */
  constructor(body, options) {
    var _context;
    super();
    this.body = body;
    this.defaultOptions = {
      moment: moment$2,
      locales,
      locale: "en",
      id: void 0,
      title: void 0
    };
    this.options = availableUtils.extend({}, this.defaultOptions);
    this.setOptions(options);
    this.options.locales = availableUtils.extend({}, locales, this.options.locales);
    const defaultLocales = this.defaultOptions.locales[this.defaultOptions.locale];
    _forEachInstanceProperty(_context = _Object$keys(this.options.locales)).call(_context, (locale) => {
      this.options.locales[locale] = availableUtils.extend({}, defaultLocales, this.options.locales[locale]);
    });
    if (options && options.time != null) {
      this.customTime = options.time;
    } else {
      this.customTime = /* @__PURE__ */ new Date();
    }
    this.eventParams = {};
    this._create();
  }
  /**
   * Set options for the component. Options will be merged in current options.
   * @param {Object} options  Available parameters:
   *                                  {number | string} id
   *                                  {string} locales
   *                                  {string} locale
   */
  setOptions(options) {
    if (options) {
      availableUtils.selectiveExtend(["moment", "locale", "locales", "id", "title", "rtl", "snap"], this.options, options);
    }
  }
  /**
   * Create the DOM for the custom time
   * @private
   */
  _create() {
    var _context2, _context3, _context4;
    const bar = document.createElement("div");
    bar["custom-time"] = this;
    bar.className = "vis-custom-time ".concat(this.options.id || "");
    bar.style.position = "absolute";
    bar.style.top = "0px";
    bar.style.height = "100%";
    this.bar = bar;
    const drag = document.createElement("div");
    drag.style.position = "relative";
    drag.style.top = "0px";
    if (this.options.rtl) {
      drag.style.right = "-10px";
    } else {
      drag.style.left = "-10px";
    }
    drag.style.height = "100%";
    drag.style.width = "20px";
    function onMouseWheel(e) {
      this.body.range._onMouseWheel(e);
    }
    if (drag.addEventListener) {
      drag.addEventListener("mousewheel", _bindInstanceProperty(onMouseWheel).call(onMouseWheel, this), false);
      drag.addEventListener("DOMMouseScroll", _bindInstanceProperty(onMouseWheel).call(onMouseWheel, this), false);
    } else {
      drag.attachEvent("onmousewheel", _bindInstanceProperty(onMouseWheel).call(onMouseWheel, this));
    }
    bar.appendChild(drag);
    this.hammer = new Hammer(drag);
    this.hammer.on("panstart", _bindInstanceProperty(_context2 = this._onDragStart).call(_context2, this));
    this.hammer.on("panmove", _bindInstanceProperty(_context3 = this._onDrag).call(_context3, this));
    this.hammer.on("panend", _bindInstanceProperty(_context4 = this._onDragEnd).call(_context4, this));
    this.hammer.get("pan").set({
      threshold: 5,
      direction: Hammer.DIRECTION_ALL
    });
    this.hammer.get("press").set({
      time: 1e4
    });
  }
  /**
   * Destroy the CustomTime bar
   */
  destroy() {
    this.hide();
    this.hammer.destroy();
    this.hammer = null;
    this.body = null;
  }
  /**
   * Repaint the component
   * @return {boolean} Returns true if the component is resized
   */
  redraw() {
    const parent = this.body.dom.backgroundVertical;
    if (this.bar.parentNode != parent) {
      if (this.bar.parentNode) {
        this.bar.parentNode.removeChild(this.bar);
      }
      parent.appendChild(this.bar);
    }
    const x = this.body.util.toScreen(this.customTime);
    let locale = this.options.locales[this.options.locale];
    if (!locale) {
      if (!this.warned) {
        console.warn("WARNING: options.locales['".concat(this.options.locale, "'] not found. See https://visjs.github.io/vis-timeline/docs/timeline/#Localization"));
        this.warned = true;
      }
      locale = this.options.locales["en"];
    }
    let title = this.options.title;
    if (title === void 0) {
      var _context5;
      title = _concatInstanceProperty(_context5 = "".concat(locale.time, ": ")).call(_context5, this.options.moment(this.customTime).format("dddd, MMMM Do YYYY, H:mm:ss"));
      title = title.charAt(0).toUpperCase() + title.substring(1);
    } else if (typeof title === "function") {
      title = title.call(this, this.customTime);
    }
    this.options.rtl ? this.bar.style.right = "".concat(x, "px") : this.bar.style.left = "".concat(x, "px");
    this.bar.title = title;
    return false;
  }
  /**
   * Remove the CustomTime from the DOM
   */
  hide() {
    if (this.bar.parentNode) {
      this.bar.parentNode.removeChild(this.bar);
    }
  }
  /**
   * Set custom time.
   * @param {Date | number | string} time
   */
  setCustomTime(time) {
    this.customTime = availableUtils.convert(time, "Date");
    this.redraw();
  }
  /**
   * Retrieve the current custom time.
   * @return {Date} customTime
   */
  getCustomTime() {
    return new Date(this.customTime.valueOf());
  }
  /**
   * Set custom marker.
   * @param {string} [title] Title of the custom marker
   * @param {boolean} [editable] Make the custom marker editable.
   */
  setCustomMarker(title, editable) {
    if (this.marker) {
      this.bar.removeChild(this.marker);
    }
    this.marker = document.createElement("div");
    this.marker.className = "vis-custom-time-marker";
    this.marker.innerHTML = availableUtils.xss(title);
    this.marker.style.position = "absolute";
    if (editable) {
      var _context6;
      this.marker.setAttribute("contenteditable", "true");
      this.marker.addEventListener("pointerdown", () => {
        this.marker.focus();
      });
      this.marker.addEventListener("input", _bindInstanceProperty(_context6 = this._onMarkerChange).call(_context6, this));
      this.marker.title = title;
      this.marker.addEventListener("blur", (event2) => {
        if (this.title != event2.target.innerHTML) {
          this._onMarkerChanged(event2);
          this.title = event2.target.innerHTML;
        }
      });
    }
    this.bar.appendChild(this.marker);
  }
  /**
   * Set custom title.
   * @param {Date | number | string} title
   */
  setCustomTitle(title) {
    this.options.title = title;
  }
  /**
   * Start moving horizontally
   * @param {Event} event
   * @private
   */
  _onDragStart(event2) {
    this.eventParams.dragging = true;
    this.eventParams.customTime = this.customTime;
    event2.stopPropagation();
  }
  /**
   * Perform moving operating.
   * @param {Event} event
   * @private
   */
  _onDrag(event2) {
    if (!this.eventParams.dragging) return;
    let deltaX = this.options.rtl ? -1 * event2.deltaX : event2.deltaX;
    const x = this.body.util.toScreen(this.eventParams.customTime) + deltaX;
    const time = this.body.util.toTime(x);
    const scale = this.body.util.getScale();
    const step = this.body.util.getStep();
    const snap = this.options.snap;
    const snappedTime = snap ? snap(time, scale, step) : time;
    this.setCustomTime(snappedTime);
    this.body.emitter.emit("timechange", {
      id: this.options.id,
      time: new Date(this.customTime.valueOf()),
      event: event2
    });
    event2.stopPropagation();
  }
  /**
   * Stop moving operating.
   * @param {Event} event
   * @private
   */
  _onDragEnd(event2) {
    if (!this.eventParams.dragging) return;
    this.body.emitter.emit("timechanged", {
      id: this.options.id,
      time: new Date(this.customTime.valueOf()),
      event: event2
    });
    event2.stopPropagation();
  }
  /**
   * Perform input operating.
   * @param {Event} event
   * @private
   */
  _onMarkerChange(event2) {
    this.body.emitter.emit("markerchange", {
      id: this.options.id,
      title: event2.target.innerHTML,
      event: event2
    });
    event2.stopPropagation();
  }
  /**
   * Perform change operating.
   * @param {Event} event
   * @private
   */
  _onMarkerChanged(event2) {
    this.body.emitter.emit("markerchanged", {
      id: this.options.id,
      title: event2.target.innerHTML,
      event: event2
    });
    event2.stopPropagation();
  }
  /**
   * Find a custom time from an event target:
   * searches for the attribute 'custom-time' in the event target's element tree
   * @param {Event} event
   * @return {CustomTime | null} customTime
   */
  static customTimeFromTarget(event2) {
    let target = event2.target;
    while (target) {
      if (Object.prototype.hasOwnProperty.call(target, "custom-time")) {
        return target["custom-time"];
      }
      target = target.parentNode;
    }
    return null;
  }
};
var Core = class {
  /**
   * Create the main DOM for the Core: a root panel containing left, right,
   * top, bottom, content, and background panel.
   * @param {Element} container  The container element where the Core will
   *                             be attached.
   * @protected
   */
  _create(container) {
    var _context, _context2, _context3;
    this.dom = {};
    this.dom.container = container;
    this.dom.container.style.position = "relative";
    this.dom.root = document.createElement("div");
    this.dom.background = document.createElement("div");
    this.dom.backgroundVertical = document.createElement("div");
    this.dom.backgroundHorizontal = document.createElement("div");
    this.dom.centerContainer = document.createElement("div");
    this.dom.leftContainer = document.createElement("div");
    this.dom.rightContainer = document.createElement("div");
    this.dom.center = document.createElement("div");
    this.dom.left = document.createElement("div");
    this.dom.right = document.createElement("div");
    this.dom.top = document.createElement("div");
    this.dom.bottom = document.createElement("div");
    this.dom.shadowTop = document.createElement("div");
    this.dom.shadowBottom = document.createElement("div");
    this.dom.shadowTopLeft = document.createElement("div");
    this.dom.shadowBottomLeft = document.createElement("div");
    this.dom.shadowTopRight = document.createElement("div");
    this.dom.shadowBottomRight = document.createElement("div");
    this.dom.rollingModeBtn = document.createElement("div");
    this.dom.loadingScreen = document.createElement("div");
    this.dom.root.className = "vis-timeline";
    this.dom.background.className = "vis-panel vis-background";
    this.dom.backgroundVertical.className = "vis-panel vis-background vis-vertical";
    this.dom.backgroundHorizontal.className = "vis-panel vis-background vis-horizontal";
    this.dom.centerContainer.className = "vis-panel vis-center";
    this.dom.leftContainer.className = "vis-panel vis-left";
    this.dom.rightContainer.className = "vis-panel vis-right";
    this.dom.top.className = "vis-panel vis-top";
    this.dom.bottom.className = "vis-panel vis-bottom";
    this.dom.left.className = "vis-content";
    this.dom.center.className = "vis-content";
    this.dom.right.className = "vis-content";
    this.dom.shadowTop.className = "vis-shadow vis-top";
    this.dom.shadowBottom.className = "vis-shadow vis-bottom";
    this.dom.shadowTopLeft.className = "vis-shadow vis-top";
    this.dom.shadowBottomLeft.className = "vis-shadow vis-bottom";
    this.dom.shadowTopRight.className = "vis-shadow vis-top";
    this.dom.shadowBottomRight.className = "vis-shadow vis-bottom";
    this.dom.rollingModeBtn.className = "vis-rolling-mode-btn";
    this.dom.loadingScreen.className = "vis-loading-screen";
    this.dom.root.appendChild(this.dom.background);
    this.dom.root.appendChild(this.dom.backgroundVertical);
    this.dom.root.appendChild(this.dom.backgroundHorizontal);
    this.dom.root.appendChild(this.dom.centerContainer);
    this.dom.root.appendChild(this.dom.leftContainer);
    this.dom.root.appendChild(this.dom.rightContainer);
    this.dom.root.appendChild(this.dom.top);
    this.dom.root.appendChild(this.dom.bottom);
    this.dom.root.appendChild(this.dom.rollingModeBtn);
    this.dom.centerContainer.appendChild(this.dom.center);
    this.dom.leftContainer.appendChild(this.dom.left);
    this.dom.rightContainer.appendChild(this.dom.right);
    this.dom.centerContainer.appendChild(this.dom.shadowTop);
    this.dom.centerContainer.appendChild(this.dom.shadowBottom);
    this.dom.leftContainer.appendChild(this.dom.shadowTopLeft);
    this.dom.leftContainer.appendChild(this.dom.shadowBottomLeft);
    this.dom.rightContainer.appendChild(this.dom.shadowTopRight);
    this.dom.rightContainer.appendChild(this.dom.shadowBottomRight);
    this.props = {
      root: {},
      background: {},
      centerContainer: {},
      leftContainer: {},
      rightContainer: {},
      center: {},
      left: {},
      right: {},
      top: {},
      bottom: {},
      border: {},
      scrollTop: 0,
      scrollTopMin: 0
    };
    this.on("rangechange", () => {
      if (this.initialDrawDone === true) {
        this._redraw();
      }
    });
    this.on("rangechanged", () => {
      if (!this.initialRangeChangeDone) {
        this.initialRangeChangeDone = true;
      }
    });
    this.on("touch", _bindInstanceProperty(_context = this._onTouch).call(_context, this));
    this.on("panmove", _bindInstanceProperty(_context2 = this._onDrag).call(_context2, this));
    const me = this;
    this._origRedraw = _bindInstanceProperty(_context3 = this._redraw).call(_context3, this);
    this._redraw = availableUtils.throttle(this._origRedraw);
    this.on("_change", (properties) => {
      if (me.itemSet && me.itemSet.initialItemSetDrawn && properties && properties.queue == true) {
        me._redraw();
      } else {
        me._origRedraw();
      }
    });
    this.hammer = new Hammer(this.dom.root);
    const pinchRecognizer = this.hammer.get("pinch").set({
      enable: true
    });
    pinchRecognizer && disablePreventDefaultVertically(pinchRecognizer);
    this.hammer.get("pan").set({
      threshold: 5,
      direction: Hammer.DIRECTION_ALL
    });
    this.timelineListeners = {};
    const events = [
      "tap",
      "doubletap",
      "press",
      "pinch",
      "pan",
      "panstart",
      "panmove",
      "panend"
      // TODO: cleanup
      //'touch', 'pinch',
      //'tap', 'doubletap', 'hold',
      //'dragstart', 'drag', 'dragend',
      //'mousewheel', 'DOMMouseScroll' // DOMMouseScroll is needed for Firefox
    ];
    _forEachInstanceProperty(events).call(events, (type) => {
      const listener = (event2) => {
        if (me.isActive()) {
          me.emit(type, event2);
        }
      };
      me.hammer.on(type, listener);
      me.timelineListeners[type] = listener;
    });
    onTouch(this.hammer, (event2) => {
      me.emit("touch", event2);
    });
    onRelease(this.hammer, (event2) => {
      me.emit("release", event2);
    });
    function onMouseWheel(event2) {
      if (!this.isActive()) return;
      this.emit("mousewheel", event2);
      if (this.options.preferZoom) {
        if (!this.options.zoomKey || event2[this.options.zoomKey]) return;
      } else {
        if (this.options.zoomKey && event2[this.options.zoomKey]) return;
      }
      if (!this.options.verticalScroll && !this.options.horizontalScroll) return;
      let deltaX = 0;
      let deltaY = 0;
      if ("detail" in event2) deltaY = event2.detail * -1;
      if ("wheelDelta" in event2) deltaY = event2.wheelDelta;
      if ("wheelDeltaY" in event2) deltaY = event2.wheelDeltaY;
      if ("wheelDeltaX" in event2) deltaX = event2.wheelDeltaX * -1;
      if ("axis" in event2 && event2.axis === event2.HORIZONTAL_AXIS) {
        deltaX = deltaY * -1;
        deltaY = 0;
      }
      if ("deltaY" in event2) {
        deltaY = event2.deltaY * -1;
      }
      if ("deltaX" in event2) {
        deltaX = event2.deltaX;
      }
      var LINE_HEIGHT = 40;
      var PAGE_HEIGHT = 800;
      if (event2.deltaMode) {
        if (event2.deltaMode === 1) {
          deltaX *= LINE_HEIGHT;
          deltaY *= LINE_HEIGHT;
        } else {
          deltaX *= LINE_HEIGHT;
          deltaY *= PAGE_HEIGHT;
        }
      }
      const isVerticalScrollingPreferred = this.options.verticalScroll;
      const isCurrentlyScrollingWithVerticalScrollWheel = Math.abs(deltaY) >= Math.abs(deltaX);
      const isHorizontalScrollKeyConfiguredAndPressed = this.options.horizontalScroll && this.options.horizontalScrollKey && event2[this.options.horizontalScrollKey];
      if (isVerticalScrollingPreferred && isCurrentlyScrollingWithVerticalScrollWheel && !isHorizontalScrollKeyConfiguredAndPressed) {
        const current = this.props.scrollTop;
        const adjusted = current + deltaY;
        const newScrollTop = this._setScrollTop(adjusted);
        if (newScrollTop !== current) {
          this._redraw();
          this.emit("scroll", event2);
          event2.preventDefault();
        }
        return;
      }
      if (this.options.horizontalScroll) {
        this.range.stopRolling();
        const delta = isCurrentlyScrollingWithVerticalScrollWheel ? deltaY : deltaX;
        let diff = delta / 120 * (this.range.end - this.range.start) / 20;
        if (this.options.horizontalScrollInvert && isCurrentlyScrollingWithVerticalScrollWheel) diff = -diff;
        const newStart = this.range.start + diff;
        const newEnd = this.range.end + diff;
        const options = {
          animation: false,
          byUser: true,
          event: event2
        };
        this.range.setRange(newStart, newEnd, options);
        event2.preventDefault();
        return;
      }
    }
    const wheelType = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : (
      // DOMMouseScroll - Older Firefox versions use "DOMMouseScroll"
      // onmousewheel - All the use "onmousewheel"
      this.dom.centerContainer.addEventListener ? "DOMMouseScroll" : "onmousewheel"
    );
    this.dom.top.addEventListener ? "DOMMouseScroll" : "onmousewheel";
    this.dom.bottom.addEventListener ? "DOMMouseScroll" : "onmousewheel";
    this.dom.centerContainer.addEventListener(wheelType, _bindInstanceProperty(onMouseWheel).call(onMouseWheel, this), false);
    this.dom.top.addEventListener(wheelType, _bindInstanceProperty(onMouseWheel).call(onMouseWheel, this), false);
    this.dom.bottom.addEventListener(wheelType, _bindInstanceProperty(onMouseWheel).call(onMouseWheel, this), false);
    function onMouseScrollSide(event2) {
      if (!me.options.verticalScroll) return;
      event2.preventDefault();
      if (me.isActive()) {
        const adjusted = -event2.target.scrollTop;
        me._setScrollTop(adjusted);
        me._redraw();
        me.emit("scrollSide", event2);
      }
    }
    this.dom.left.parentNode.addEventListener("scroll", _bindInstanceProperty(onMouseScrollSide).call(onMouseScrollSide, this));
    this.dom.right.parentNode.addEventListener("scroll", _bindInstanceProperty(onMouseScrollSide).call(onMouseScrollSide, this));
    let itemAddedToTimeline = false;
    function handleDragOver(event2) {
      var _context4;
      if (event2.preventDefault) {
        me.emit("dragover", me.getEventProperties(event2));
        event2.preventDefault();
      }
      if (!(_indexOfInstanceProperty(_context4 = event2.target.className).call(_context4, "timeline") > -1)) return;
      if (itemAddedToTimeline) return;
      event2.dataTransfer.dropEffect = "move";
      itemAddedToTimeline = true;
      return false;
    }
    function handleDrop(event2) {
      if (event2.preventDefault) {
        event2.preventDefault();
      }
      if (event2.stopPropagation) {
        event2.stopPropagation();
      }
      try {
        var itemData = JSON.parse(event2.dataTransfer.getData("text"));
        if (!itemData || !itemData.content) return;
      } catch (err) {
        return false;
      }
      itemAddedToTimeline = false;
      event2.center = {
        x: event2.clientX,
        y: event2.clientY
      };
      if (itemData.target !== "item") {
        me.itemSet._onAddItem(event2);
      } else {
        me.itemSet._onDropObjectOnItem(event2);
      }
      me.emit("drop", me.getEventProperties(event2));
      return false;
    }
    this.dom.center.addEventListener("dragover", _bindInstanceProperty(handleDragOver).call(handleDragOver, this), false);
    this.dom.center.addEventListener("drop", _bindInstanceProperty(handleDrop).call(handleDrop, this), false);
    this.customTimes = [];
    this.touch = {};
    this.redrawCount = 0;
    this.initialDrawDone = false;
    this.initialRangeChangeDone = false;
    if (!container) throw new Error("No container provided");
    container.appendChild(this.dom.root);
    container.appendChild(this.dom.loadingScreen);
  }
  /**
   * Set options. Options will be passed to all components loaded in the Timeline.
   * @param {Object} [options]
   *                           {String} orientation
   *                              Vertical orientation for the Timeline,
   *                              can be 'bottom' (default) or 'top'.
   *                           {string | number} width
   *                              Width for the timeline, a number in pixels or
   *                              a css string like '1000px' or '75%'. '100%' by default.
   *                           {string | number} height
   *                              Fixed height for the Timeline, a number in pixels or
   *                              a css string like '400px' or '75%'. If undefined,
   *                              The Timeline will automatically size such that
   *                              its contents fit.
   *                           {string | number} minHeight
   *                              Minimum height for the Timeline, a number in pixels or
   *                              a css string like '400px' or '75%'.
   *                           {string | number} maxHeight
   *                              Maximum height for the Timeline, a number in pixels or
   *                              a css string like '400px' or '75%'.
   *                           {number | Date | string} start
   *                              Start date for the visible window
   *                           {number | Date | string} end
   *                              End date for the visible window
   */
  setOptions(options) {
    var _context7;
    if (options) {
      const fields = ["width", "height", "minHeight", "maxHeight", "autoResize", "start", "end", "clickToUse", "dataAttributes", "hiddenDates", "locale", "locales", "moment", "preferZoom", "rtl", "zoomKey", "horizontalScroll", "horizontalScrollKey", "horizontalScrollInvert", "verticalScroll", "longSelectPressTime", "snap"];
      availableUtils.selectiveExtend(fields, this.options, options);
      this.dom.rollingModeBtn.style.visibility = "hidden";
      if (this.options.rtl) {
        this.dom.container.style.direction = "rtl";
        this.dom.backgroundVertical.className = "vis-panel vis-background vis-vertical-rtl";
      }
      if (this.options.verticalScroll) {
        if (this.options.rtl) {
          this.dom.rightContainer.className = "vis-panel vis-right vis-vertical-scroll";
        } else {
          this.dom.leftContainer.className = "vis-panel vis-left vis-vertical-scroll";
        }
      }
      if (typeof this.options.orientation !== "object") {
        this.options.orientation = {
          item: void 0,
          axis: void 0
        };
      }
      if ("orientation" in options) {
        if (typeof options.orientation === "string") {
          this.options.orientation = {
            item: options.orientation,
            axis: options.orientation
          };
        } else if (typeof options.orientation === "object") {
          if ("item" in options.orientation) {
            this.options.orientation.item = options.orientation.item;
          }
          if ("axis" in options.orientation) {
            this.options.orientation.axis = options.orientation.axis;
          }
        }
      }
      if (this.options.orientation.axis === "both") {
        if (!this.timeAxis2) {
          const timeAxis2 = this.timeAxis2 = new TimeAxis(this.body, this.options);
          timeAxis2.setOptions = (options2) => {
            const _options = options2 ? availableUtils.extend({}, options2) : {};
            _options.orientation = "top";
            TimeAxis.prototype.setOptions.call(timeAxis2, _options);
          };
          this.components.push(timeAxis2);
        }
      } else {
        if (this.timeAxis2) {
          var _context5;
          const index = _indexOfInstanceProperty(_context5 = this.components).call(_context5, this.timeAxis2);
          if (index !== -1) {
            var _context6;
            _spliceInstanceProperty(_context6 = this.components).call(_context6, index, 1);
          }
          this.timeAxis2.destroy();
          this.timeAxis2 = null;
        }
      }
      if (typeof options.drawPoints == "function") {
        options.drawPoints = {
          onRender: options.drawPoints
        };
      }
      if ("hiddenDates" in this.options) {
        convertHiddenOptions(this.options.moment, this.body, this.options.hiddenDates);
      }
      if ("clickToUse" in options) {
        if (options.clickToUse) {
          if (!this.activator) {
            this.activator = new Activator(this.dom.root);
          }
        } else {
          if (this.activator) {
            this.activator.destroy();
            delete this.activator;
          }
        }
      }
      this._initAutoResize();
    }
    _forEachInstanceProperty(_context7 = this.components).call(_context7, (component) => component.setOptions(options));
    if ("configure" in options) {
      var _context8;
      if (!this.configurator) {
        this.configurator = this._createConfigurator();
      }
      this.configurator.setOptions(options.configure);
      const appliedOptions = availableUtils.deepExtend({}, this.options);
      _forEachInstanceProperty(_context8 = this.components).call(_context8, (component) => {
        availableUtils.deepExtend(appliedOptions, component.options);
      });
      this.configurator.setModuleOptions({
        global: appliedOptions
      });
    }
    this._redraw();
  }
  /**
   * Returns true when the Timeline is active.
   * @returns {boolean}
   */
  isActive() {
    return !this.activator || this.activator.active;
  }
  /**
   * Destroy the Core, clean up all DOM elements and event listeners.
   */
  destroy() {
    var _context9;
    this.setItems(null);
    this.setGroups(null);
    this.off();
    this._stopAutoResize();
    if (this.dom.root.parentNode) {
      this.dom.root.parentNode.removeChild(this.dom.root);
    }
    this.dom = null;
    if (this.activator) {
      this.activator.destroy();
      delete this.activator;
    }
    for (const event2 in this.timelineListeners) {
      if (Object.prototype.hasOwnProperty.call(this.timelineListeners, event2)) {
        delete this.timelineListeners[event2];
      }
    }
    this.timelineListeners = null;
    this.hammer && this.hammer.destroy();
    this.hammer = null;
    _forEachInstanceProperty(_context9 = this.components).call(_context9, (component) => component.destroy());
    this.body = null;
  }
  /**
   * Set a custom time bar
   * @param {Date} time
   * @param {number} [id=undefined] Optional id of the custom time bar to be adjusted.
   */
  setCustomTime(time, id) {
    var _context0;
    const customTimes = _filterInstanceProperty(_context0 = this.customTimes).call(_context0, (component) => id === component.options.id);
    if (customTimes.length === 0) {
      throw new Error("No custom time bar found with id ".concat(_JSON$stringify(id)));
    }
    if (customTimes.length > 0) {
      customTimes[0].setCustomTime(time);
    }
  }
  /**
   * Retrieve the current custom time.
   * @param {number} [id=undefined]    Id of the custom time bar.
   * @return {Date | undefined} customTime
   */
  getCustomTime(id) {
    var _context1;
    const customTimes = _filterInstanceProperty(_context1 = this.customTimes).call(_context1, (component) => component.options.id === id);
    if (customTimes.length === 0) {
      throw new Error("No custom time bar found with id ".concat(_JSON$stringify(id)));
    }
    return customTimes[0].getCustomTime();
  }
  /**
   * Set a custom marker for the custom time bar.
   * @param {string} [title] Title of the custom marker.
   * @param {number} [id=undefined] Id of the custom marker.
   * @param {boolean} [editable=false] Make the custom marker editable.
   */
  setCustomTimeMarker(title, id, editable) {
    var _context10;
    const customTimes = _filterInstanceProperty(_context10 = this.customTimes).call(_context10, (component) => component.options.id === id);
    if (customTimes.length === 0) {
      throw new Error("No custom time bar found with id ".concat(_JSON$stringify(id)));
    }
    if (customTimes.length > 0) {
      customTimes[0].setCustomMarker(title, editable);
    }
  }
  /**
   * Set a custom title for the custom time bar.
   * @param {string} [title] Custom title
   * @param {number} [id=undefined]    Id of the custom time bar.
   * @returns {*}
   */
  setCustomTimeTitle(title, id) {
    var _context11;
    const customTimes = _filterInstanceProperty(_context11 = this.customTimes).call(_context11, (component) => component.options.id === id);
    if (customTimes.length === 0) {
      throw new Error("No custom time bar found with id ".concat(_JSON$stringify(id)));
    }
    if (customTimes.length > 0) {
      return customTimes[0].setCustomTitle(title);
    }
  }
  /**
   * Retrieve meta information from an event.
   * Should be overridden by classes extending Core
   * @param {Event} event
   * @return {Object} An object with related information.
   */
  getEventProperties(event2) {
    return {
      event: event2
    };
  }
  /**
   * Add custom vertical bar
   * @param {Date | string | number} [time]  A Date, unix timestamp, or
   *                                         ISO date string. Time point where
   *                                         the new bar should be placed.
   *                                         If not provided, `new Date()` will
   *                                         be used.
   * @param {number | string} [id=undefined] Id of the new bar. Optional
   * @return {number | string}               Returns the id of the new bar
   */
  addCustomTime(time, id) {
    var _context12;
    const timestamp = time !== void 0 ? availableUtils.convert(time, "Date") : /* @__PURE__ */ new Date();
    const exists = _someInstanceProperty(_context12 = this.customTimes).call(_context12, (customTime2) => customTime2.options.id === id);
    if (exists) {
      throw new Error("A custom time with id ".concat(_JSON$stringify(id), " already exists"));
    }
    const customTime = new CustomTime(this.body, availableUtils.extend({}, this.options, {
      time: timestamp,
      id,
      snap: this.itemSet ? this.itemSet.options.snap : this.options.snap
    }));
    this.customTimes.push(customTime);
    this.components.push(customTime);
    this._redraw();
    return id;
  }
  /**
   * Remove previously added custom bar
   * @param {int} id ID of the custom bar to be removed
   * [at]returns {boolean} True if the bar exists and is removed, false otherwise
   */
  removeCustomTime(id) {
    var _context13;
    const customTimes = _filterInstanceProperty(_context13 = this.customTimes).call(_context13, (bar) => bar.options.id === id);
    if (customTimes.length === 0) {
      throw new Error("No custom time bar found with id ".concat(_JSON$stringify(id)));
    }
    _forEachInstanceProperty(customTimes).call(customTimes, (customTime) => {
      var _context14, _context15, _context16, _context17;
      _spliceInstanceProperty(_context14 = this.customTimes).call(_context14, _indexOfInstanceProperty(_context15 = this.customTimes).call(_context15, customTime), 1);
      _spliceInstanceProperty(_context16 = this.components).call(_context16, _indexOfInstanceProperty(_context17 = this.components).call(_context17, customTime), 1);
      customTime.destroy();
    });
  }
  /**
   * Get the id's of the currently visible items.
   * @returns {Array} The ids of the visible items
   */
  getVisibleItems() {
    return this.itemSet && this.itemSet.getVisibleItems() || [];
  }
  /**
   * Get the id's of the items at specific time, where a click takes place on the timeline.
   * @param {Date} timeOfEvent The point in time to query items.
   * @returns {Array} The ids of all items in existence at the time of event.
   */
  getItemsAtCurrentTime(timeOfEvent) {
    this.time = timeOfEvent;
    return this.itemSet && this.itemSet.getItemsAtCurrentTime(this.time) || [];
  }
  /**
   * Get the id's of the currently visible groups.
   * @returns {Array} The ids of the visible groups
   */
  getVisibleGroups() {
    return this.itemSet && this.itemSet.getVisibleGroups() || [];
  }
  /**
   * Set Core window such that it fits all items
   * @param {Object} [options]  Available options:
   *                                `animation: boolean | {duration: number, easingFunction: string}`
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   * @param {function} [callback] a callback funtion to be executed at the end of this function
   */
  fit(options, callback) {
    const range = this.getDataRange();
    if (range.min === null && range.max === null) {
      return;
    }
    const interval = range.max - range.min;
    const min = new Date(range.min.valueOf() - interval * 0.01);
    const max = new Date(range.max.valueOf() + interval * 0.01);
    const animation = options && options.animation !== void 0 ? options.animation : true;
    this.range.setRange(min, max, {
      animation
    }, callback);
  }
  /**
   * Calculate the data range of the items start and end dates
   * [at]returns {{min: [Date], max: [Date]}}
   * @protected
   */
  getDataRange() {
    throw new Error("Cannot invoke abstract method getDataRange");
  }
  /**
   * Set the visible window. Both parameters are optional, you can change only
   * start or only end. Syntax:
   *
   *     TimeLine.setWindow(start, end)
   *     TimeLine.setWindow(start, end, options)
   *     TimeLine.setWindow(range)
   *
   * Where start and end can be a Date, number, or string, and range is an
   * object with properties start and end.
   *
   * @param {Date | number | string | Object} [start] Start date of visible window
   * @param {Date | number | string} [end]            End date of visible window
   * @param {Object} [options]  Available options:
   *                                `animation: boolean | {duration: number, easingFunction: string}`
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   * @param {function} [callback] a callback funtion to be executed at the end of this function
   */
  setWindow(start, end, options, callback) {
    if (typeof arguments[2] == "function") {
      callback = arguments[2];
      options = {};
    }
    let animation;
    let range;
    if (arguments.length == 1) {
      range = arguments[0];
      animation = range.animation !== void 0 ? range.animation : true;
      this.range.setRange(range.start, range.end, {
        animation
      });
    } else if (arguments.length == 2 && typeof arguments[1] == "function") {
      range = arguments[0];
      callback = arguments[1];
      animation = range.animation !== void 0 ? range.animation : true;
      this.range.setRange(range.start, range.end, {
        animation
      }, callback);
    } else {
      animation = options && options.animation !== void 0 ? options.animation : true;
      this.range.setRange(start, end, {
        animation
      }, callback);
    }
  }
  /**
   * Move the window such that given time is centered on screen.
   * @param {Date | number | string} time
   * @param {Object} [options]  Available options:
   *                                `animation: boolean | {duration: number, easingFunction: string}`
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   * @param {function} [callback] a callback funtion to be executed at the end of this function
   */
  moveTo(time, options, callback) {
    if (typeof arguments[1] == "function") {
      callback = arguments[1];
      options = {};
    }
    const interval = this.range.end - this.range.start;
    const t = availableUtils.convert(time, "Date").valueOf();
    const start = t - interval / 2;
    const end = t + interval / 2;
    const animation = options && options.animation !== void 0 ? options.animation : true;
    this.range.setRange(start, end, {
      animation
    }, callback);
  }
  /**
   * Get the visible window
   * @return {{start: Date, end: Date}}   Visible range
   */
  getWindow() {
    const range = this.range.getRange();
    return {
      start: new Date(range.start),
      end: new Date(range.end)
    };
  }
  /**
   * Zoom in the window such that given time is centered on screen.
   * @param {number} percentage - must be between [0..1]
   * @param {Object} [options]  Available options:
   *                                `animation: boolean | {duration: number, easingFunction: string}`
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   * @param {function} [callback] a callback funtion to be executed at the end of this function
   */
  zoomIn(percentage, options, callback) {
    if (!percentage || percentage < 0 || percentage > 1) return;
    if (typeof arguments[1] == "function") {
      callback = arguments[1];
      options = {};
    }
    const range = this.getWindow();
    const start = range.start.valueOf();
    const end = range.end.valueOf();
    const interval = end - start;
    const newInterval = interval / (1 + percentage);
    const distance = (interval - newInterval) / 2;
    const newStart = start + distance;
    const newEnd = end - distance;
    this.setWindow(newStart, newEnd, options, callback);
  }
  /**
   * Zoom out the window such that given time is centered on screen.
   * @param {number} percentage - must be between [0..1]
   * @param {Object} [options]  Available options:
   *                                `animation: boolean | {duration: number, easingFunction: string}`
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   * @param {function} [callback] a callback funtion to be executed at the end of this function
   */
  zoomOut(percentage, options, callback) {
    if (!percentage || percentage < 0 || percentage > 1) return;
    if (typeof arguments[1] == "function") {
      callback = arguments[1];
      options = {};
    }
    const range = this.getWindow();
    const start = range.start.valueOf();
    const end = range.end.valueOf();
    const interval = end - start;
    const newStart = start - interval * percentage / 2;
    const newEnd = end + interval * percentage / 2;
    this.setWindow(newStart, newEnd, options, callback);
  }
  /**
   * Force a redraw. Can be overridden by implementations of Core
   *
   * Note: this function will be overridden on construction with a trottled version
   */
  redraw() {
    this._redraw();
  }
  /**
   * Redraw for internal use. Redraws all components. See also the public
   * method redraw.
   * @protected
   */
  _redraw() {
    var _context18;
    this.redrawCount++;
    const dom2 = this.dom;
    if (!dom2 || !dom2.container || dom2.root.offsetWidth == 0) return;
    let resized = false;
    const options = this.options;
    const props = this.props;
    updateHiddenDates(this.options.moment, this.body, this.options.hiddenDates);
    if (options.orientation == "top") {
      availableUtils.addClassName(dom2.root, "vis-top");
      availableUtils.removeClassName(dom2.root, "vis-bottom");
    } else {
      availableUtils.removeClassName(dom2.root, "vis-top");
      availableUtils.addClassName(dom2.root, "vis-bottom");
    }
    if (options.rtl) {
      availableUtils.addClassName(dom2.root, "vis-rtl");
      availableUtils.removeClassName(dom2.root, "vis-ltr");
    } else {
      availableUtils.addClassName(dom2.root, "vis-ltr");
      availableUtils.removeClassName(dom2.root, "vis-rtl");
    }
    dom2.root.style.maxHeight = availableUtils.option.asSize(options.maxHeight, "");
    dom2.root.style.minHeight = availableUtils.option.asSize(options.minHeight, "");
    dom2.root.style.width = availableUtils.option.asSize(options.width, "");
    const rootOffsetWidth = dom2.root.offsetWidth;
    props.border.left = 1;
    props.border.right = 1;
    props.border.top = 1;
    props.border.bottom = 1;
    props.center.height = dom2.center.offsetHeight;
    props.left.height = dom2.left.offsetHeight;
    props.right.height = dom2.right.offsetHeight;
    props.top.height = dom2.top.clientHeight || -props.border.top;
    props.bottom.height = Math.round(dom2.bottom.getBoundingClientRect().height) || dom2.bottom.clientHeight || -props.border.bottom;
    const contentHeight = Math.max(props.left.height, props.center.height, props.right.height);
    const autoHeight = props.top.height + contentHeight + props.bottom.height + props.border.top + props.border.bottom;
    dom2.root.style.height = availableUtils.option.asSize(options.height, "".concat(autoHeight, "px"));
    props.root.height = dom2.root.offsetHeight;
    props.background.height = props.root.height;
    const containerHeight = props.root.height - props.top.height - props.bottom.height;
    props.centerContainer.height = containerHeight;
    props.leftContainer.height = containerHeight;
    props.rightContainer.height = props.leftContainer.height;
    props.root.width = rootOffsetWidth;
    props.background.width = props.root.width;
    if (!this.initialDrawDone) {
      props.scrollbarWidth = availableUtils.getScrollBarWidth();
    }
    const leftContainerClientWidth = dom2.leftContainer.clientWidth;
    const rightContainerClientWidth = dom2.rightContainer.clientWidth;
    if (options.verticalScroll) {
      if (options.rtl) {
        props.left.width = leftContainerClientWidth || -props.border.left;
        props.right.width = rightContainerClientWidth + props.scrollbarWidth || -props.border.right;
      } else {
        props.left.width = leftContainerClientWidth + props.scrollbarWidth || -props.border.left;
        props.right.width = rightContainerClientWidth || -props.border.right;
      }
    } else {
      props.left.width = leftContainerClientWidth || -props.border.left;
      props.right.width = rightContainerClientWidth || -props.border.right;
    }
    this._setDOM();
    let offset = this._updateScrollTop();
    if (options.orientation.item != "top") {
      offset += Math.max(props.centerContainer.height - props.center.height - props.border.top - props.border.bottom, 0);
    }
    dom2.center.style.transform = "translateY(".concat(offset, "px)");
    const visibilityTop = props.scrollTop == 0 ? "hidden" : "";
    const visibilityBottom = props.scrollTop == props.scrollTopMin ? "hidden" : "";
    dom2.shadowTop.style.visibility = visibilityTop;
    dom2.shadowBottom.style.visibility = visibilityBottom;
    dom2.shadowTopLeft.style.visibility = visibilityTop;
    dom2.shadowBottomLeft.style.visibility = visibilityBottom;
    dom2.shadowTopRight.style.visibility = visibilityTop;
    dom2.shadowBottomRight.style.visibility = visibilityBottom;
    if (options.verticalScroll) {
      dom2.rightContainer.className = "vis-panel vis-right vis-vertical-scroll";
      dom2.leftContainer.className = "vis-panel vis-left vis-vertical-scroll";
      dom2.shadowTopRight.style.visibility = "hidden";
      dom2.shadowBottomRight.style.visibility = "hidden";
      dom2.shadowTopLeft.style.visibility = "hidden";
      dom2.shadowBottomLeft.style.visibility = "hidden";
      dom2.left.style.top = "0px";
      dom2.right.style.top = "0px";
    }
    if (!options.verticalScroll || props.center.height < props.centerContainer.height) {
      dom2.left.style.top = "".concat(offset, "px");
      dom2.right.style.top = "".concat(offset, "px");
      dom2.rightContainer.className = dom2.rightContainer.className.replace(new RegExp("(?:^|\\s)vis-vertical-scroll(?:\\s|$)"), " ");
      dom2.leftContainer.className = dom2.leftContainer.className.replace(new RegExp("(?:^|\\s)vis-vertical-scroll(?:\\s|$)"), " ");
      props.left.width = leftContainerClientWidth || -props.border.left;
      props.right.width = rightContainerClientWidth || -props.border.right;
      this._setDOM();
    }
    const contentsOverflow = props.center.height > props.centerContainer.height;
    this.hammer.get("pan").set({
      direction: contentsOverflow ? Hammer.DIRECTION_ALL : Hammer.DIRECTION_HORIZONTAL
    });
    this.hammer.get("press").set({
      time: this.options.longSelectPressTime
    });
    _forEachInstanceProperty(_context18 = this.components).call(_context18, (component) => {
      resized = component.redraw() || resized;
    });
    const MAX_REDRAW = 5;
    if (resized) {
      if (this.redrawCount < MAX_REDRAW) {
        this.body.emitter.emit("_change");
        return;
      } else {
        console.log("WARNING: infinite loop in redraw?");
      }
    } else {
      this.redrawCount = 0;
    }
    this.body.emitter.emit("changed");
  }
  /**
   * sets the basic DOM components needed for the timeline\graph2d
   */
  _setDOM() {
    const props = this.props;
    const dom2 = this.dom;
    props.leftContainer.width = props.left.width;
    props.rightContainer.width = props.right.width;
    const centerWidth = props.root.width - props.left.width - props.right.width;
    props.center.width = centerWidth;
    props.centerContainer.width = centerWidth;
    props.top.width = centerWidth;
    props.bottom.width = centerWidth;
    dom2.background.style.height = "".concat(props.background.height, "px");
    dom2.backgroundVertical.style.height = "".concat(props.background.height, "px");
    dom2.backgroundHorizontal.style.height = "".concat(props.centerContainer.height, "px");
    dom2.centerContainer.style.height = "".concat(props.centerContainer.height, "px");
    dom2.leftContainer.style.height = "".concat(props.leftContainer.height, "px");
    dom2.rightContainer.style.height = "".concat(props.rightContainer.height, "px");
    dom2.background.style.width = "".concat(props.background.width, "px");
    dom2.backgroundVertical.style.width = "".concat(props.centerContainer.width, "px");
    dom2.backgroundHorizontal.style.width = "".concat(props.background.width, "px");
    dom2.centerContainer.style.width = "".concat(props.center.width, "px");
    dom2.top.style.width = "".concat(props.top.width, "px");
    dom2.bottom.style.width = "".concat(props.bottom.width, "px");
    dom2.background.style.left = "0";
    dom2.background.style.top = "0";
    dom2.backgroundVertical.style.left = "".concat(props.left.width + props.border.left, "px");
    dom2.backgroundVertical.style.top = "0";
    dom2.backgroundHorizontal.style.left = "0";
    dom2.backgroundHorizontal.style.top = "".concat(props.top.height, "px");
    dom2.centerContainer.style.left = "".concat(props.left.width, "px");
    dom2.centerContainer.style.top = "".concat(props.top.height, "px");
    dom2.leftContainer.style.left = "0";
    dom2.leftContainer.style.top = "".concat(props.top.height, "px");
    dom2.rightContainer.style.left = "".concat(props.left.width + props.center.width, "px");
    dom2.rightContainer.style.top = "".concat(props.top.height, "px");
    dom2.top.style.left = "".concat(props.left.width, "px");
    dom2.top.style.top = "0";
    dom2.bottom.style.left = "".concat(props.left.width, "px");
    dom2.bottom.style.top = "".concat(props.top.height + props.centerContainer.height, "px");
    dom2.center.style.left = "0";
    dom2.left.style.left = "0";
    dom2.right.style.left = "0";
  }
  /**
   * Set a current time. This can be used for example to ensure that a client's
   * time is synchronized with a shared server time.
   * Only applicable when option `showCurrentTime` is true.
   * @param {Date | string | number} time     A Date, unix timestamp, or
   *                                          ISO date string.
   */
  setCurrentTime(time) {
    if (!this.currentTime) {
      throw new Error("Option showCurrentTime must be true");
    }
    this.currentTime.setCurrentTime(time);
  }
  /**
   * Get the current time.
   * Only applicable when option `showCurrentTime` is true.
   * @return {Date} Returns the current time.
   */
  getCurrentTime() {
    if (!this.currentTime) {
      throw new Error("Option showCurrentTime must be true");
    }
    return this.currentTime.getCurrentTime();
  }
  /**
   * Convert a position on screen (pixels) to a datetime
   * @param {int}     x    Position on the screen in pixels
   * @return {Date}   time The datetime the corresponds with given position x
   * @protected
   * TODO: move this function to Range
   */
  _toTime(x) {
    return toTime(this, x, this.props.center.width);
  }
  /**
   * Convert a position on the global screen (pixels) to a datetime
   * @param {int}     x    Position on the screen in pixels
   * @return {Date}   time The datetime the corresponds with given position x
   * @protected
   * TODO: move this function to Range
   */
  _toGlobalTime(x) {
    return toTime(this, x, this.props.root.width);
  }
  /**
   * Convert a datetime (Date object) into a position on the screen
   * @param {Date}   time A date
   * @return {int}   x    The position on the screen in pixels which corresponds
   *                      with the given date.
   * @protected
   * TODO: move this function to Range
   */
  _toScreen(time) {
    return toScreen(this, time, this.props.center.width);
  }
  /**
   * Convert a datetime (Date object) into a position on the root
   * This is used to get the pixel density estimate for the screen, not the center panel
   * @param {Date}   time A date
   * @return {int}   x    The position on root in pixels which corresponds
   *                      with the given date.
   * @protected
   * TODO: move this function to Range
   */
  _toGlobalScreen(time) {
    return toScreen(this, time, this.props.root.width);
  }
  /**
   * Initialize watching when option autoResize is true
   * @private
   */
  _initAutoResize() {
    if (this.options.autoResize == true) {
      this._startAutoResize();
    } else {
      this._stopAutoResize();
    }
  }
  /**
   * Watch for changes in the size of the container. On resize, the Panel will
   * automatically redraw itself.
   * @private
   */
  _startAutoResize() {
    const me = this;
    this._stopAutoResize();
    this._onResize = () => {
      if (me.options.autoResize != true) {
        me._stopAutoResize();
        return;
      }
      if (me.dom.root) {
        const rootOffsetHeight = me.dom.root.offsetHeight;
        const rootOffsetWidth = me.dom.root.offsetWidth;
        if (rootOffsetWidth != me.props.lastWidth || rootOffsetHeight != me.props.lastHeight) {
          me.props.lastWidth = rootOffsetWidth;
          me.props.lastHeight = rootOffsetHeight;
          me.props.scrollbarWidth = availableUtils.getScrollBarWidth();
          me.body.emitter.emit("_change");
        }
      }
    };
    window.addEventListener("resize", this._onResize);
    if (me.dom.root) {
      me.props.lastWidth = me.dom.root.offsetWidth;
      me.props.lastHeight = me.dom.root.offsetHeight;
    }
    this.watchTimer = _setInterval(this._onResize, 1e3);
  }
  /**
   * Stop watching for a resize of the frame.
   * @private
   */
  _stopAutoResize() {
    if (this.watchTimer) {
      clearInterval(this.watchTimer);
      this.watchTimer = void 0;
    }
    if (this._onResize) {
      window.removeEventListener("resize", this._onResize);
      this._onResize = null;
    }
  }
  /**
   * Start moving the timeline vertically
   * @private
   */
  _onTouch() {
    this.touch.allowDragging = true;
    this.touch.initialScrollTop = this.props.scrollTop;
  }
  /**
   * Start moving the timeline vertically
   * @private
   */
  _onPinch() {
    this.touch.allowDragging = false;
  }
  /**
   * Move the timeline vertically
   * @param {Event} event
   * @private
   */
  _onDrag(event2) {
    if (!event2) return;
    if (!this.touch.allowDragging) return;
    const delta = event2.deltaY;
    const oldScrollTop = this._getScrollTop();
    const newScrollTop = this._setScrollTop(this.touch.initialScrollTop + delta);
    if (this.options.verticalScroll) {
      this.dom.left.parentNode.scrollTop = -this.props.scrollTop;
      this.dom.right.parentNode.scrollTop = -this.props.scrollTop;
    }
    if (newScrollTop != oldScrollTop) {
      this.emit("verticalDrag");
    }
  }
  /**
   * Apply a scrollTop
   * @param {number} scrollTop
   * @returns {number} scrollTop  Returns the applied scrollTop
   * @private
   */
  _setScrollTop(scrollTop) {
    this.props.scrollTop = scrollTop;
    this._updateScrollTop();
    return this.props.scrollTop;
  }
  /**
   * Update the current scrollTop when the height of  the containers has been changed
   * @returns {number} scrollTop  Returns the applied scrollTop
   * @private
   */
  _updateScrollTop() {
    const scrollTopMin = Math.min(this.props.centerContainer.height - this.props.border.top - this.props.border.bottom - this.props.center.height, 0);
    if (scrollTopMin != this.props.scrollTopMin) {
      if (this.options.orientation.item != "top") {
        this.props.scrollTop += scrollTopMin - this.props.scrollTopMin;
      }
      this.props.scrollTopMin = scrollTopMin;
    }
    if (this.props.scrollTop > 0) this.props.scrollTop = 0;
    if (this.props.scrollTop < scrollTopMin) this.props.scrollTop = scrollTopMin;
    if (this.options.verticalScroll) {
      this.dom.left.parentNode.scrollTop = -this.props.scrollTop;
      this.dom.right.parentNode.scrollTop = -this.props.scrollTop;
    }
    return this.props.scrollTop;
  }
  /**
   * Get the current scrollTop
   * @returns {number} scrollTop
   * @private
   */
  _getScrollTop() {
    return this.props.scrollTop;
  }
  /**
   * Load a configurator
   * [at]returns {Object}
   * @private
   */
  _createConfigurator() {
    throw new Error("Cannot invoke abstract method _createConfigurator");
  }
};
Emitter(Core.prototype);
var CurrentTime = class extends Component {
  /**
   * @param {{range: Range, dom: Object, domProps: Object}} body
   * @param {Object} [options]        Available parameters:
   *                                  {Boolean} [showCurrentTime]
   *                                  {String}  [alignCurrentTime]
   * @constructor CurrentTime
   * @extends Component
   */
  constructor(body, options) {
    var _context;
    super();
    this.body = body;
    this.defaultOptions = {
      rtl: false,
      showCurrentTime: true,
      alignCurrentTime: void 0,
      moment: moment$2,
      locales,
      locale: "en"
    };
    this.options = availableUtils.extend({}, this.defaultOptions);
    this.setOptions(options);
    this.options.locales = availableUtils.extend({}, locales, this.options.locales);
    const defaultLocales = this.defaultOptions.locales[this.defaultOptions.locale];
    _forEachInstanceProperty(_context = _Object$keys(this.options.locales)).call(_context, (locale) => {
      this.options.locales[locale] = availableUtils.extend({}, defaultLocales, this.options.locales[locale]);
    });
    this.offset = 0;
    this._create();
  }
  /**
   * Create the HTML DOM for the current time bar
   * @private
   */
  _create() {
    const bar = document.createElement("div");
    bar.className = "vis-current-time";
    bar.style.position = "absolute";
    bar.style.top = "0px";
    bar.style.height = "100%";
    this.bar = bar;
  }
  /**
   * Destroy the CurrentTime bar
   */
  destroy() {
    this.options.showCurrentTime = false;
    this.redraw();
    this.body = null;
  }
  /**
   * Set options for the component. Options will be merged in current options.
   * @param {Object} options  Available parameters:
   *                          {boolean} [showCurrentTime]
   *                          {String}  [alignCurrentTime]
   */
  setOptions(options) {
    if (options) {
      availableUtils.selectiveExtend(["rtl", "showCurrentTime", "alignCurrentTime", "moment", "locale", "locales"], this.options, options);
    }
  }
  /**
   * Repaint the component
   * @return {boolean} Returns true if the component is resized
   */
  redraw() {
    if (this.options.showCurrentTime) {
      var _context2, _context3;
      const parent = this.body.dom.backgroundVertical;
      if (this.bar.parentNode != parent) {
        if (this.bar.parentNode) {
          this.bar.parentNode.removeChild(this.bar);
        }
        parent.appendChild(this.bar);
        this.start();
      }
      let now2 = this.options.moment(_Date$now() + this.offset);
      if (this.options.alignCurrentTime) {
        now2 = now2.startOf(this.options.alignCurrentTime);
      }
      const x = this.body.util.toScreen(now2);
      let locale = this.options.locales[this.options.locale];
      if (!locale) {
        if (!this.warned) {
          console.warn("WARNING: options.locales['".concat(this.options.locale, "'] not found. See https://visjs.github.io/vis-timeline/docs/timeline/#Localization"));
          this.warned = true;
        }
        locale = this.options.locales["en"];
      }
      let title = _concatInstanceProperty(_context2 = _concatInstanceProperty(_context3 = "".concat(locale.current, " ")).call(_context3, locale.time, ": ")).call(_context2, now2.format("dddd, MMMM Do YYYY, H:mm:ss"));
      title = title.charAt(0).toUpperCase() + title.substring(1);
      if (this.options.rtl) {
        this.bar.style.transform = "translateX(".concat(x * -1, "px)");
      } else {
        this.bar.style.transform = "translateX(".concat(x, "px)");
      }
      this.bar.title = title;
    } else {
      if (this.bar.parentNode) {
        this.bar.parentNode.removeChild(this.bar);
      }
      this.stop();
    }
    return false;
  }
  /**
   * Start auto refreshing the current time bar
   */
  start() {
    const me = this;
    function update() {
      me.stop();
      const scale = me.body.range.conversion(me.body.domProps.center.width).scale;
      let interval = 1 / scale / 10;
      if (interval < 30) interval = 30;
      if (interval > 1e3) interval = 1e3;
      me.redraw();
      me.body.emitter.emit("currentTimeTick");
      me.currentTimeTimer = _setTimeout(update, interval);
    }
    update();
  }
  /**
   * Stop auto refreshing the current time bar
   */
  stop() {
    if (this.currentTimeTimer !== void 0) {
      clearTimeout(this.currentTimeTimer);
      delete this.currentTimeTimer;
    }
  }
  /**
   * Set a current time. This can be used for example to ensure that a client's
   * time is synchronized with a shared server time.
   * @param {Date | string | number} time     A Date, unix timestamp, or
   *                                          ISO date string.
   */
  setCurrentTime(time) {
    const t = availableUtils.convert(time, "Date").valueOf();
    const now2 = _Date$now();
    this.offset = t - now2;
    this.redraw();
  }
  /**
   * Get the current time.
   * @return {Date} Returns the current time.
   */
  getCurrentTime() {
    return new Date(_Date$now() + this.offset);
  }
};
var es_array_find = {};
var hasRequiredEs_array_find;
function requireEs_array_find() {
  if (hasRequiredEs_array_find) return es_array_find;
  hasRequiredEs_array_find = 1;
  var $ = require_export();
  var $find = requireArrayIteration().find;
  var addToUnscopables2 = requireAddToUnscopables();
  var FIND = "find";
  var SKIPS_HOLES = true;
  if (FIND in []) Array(1)[FIND](function() {
    SKIPS_HOLES = false;
  });
  $({ target: "Array", proto: true, forced: SKIPS_HOLES }, {
    find: function find2(callbackfn) {
      return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    }
  });
  addToUnscopables2(FIND);
  return es_array_find;
}
var find$3;
var hasRequiredFind$3;
function requireFind$3() {
  if (hasRequiredFind$3) return find$3;
  hasRequiredFind$3 = 1;
  requireEs_array_find();
  var getBuiltInPrototypeMethod2 = requireGetBuiltInPrototypeMethod();
  find$3 = getBuiltInPrototypeMethod2("Array", "find");
  return find$3;
}
var find$2;
var hasRequiredFind$2;
function requireFind$2() {
  if (hasRequiredFind$2) return find$2;
  hasRequiredFind$2 = 1;
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var method = requireFind$3();
  var ArrayPrototype = Array.prototype;
  find$2 = function(it2) {
    var own = it2.find;
    return it2 === ArrayPrototype || isPrototypeOf(ArrayPrototype, it2) && own === ArrayPrototype.find ? method : own;
  };
  return find$2;
}
var find$1;
var hasRequiredFind$1;
function requireFind$1() {
  if (hasRequiredFind$1) return find$1;
  hasRequiredFind$1 = 1;
  var parent = requireFind$2();
  find$1 = parent;
  return find$1;
}
var find;
var hasRequiredFind;
function requireFind() {
  if (hasRequiredFind) return find;
  hasRequiredFind = 1;
  find = requireFind$1();
  return find;
}
var findExports = requireFind();
var _findInstanceProperty = getDefaultExportFromCjs(findExports);
var EPSILON = 1e-3;
function orderByStart(items) {
  _sortInstanceProperty(items).call(items, (a, b) => a.data.start - b.data.start);
}
function orderByEnd(items) {
  _sortInstanceProperty(items).call(items, (a, b) => {
    const aTime = "end" in a.data ? a.data.end : a.data.start;
    const bTime = "end" in b.data ? b.data.end : b.data.start;
    return aTime - bTime;
  });
}
function stack(items, margin, force, shouldBailItemsRedrawFunction) {
  const stackingResult = performStacking(items, margin.item, false, (item) => item.stack && (force || item.top === null), (item) => item.stack, () => margin.axis, shouldBailItemsRedrawFunction);
  return stackingResult === null;
}
function substack(items, margin, subgroup) {
  const subgroupHeight = performStacking(items, margin.item, false, (item) => item.stack, () => true, (item) => item.baseTop);
  subgroup.height = subgroupHeight - subgroup.top + 0.5 * margin.item.vertical;
}
function nostack(items, margin, subgroups, isStackSubgroups) {
  for (let i = 0; i < items.length; i++) {
    if (items[i].data.subgroup == void 0) {
      items[i].top = margin.item.vertical;
      continue;
    }
    if (items[i].data.subgroup === void 0 || !isStackSubgroups) continue;
    let newTop = 0;
    for (const subgroup in subgroups) {
      if (!Object.prototype.hasOwnProperty.call(subgroups, subgroup) || subgroups[subgroup].visible !== true || subgroups[subgroup].index >= subgroups[items[i].data.subgroup].index) continue;
      newTop += subgroups[subgroup].height;
      subgroups[items[i].data.subgroup].top = newTop;
    }
    items[i].top = newTop + 0.5 * margin.item.vertical;
  }
  if (!isStackSubgroups) stackSubgroups(items, margin, subgroups);
}
function stackSubgroups(items, margin, subgroups) {
  var _context;
  performStacking(_sortInstanceProperty(_context = _Object$values(subgroups)).call(_context, (a, b) => {
    if (a.index > b.index) return 1;
    if (a.index < b.index) return -1;
    return 0;
  }), {
    vertical: 0
  }, true, () => true, () => true, () => 0);
  for (let i = 0; i < items.length; i++) {
    if (items[i].data.subgroup !== void 0) {
      items[i].top = subgroups[items[i].data.subgroup].top + 0.5 * margin.item.vertical;
    }
  }
}
function stackSubgroupsWithInnerStack(subgroupItems, margin, subgroups) {
  let doSubStack = false;
  const subgroupOrder = [];
  for (let subgroup in subgroups) {
    if (Object.prototype.hasOwnProperty.call(subgroups[subgroup], "index")) {
      subgroupOrder[subgroups[subgroup].index] = subgroup;
    } else {
      subgroupOrder.push(subgroup);
    }
  }
  for (let j = 0; j < subgroupOrder.length; j++) {
    let subgroup = subgroupOrder[j];
    if (!Object.prototype.hasOwnProperty.call(subgroups, subgroup)) continue;
    doSubStack = doSubStack || subgroups[subgroup].stack;
    subgroups[subgroup].top = 0;
    for (const otherSubgroup in subgroups) {
      if (subgroups[otherSubgroup].visible && subgroups[subgroup].index > subgroups[otherSubgroup].index) {
        subgroups[subgroup].top += subgroups[otherSubgroup].height;
      }
    }
    const items = subgroupItems[subgroup];
    for (let i = 0; i < items.length; i++) {
      if (items[i].data.subgroup === void 0) continue;
      items[i].top = subgroups[items[i].data.subgroup].top + 0.5 * margin.item.vertical;
      if (subgroups[subgroup].stack) items[i].baseTop = items[i].top;
    }
    if (doSubStack && subgroups[subgroup].stack) substack(subgroupItems[subgroup], margin, subgroups[subgroup]);
  }
}
function performStacking(items, margins, compareTimes, shouldStack, shouldOthersStack, getInitialHeight, shouldBail) {
  let getItemStart = (item) => item.start;
  let getItemEnd = (item) => item.end;
  if (!compareTimes) {
    const rtl = !!(items[0] && items[0].options.rtl);
    if (rtl) {
      getItemStart = (item) => item.right;
    } else {
      getItemStart = (item) => item.left;
    }
    getItemEnd = (item) => getItemStart(item) + item.width + margins.horizontal;
  }
  const itemsToPosition = [];
  const itemsAlreadyPositioned = [];
  let previousStart = null;
  let insertionIndex = 0;
  for (const item of items) {
    if (shouldStack(item)) {
      itemsToPosition.push(item);
    } else {
      if (shouldOthersStack(item)) {
        const itemStart = getItemStart(item);
        if (previousStart !== null && itemStart < previousStart - EPSILON) {
          insertionIndex = 0;
        }
        previousStart = itemStart;
        insertionIndex = findIndexFrom(itemsAlreadyPositioned, (i) => getItemStart(i) - EPSILON > itemStart, insertionIndex);
        _spliceInstanceProperty(itemsAlreadyPositioned).call(itemsAlreadyPositioned, insertionIndex, 0, item);
        insertionIndex++;
      }
    }
  }
  previousStart = null;
  let previousEnd = null;
  insertionIndex = 0;
  let horizontalOverlapStartIndex = 0;
  let horizontalOverlapEndIndex = 0;
  let maxHeight = 0;
  while (itemsToPosition.length > 0) {
    var _context2;
    const item = itemsToPosition.shift();
    item.top = getInitialHeight(item);
    const itemStart = getItemStart(item);
    const itemEnd = getItemEnd(item);
    if (previousStart !== null && itemStart < previousStart - EPSILON) {
      horizontalOverlapStartIndex = 0;
      horizontalOverlapEndIndex = 0;
      insertionIndex = 0;
      previousEnd = null;
    }
    if (previousStart === null || itemStart > previousStart + EPSILON) {
      horizontalOverlapStartIndex = findIndexFrom(itemsAlreadyPositioned, (i) => itemStart < getItemEnd(i) - EPSILON, horizontalOverlapStartIndex);
    }
    previousStart = itemStart;
    if (previousEnd === null || previousEnd < itemEnd - EPSILON) {
      horizontalOverlapEndIndex = findIndexFrom(itemsAlreadyPositioned, (i) => itemEnd < getItemStart(i) - EPSILON, Math.max(horizontalOverlapStartIndex, horizontalOverlapEndIndex));
    }
    if (previousEnd !== null && previousEnd - EPSILON > itemEnd) {
      horizontalOverlapEndIndex = findLastIndexBetween(itemsAlreadyPositioned, (i) => itemEnd + EPSILON >= getItemStart(i), horizontalOverlapStartIndex, horizontalOverlapEndIndex) + 1;
    }
    previousEnd = itemEnd;
    const horizontallyCollidingItems = _sortInstanceProperty(_context2 = filterBetween(itemsAlreadyPositioned, (i) => itemStart < getItemEnd(i) - EPSILON, horizontalOverlapStartIndex, horizontalOverlapEndIndex)).call(_context2, (a, b) => a.top - b.top);
    for (let i2 = 0; i2 < horizontallyCollidingItems.length; i2++) {
      const otherItem = horizontallyCollidingItems[i2];
      if (checkVerticalSpatialCollision(item, otherItem, margins)) {
        item.top = otherItem.top + otherItem.height + margins.vertical;
      }
    }
    if (shouldOthersStack(item)) {
      insertionIndex = findIndexFrom(itemsAlreadyPositioned, (i) => getItemStart(i) - EPSILON > itemStart, insertionIndex);
      _spliceInstanceProperty(itemsAlreadyPositioned).call(itemsAlreadyPositioned, insertionIndex, 0, item);
      if (insertionIndex < horizontalOverlapStartIndex) {
        horizontalOverlapStartIndex++;
      }
      if (insertionIndex <= horizontalOverlapEndIndex) {
        horizontalOverlapEndIndex++;
      }
      insertionIndex++;
    }
    const currentHeight = item.top + item.height;
    if (currentHeight > maxHeight) {
      maxHeight = currentHeight;
    }
    if (shouldBail && shouldBail()) {
      return null;
    }
  }
  return maxHeight;
}
function checkVerticalSpatialCollision(a, b, margin) {
  return a.top - margin.vertical + EPSILON < b.top + b.height && a.top + a.height + margin.vertical - EPSILON > b.top;
}
function findIndexFrom(arr, predicate, startIndex) {
  if (!startIndex) {
    startIndex = 0;
  }
  for (let i = startIndex; i < arr.length; i++) {
    if (predicate(arr[i])) {
      return i;
    }
  }
  return arr.length;
}
function findLastIndexBetween(arr, predicate, startIndex, endIndex) {
  if (!startIndex) {
    startIndex = 0;
  }
  if (!endIndex) {
    endIndex = arr.length;
  }
  for (let i = endIndex - 1; i >= startIndex; i--) {
    if (predicate(arr[i])) {
      return i;
    }
  }
  return startIndex - 1;
}
function filterBetween(arr, predicate, startIndex, endIndex) {
  if (!startIndex) {
    startIndex = 0;
  }
  if (endIndex) {
    endIndex = Math.min(endIndex, arr.length);
  } else {
    endIndex = arr.length;
  }
  const result = [];
  for (let i = startIndex; i < endIndex; i++) {
    if (predicate(arr[i])) {
      result.push(arr[i]);
    }
  }
  return result;
}
var stack$1 = Object.freeze({
  __proto__: null,
  nostack,
  orderByEnd,
  orderByStart,
  stack,
  stackSubgroups,
  stackSubgroupsWithInnerStack,
  substack
});
var BACKGROUND$1 = "__background__";
var ReservedGroupIds$1 = {
  BACKGROUND: BACKGROUND$1
};
var Group = class {
  /**
   * @param {number | string} groupId
   * @param {Object} data
   * @param {ItemSet} itemSet
   * @constructor Group
   */
  constructor(groupId, data, itemSet) {
    this.groupId = groupId;
    this.subgroups = {};
    this.subgroupStack = {};
    this.subgroupStackAll = false;
    this.subgroupVisibility = {};
    this.doInnerStack = false;
    this.shouldBailStackItems = false;
    this.subgroupIndex = 0;
    this.subgroupOrderer = data && data.subgroupOrder;
    this.itemSet = itemSet;
    this.isVisible = null;
    this.height = 0;
    this.stackDirty = true;
    this._disposeCallbacks = [];
    if (data && data.nestedGroups) {
      this.nestedGroups = data.nestedGroups;
      if (data.showNested == false) {
        this.showNested = false;
      } else {
        this.showNested = true;
      }
    }
    if (data && data.subgroupStack) {
      if (typeof data.subgroupStack === "boolean") {
        this.doInnerStack = data.subgroupStack;
        this.subgroupStackAll = data.subgroupStack;
      } else {
        for (const key in data.subgroupStack) {
          if (!Object.prototype.hasOwnProperty.call(data.subgroupStack, key)) continue;
          this.subgroupStack[key] = data.subgroupStack[key];
          this.doInnerStack = this.doInnerStack || data.subgroupStack[key];
        }
      }
    }
    if (data && data.heightMode) {
      this.heightMode = data.heightMode;
    } else {
      this.heightMode = itemSet.options.groupHeightMode;
    }
    this.nestedInGroup = null;
    this.dom = {};
    this.props = {
      label: {
        width: 0,
        height: 0
      }
    };
    this.className = null;
    this.items = {};
    this.visibleItems = [];
    this.itemsInRange = [];
    this.orderedItems = {
      byStart: [],
      byEnd: []
    };
    this.checkRangedItems = false;
    const handleCheckRangedItems = () => {
      this.checkRangedItems = true;
    };
    this.itemSet.body.emitter.on("checkRangedItems", handleCheckRangedItems);
    this._disposeCallbacks.push(() => {
      this.itemSet.body.emitter.off("checkRangedItems", handleCheckRangedItems);
    });
    this._create();
    this.setData(data);
  }
  /**
   * Create DOM elements for the group
   * @private
   */
  _create() {
    const label = document.createElement("div");
    if (this.itemSet.options.groupEditable.order) {
      label.className = "vis-label draggable";
    } else {
      label.className = "vis-label";
    }
    this.dom.label = label;
    const inner = document.createElement("div");
    inner.className = "vis-inner";
    label.appendChild(inner);
    this.dom.inner = inner;
    const foreground = document.createElement("div");
    foreground.className = "vis-group";
    foreground["vis-group"] = this;
    this.dom.foreground = foreground;
    this.dom.background = document.createElement("div");
    this.dom.background.className = "vis-group";
    this.dom.axis = document.createElement("div");
    this.dom.axis.className = "vis-group";
    this.dom.marker = document.createElement("div");
    this.dom.marker.style.visibility = "hidden";
    this.dom.marker.style.position = "absolute";
    this.dom.marker.innerHTML = "";
    this.dom.background.appendChild(this.dom.marker);
  }
  /**
   * Set the group data for this group
   * @param {Object} data   Group data, can contain properties content and className
   */
  setData(data) {
    if (this.itemSet.groupTouchParams.isDragging) return;
    let content;
    let templateFunction;
    if (data && data.subgroupVisibility) {
      for (const key in data.subgroupVisibility) {
        if (!Object.prototype.hasOwnProperty.call(data.subgroupVisibility, key)) continue;
        this.subgroupVisibility[key] = data.subgroupVisibility[key];
      }
    }
    if (this.itemSet.options && this.itemSet.options.groupTemplate) {
      var _context;
      templateFunction = _bindInstanceProperty(_context = this.itemSet.options.groupTemplate).call(_context, this);
      content = templateFunction(data, this.dom.inner);
    } else {
      content = data && data.content;
    }
    if (content instanceof Element) {
      while (this.dom.inner.firstChild) {
        this.dom.inner.removeChild(this.dom.inner.firstChild);
      }
      this.dom.inner.appendChild(content);
    } else if (content instanceof Object && content.isReactComponent) ;
    else if (content instanceof Object) {
      templateFunction(data, this.dom.inner);
    } else if (content !== void 0 && content !== null) {
      this.dom.inner.innerHTML = availableUtils.xss(content);
    } else {
      this.dom.inner.innerHTML = availableUtils.xss(this.groupId || "");
    }
    this.dom.label.title = data && data.title || "";
    if (!this.dom.inner.firstChild) {
      availableUtils.addClassName(this.dom.inner, "vis-hidden");
    } else {
      availableUtils.removeClassName(this.dom.inner, "vis-hidden");
    }
    if (data && data.nestedGroups) {
      if (!this.nestedGroups || this.nestedGroups != data.nestedGroups) {
        this.nestedGroups = data.nestedGroups;
      }
      if (data.showNested !== void 0 || this.showNested === void 0) {
        if (data.showNested == false) {
          this.showNested = false;
        } else {
          this.showNested = true;
        }
      }
      availableUtils.addClassName(this.dom.label, "vis-nesting-group");
      if (this.showNested) {
        availableUtils.removeClassName(this.dom.label, "collapsed");
        availableUtils.addClassName(this.dom.label, "expanded");
      } else {
        availableUtils.removeClassName(this.dom.label, "expanded");
        availableUtils.addClassName(this.dom.label, "collapsed");
      }
    } else if (this.nestedGroups) {
      this.nestedGroups = null;
      availableUtils.removeClassName(this.dom.label, "collapsed");
      availableUtils.removeClassName(this.dom.label, "expanded");
      availableUtils.removeClassName(this.dom.label, "vis-nesting-group");
    }
    if (data && (data.treeLevel || data.nestedInGroup)) {
      availableUtils.addClassName(this.dom.label, "vis-nested-group");
      if (data.treeLevel) {
        availableUtils.addClassName(this.dom.label, "vis-group-level-" + data.treeLevel);
      } else {
        availableUtils.addClassName(this.dom.label, "vis-group-level-unknown-but-gte1");
      }
    } else {
      availableUtils.addClassName(this.dom.label, "vis-group-level-0");
    }
    const className = data && data.className || null;
    if (className != this.className) {
      if (this.className) {
        availableUtils.removeClassName(this.dom.label, this.className);
        availableUtils.removeClassName(this.dom.foreground, this.className);
        availableUtils.removeClassName(this.dom.background, this.className);
        availableUtils.removeClassName(this.dom.axis, this.className);
      }
      availableUtils.addClassName(this.dom.label, className);
      availableUtils.addClassName(this.dom.foreground, className);
      availableUtils.addClassName(this.dom.background, className);
      availableUtils.addClassName(this.dom.axis, className);
      this.className = className;
    }
    if (this.style) {
      availableUtils.removeCssText(this.dom.label, this.style);
      this.style = null;
    }
    if (data && data.style) {
      availableUtils.addCssText(this.dom.label, data.style);
      this.style = data.style;
    }
  }
  /**
   * Get the width of the group label
   * @return {number} width
   */
  getLabelWidth() {
    return this.props.label.width;
  }
  /**
   * check if group has had an initial height hange
   * @returns {boolean}
   */
  _didMarkerHeightChange() {
    const markerHeight = this.dom.marker.clientHeight;
    if (markerHeight != this.lastMarkerHeight) {
      this.lastMarkerHeight = markerHeight;
      const redrawQueue = {};
      let redrawQueueLength = 0;
      _forEachInstanceProperty(availableUtils).call(availableUtils, this.items, (item, key) => {
        item.dirty = true;
        if (item.displayed) {
          const returnQueue = true;
          redrawQueue[key] = item.redraw(returnQueue);
          redrawQueueLength = redrawQueue[key].length;
        }
      });
      const needRedraw = redrawQueueLength > 0;
      if (needRedraw) {
        for (let i = 0; i < redrawQueueLength; i++) {
          _forEachInstanceProperty(availableUtils).call(availableUtils, redrawQueue, (fns) => {
            fns[i]();
          });
        }
      }
      return true;
    } else {
      return false;
    }
  }
  /**
   * calculate group dimentions and position
   * @param {number} pixels
   */
  _calculateGroupSizeAndPosition() {
    const {
      offsetTop,
      offsetLeft,
      offsetWidth
    } = this.dom.foreground;
    this.top = offsetTop;
    this.right = offsetLeft;
    this.width = offsetWidth;
  }
  /**
   * checks if should bail redraw of items
   * @returns {boolean} should bail
   */
  _shouldBailItemsRedraw() {
    const me = this;
    const timeoutOptions = this.itemSet.options.onTimeout;
    const bailOptions = {
      relativeBailingTime: this.itemSet.itemsSettingTime,
      bailTimeMs: timeoutOptions && timeoutOptions.timeoutMs,
      userBailFunction: timeoutOptions && timeoutOptions.callback,
      shouldBailStackItems: this.shouldBailStackItems
    };
    let bail = null;
    if (!this.itemSet.initialDrawDone) {
      if (bailOptions.shouldBailStackItems) {
        return true;
      }
      if (Math.abs(_Date$now() - new Date(bailOptions.relativeBailingTime)) > bailOptions.bailTimeMs) {
        if (bailOptions.userBailFunction && this.itemSet.userContinueNotBail == null) {
          bailOptions.userBailFunction((didUserContinue) => {
            me.itemSet.userContinueNotBail = didUserContinue;
            bail = !didUserContinue;
          });
        } else if (me.itemSet.userContinueNotBail == false) {
          bail = true;
        } else {
          bail = false;
        }
      }
    }
    return bail;
  }
  /**
   * redraws items
   * @param {boolean} forceRestack
   * @param {boolean} lastIsVisible
   * @param {number} margin
   * @param {object} range
   * @private
   */
  _redrawItems(forceRestack, lastIsVisible, margin, range) {
    const restack = forceRestack || this.stackDirty || this.isVisible && !lastIsVisible;
    if (restack) {
      var _context2, _context3, _context4, _context5, _context6, _context7;
      const orderedItems = {
        byEnd: _filterInstanceProperty(_context2 = this.orderedItems.byEnd).call(_context2, (item) => !item.isCluster),
        byStart: _filterInstanceProperty(_context3 = this.orderedItems.byStart).call(_context3, (item) => !item.isCluster)
      };
      const orderedClusters = {
        byEnd: [...new _Set(_filterInstanceProperty(_context4 = _mapInstanceProperty(_context5 = this.orderedItems.byEnd).call(_context5, (item) => item.cluster)).call(_context4, (item) => !!item))],
        byStart: [...new _Set(_filterInstanceProperty(_context6 = _mapInstanceProperty(_context7 = this.orderedItems.byStart).call(_context7, (item) => item.cluster)).call(_context6, (item) => !!item))]
      };
      const getVisibleItems = () => {
        var _context8, _context9;
        const visibleItems = this._updateItemsInRange(orderedItems, _filterInstanceProperty(_context8 = this.visibleItems).call(_context8, (item) => !item.isCluster), range);
        const visibleClusters = this._updateClustersInRange(orderedClusters, _filterInstanceProperty(_context9 = this.visibleItems).call(_context9, (item) => item.isCluster), range);
        return [...visibleItems, ...visibleClusters];
      };
      const getVisibleItemsGroupedBySubgroup = (orderFn) => {
        let visibleSubgroupsItems = {};
        for (const subgroup in this.subgroups) {
          var _context0;
          if (!Object.prototype.hasOwnProperty.call(this.subgroups, subgroup)) continue;
          const items = _filterInstanceProperty(_context0 = this.visibleItems).call(_context0, (item) => item.data.subgroup === subgroup);
          visibleSubgroupsItems[subgroup] = orderFn ? _sortInstanceProperty(items).call(items, (a, b) => orderFn(a.data, b.data)) : items;
        }
        return visibleSubgroupsItems;
      };
      if (typeof this.itemSet.options.order === "function") {
        const me = this;
        if (this.doInnerStack && this.itemSet.options.stackSubgroups) {
          const visibleSubgroupsItems = getVisibleItemsGroupedBySubgroup(this.itemSet.options.order);
          stackSubgroupsWithInnerStack(visibleSubgroupsItems, margin, this.subgroups);
          this.visibleItems = getVisibleItems();
          this._updateSubGroupHeights(margin);
        } else {
          var _context1, _context10, _context11, _context12;
          this.visibleItems = getVisibleItems();
          this._updateSubGroupHeights(margin);
          const customOrderedItems = _sortInstanceProperty(_context1 = _filterInstanceProperty(_context10 = _sliceInstanceProperty(_context11 = this.visibleItems).call(_context11)).call(_context10, (item) => item.isCluster || !item.isCluster && !item.cluster)).call(_context1, (a, b) => {
            return me.itemSet.options.order(a.data, b.data);
          });
          this.shouldBailStackItems = stack(customOrderedItems, margin, true, _bindInstanceProperty(_context12 = this._shouldBailItemsRedraw).call(_context12, this));
        }
      } else {
        this.visibleItems = getVisibleItems();
        this._updateSubGroupHeights(margin);
        if (this.itemSet.options.stack) {
          if (this.doInnerStack && this.itemSet.options.stackSubgroups) {
            const visibleSubgroupsItems = getVisibleItemsGroupedBySubgroup();
            stackSubgroupsWithInnerStack(visibleSubgroupsItems, margin, this.subgroups);
          } else {
            var _context13;
            this.shouldBailStackItems = stack(this.visibleItems, margin, true, _bindInstanceProperty(_context13 = this._shouldBailItemsRedraw).call(_context13, this));
          }
        } else {
          nostack(this.visibleItems, margin, this.subgroups, this.itemSet.options.stackSubgroups);
        }
      }
      for (let i = 0; i < this.visibleItems.length; i++) {
        this.visibleItems[i].repositionX();
        if (this.subgroupVisibility[this.visibleItems[i].data.subgroup] !== void 0) {
          if (!this.subgroupVisibility[this.visibleItems[i].data.subgroup]) {
            this.visibleItems[i].hide();
          }
        }
      }
      if (this.itemSet.options.cluster) {
        _forEachInstanceProperty(availableUtils).call(availableUtils, this.items, (item) => {
          if (item.cluster && item.displayed) {
            item.hide();
          }
        });
      }
      if (this.shouldBailStackItems) {
        this.itemSet.body.emitter.emit("destroyTimeline");
      }
      this.stackDirty = false;
    }
  }
  /**
   * check if group resized
   * @param {boolean} resized
   * @param {number} height
   * @return {boolean} did resize
   */
  _didResize(resized, height) {
    resized = availableUtils.updateProperty(this, "height", height) || resized;
    const labelWidth = this.dom.inner.clientWidth;
    const labelHeight = this.dom.inner.clientHeight;
    resized = availableUtils.updateProperty(this.props.label, "width", labelWidth) || resized;
    resized = availableUtils.updateProperty(this.props.label, "height", labelHeight) || resized;
    return resized;
  }
  /**
   * apply group height
   * @param {number} height
   */
  _applyGroupHeight(height) {
    this.dom.background.style.height = "".concat(height, "px");
    this.dom.foreground.style.height = "".concat(height, "px");
    this.dom.label.style.height = "".concat(height, "px");
  }
  /**
   * update vertical position of items after they are re-stacked and the height of the group is calculated
   * @param {number} margin
   */
  _updateItemsVerticalPosition(margin) {
    for (let i = 0, ii = this.visibleItems.length; i < ii; i++) {
      const item = this.visibleItems[i];
      item.repositionY(margin);
      if (!this.isVisible && this.groupId != ReservedGroupIds$1.BACKGROUND) {
        if (item.displayed) item.hide();
      }
    }
  }
  /**
   * Repaint this group
   * @param {{start: number, end: number}} range
   * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
   * @param {boolean} [forceRestack=false]  Force restacking of all items
   * @param {boolean} [returnQueue=false]  return the queue or if the group resized
   * @return {boolean} Returns true if the group is resized or the redraw queue if returnQueue=true
   */
  redraw(range, margin, forceRestack, returnQueue) {
    var _context14, _context15, _context18, _context20, _context24;
    let resized = false;
    const lastIsVisible = this.isVisible;
    let height;
    const queue = [
      () => {
        forceRestack = this._didMarkerHeightChange.call(this) || forceRestack;
      },
      // recalculate the height of the subgroups
      _bindInstanceProperty(_context14 = this._updateSubGroupHeights).call(_context14, this, margin),
      // calculate actual size and position
      _bindInstanceProperty(_context15 = this._calculateGroupSizeAndPosition).call(_context15, this),
      () => {
        var _context16;
        this.isVisible = _bindInstanceProperty(_context16 = this._isGroupVisible).call(_context16, this)(range, margin);
      },
      () => {
        var _context17;
        _bindInstanceProperty(_context17 = this._redrawItems).call(_context17, this)(forceRestack, lastIsVisible, margin, range);
      },
      // update subgroups
      _bindInstanceProperty(_context18 = this._updateSubgroupsSizes).call(_context18, this),
      () => {
        var _context19;
        height = this.height = _bindInstanceProperty(_context19 = this._calculateHeight).call(_context19, this)(margin);
      },
      // calculate actual size and position again
      _bindInstanceProperty(_context20 = this._calculateGroupSizeAndPosition).call(_context20, this),
      () => {
        var _context21;
        resized = _bindInstanceProperty(_context21 = this._didResize).call(_context21, this)(resized, height);
      },
      () => {
        var _context22;
        _bindInstanceProperty(_context22 = this._applyGroupHeight).call(_context22, this)(height);
      },
      () => {
        var _context23;
        _bindInstanceProperty(_context23 = this._updateItemsVerticalPosition).call(_context23, this)(margin);
      },
      _bindInstanceProperty(_context24 = () => {
        if (!this.isVisible && this.height) {
          resized = false;
        }
        return resized;
      }).call(_context24, this)
    ];
    if (returnQueue) {
      return queue;
    } else {
      let result;
      _forEachInstanceProperty(queue).call(queue, (fn) => {
        result = fn();
      });
      return result;
    }
  }
  /**
   * recalculate the height of the subgroups
   *
   * @param {{item: timeline.Item}} margin
   * @private
   */
  _updateSubGroupHeights(margin) {
    if (_Object$keys(this.subgroups).length > 0) {
      const me = this;
      this._resetSubgroups();
      _forEachInstanceProperty(availableUtils).call(availableUtils, this.visibleItems, (item) => {
        if (item.data.subgroup !== void 0) {
          me.subgroups[item.data.subgroup].height = Math.max(me.subgroups[item.data.subgroup].height, item.height + margin.item.vertical);
          me.subgroups[item.data.subgroup].visible = typeof this.subgroupVisibility[item.data.subgroup] === "undefined" ? true : Boolean(this.subgroupVisibility[item.data.subgroup]);
        }
      });
    }
  }
  /**
   * check if group is visible
   *
   * @param {timeline.Range} range
   * @param {{axis: timeline.DataAxis}} margin
   * @returns {boolean} is visible
   * @private
   */
  _isGroupVisible(range, margin) {
    return this.top <= range.body.domProps.centerContainer.height - range.body.domProps.scrollTop + margin.axis && this.top + this.height + margin.axis >= -range.body.domProps.scrollTop;
  }
  /**
   * recalculate the height of the group
   * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
   * @returns {number} Returns the height
   * @private
   */
  _calculateHeight(margin) {
    let height;
    let items;
    if (this.heightMode === "fixed") {
      items = availableUtils.toArray(this.items);
    } else {
      items = this.visibleItems;
    }
    if (!this.isVisible && this.height) {
      height = Math.max(this.height, this.props.label.height);
    } else if (items.length > 0) {
      let min = items[0].top;
      let max = items[0].top + items[0].height;
      _forEachInstanceProperty(availableUtils).call(availableUtils, items, (item) => {
        min = Math.min(min, item.top);
        max = Math.max(max, item.top + item.height);
      });
      if (min > margin.axis) {
        const offset = min - margin.axis;
        max -= offset;
        _forEachInstanceProperty(availableUtils).call(availableUtils, items, (item) => {
          item.top -= offset;
        });
      }
      height = Math.ceil(max + margin.item.vertical / 2);
      if (this.heightMode !== "fitItems") {
        height = Math.max(height, this.props.label.height);
      }
    } else {
      height = this.props.label.height;
    }
    return height;
  }
  /**
   * Show this group: attach to the DOM
   */
  show() {
    if (!this.dom.label.parentNode) {
      this.itemSet.dom.labelSet.appendChild(this.dom.label);
    }
    if (!this.dom.foreground.parentNode) {
      this.itemSet.dom.foreground.appendChild(this.dom.foreground);
    }
    if (!this.dom.background.parentNode) {
      this.itemSet.dom.background.appendChild(this.dom.background);
    }
    if (!this.dom.axis.parentNode) {
      this.itemSet.dom.axis.appendChild(this.dom.axis);
    }
  }
  /**
   * Hide this group: remove from the DOM
   */
  hide() {
    const label = this.dom.label;
    if (label.parentNode) {
      label.parentNode.removeChild(label);
    }
    const foreground = this.dom.foreground;
    if (foreground.parentNode) {
      foreground.parentNode.removeChild(foreground);
    }
    const background = this.dom.background;
    if (background.parentNode) {
      background.parentNode.removeChild(background);
    }
    const axis = this.dom.axis;
    if (axis.parentNode) {
      axis.parentNode.removeChild(axis);
    }
  }
  /**
   * Add an item to the group
   * @param {Item} item
   */
  add(item) {
    var _context25;
    this.items[item.id] = item;
    item.setParent(this);
    this.stackDirty = true;
    if (item.data.subgroup !== void 0) {
      this._addToSubgroup(item);
      this.orderSubgroups();
    }
    if (!_includesInstanceProperty(_context25 = this.visibleItems).call(_context25, item)) {
      const range = this.itemSet.body.range;
      this._checkIfVisible(item, this.visibleItems, range);
    }
  }
  /**
   * add item to subgroup
   * @param {object} item
   * @param {string} subgroupId
   */
  _addToSubgroup(item) {
    let subgroupId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : item.data.subgroup;
    if (subgroupId != void 0 && this.subgroups[subgroupId] === void 0) {
      this.subgroups[subgroupId] = {
        height: 0,
        top: 0,
        start: item.data.start,
        end: item.data.end || item.data.start,
        visible: false,
        index: this.subgroupIndex,
        items: [],
        stack: this.subgroupStackAll || this.subgroupStack[subgroupId] || false
      };
      this.subgroupIndex++;
    }
    if (new Date(item.data.start) < new Date(this.subgroups[subgroupId].start)) {
      this.subgroups[subgroupId].start = item.data.start;
    }
    const itemEnd = item.data.end || item.data.start;
    if (new Date(itemEnd) > new Date(this.subgroups[subgroupId].end)) {
      this.subgroups[subgroupId].end = itemEnd;
    }
    this.subgroups[subgroupId].items.push(item);
  }
  /**
   * update subgroup sizes
   */
  _updateSubgroupsSizes() {
    const me = this;
    if (me.subgroups) {
      for (const subgroup in me.subgroups) {
        var _context26;
        if (!Object.prototype.hasOwnProperty.call(me.subgroups, subgroup)) continue;
        const initialEnd = me.subgroups[subgroup].items[0].data.end || me.subgroups[subgroup].items[0].data.start;
        let newStart = me.subgroups[subgroup].items[0].data.start;
        let newEnd = initialEnd - 1;
        _forEachInstanceProperty(_context26 = me.subgroups[subgroup].items).call(_context26, (item) => {
          if (new Date(item.data.start) < new Date(newStart)) {
            newStart = item.data.start;
          }
          const itemEnd = item.data.end || item.data.start;
          if (new Date(itemEnd) > new Date(newEnd)) {
            newEnd = itemEnd;
          }
        });
        me.subgroups[subgroup].start = newStart;
        me.subgroups[subgroup].end = new Date(newEnd - 1);
      }
    }
  }
  /**
   * order subgroups
   */
  orderSubgroups() {
    if (this.subgroupOrderer !== void 0) {
      const sortArray = [];
      if (typeof this.subgroupOrderer == "string") {
        for (const subgroup in this.subgroups) {
          if (!Object.prototype.hasOwnProperty.call(this.subgroups, subgroup)) continue;
          sortArray.push({
            subgroup,
            sortField: this.subgroups[subgroup].items[0].data[this.subgroupOrderer]
          });
        }
        _sortInstanceProperty(sortArray).call(sortArray, (a, b) => a.sortField - b.sortField);
      } else if (typeof this.subgroupOrderer == "function") {
        for (const subgroup in this.subgroups) {
          if (!Object.prototype.hasOwnProperty.call(this.subgroups, subgroup)) continue;
          sortArray.push(this.subgroups[subgroup].items[0].data);
        }
        _sortInstanceProperty(sortArray).call(sortArray, this.subgroupOrderer);
      }
      if (sortArray.length > 0) {
        for (let i = 0; i < sortArray.length; i++) {
          this.subgroups[sortArray[i].subgroup].index = i;
        }
      }
    }
  }
  /**
   * add item to subgroup
   */
  _resetSubgroups() {
    for (const subgroup in this.subgroups) {
      if (!Object.prototype.hasOwnProperty.call(this.subgroups, subgroup)) continue;
      this.subgroups[subgroup].visible = false;
      this.subgroups[subgroup].height = 0;
    }
  }
  /**
   * Remove an item from the group
   * @param {Item} item
   */
  remove(item) {
    var _context27, _context28;
    delete this.items[item.id];
    item.setParent(null);
    this.stackDirty = true;
    const index = _indexOfInstanceProperty(_context27 = this.visibleItems).call(_context27, item);
    if (index != -1) _spliceInstanceProperty(_context28 = this.visibleItems).call(_context28, index, 1);
    if (item.data.subgroup !== void 0) {
      this._removeFromSubgroup(item);
      this.orderSubgroups();
    }
  }
  /**
   * remove item from subgroup
   * @param {object} item
   * @param {string} subgroupId
   */
  _removeFromSubgroup(item) {
    let subgroupId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : item.data.subgroup;
    if (subgroupId != void 0) {
      const subgroup = this.subgroups[subgroupId];
      if (subgroup) {
        var _context29;
        const itemIndex = _indexOfInstanceProperty(_context29 = subgroup.items).call(_context29, item);
        if (itemIndex >= 0) {
          var _context30;
          _spliceInstanceProperty(_context30 = subgroup.items).call(_context30, itemIndex, 1);
          if (!subgroup.items.length) {
            delete this.subgroups[subgroupId];
          } else {
            this._updateSubgroupsSizes();
          }
        }
      }
    }
  }
  /**
   * Remove an item from the corresponding DataSet
   * @param {Item} item
   */
  removeFromDataSet(item) {
    this.itemSet.removeItem(item.id);
  }
  /**
   * Reorder the items
   */
  order() {
    const array2 = availableUtils.toArray(this.items);
    const startArray = [];
    const endArray = [];
    for (let i = 0; i < array2.length; i++) {
      if (array2[i].data.end !== void 0) {
        endArray.push(array2[i]);
      }
      startArray.push(array2[i]);
    }
    this.orderedItems = {
      byStart: startArray,
      byEnd: endArray
    };
    orderByStart(this.orderedItems.byStart);
    orderByEnd(this.orderedItems.byEnd);
  }
  /**
   * Update the visible items
   * @param {{byStart: Item[], byEnd: Item[]}} orderedItems   All items ordered by start date and by end date
   * @param {Item[]} oldVisibleItems                          The previously visible items.
   * @param {{start: number, end: number}} range              Visible range
   * @return {Item[]} visibleItems                            The new visible items.
   * @private
   */
  _updateItemsInRange(orderedItems, oldVisibleItems, range) {
    const visibleItems = [];
    const visibleItemsLookup = {};
    if (!this.isVisible && this.height !== void 0 && this.groupId != ReservedGroupIds$1.BACKGROUND) {
      for (let i = 0; i < oldVisibleItems.length; i++) {
        var item = oldVisibleItems[i];
        if (item.displayed) item.hide();
      }
      return visibleItems;
    }
    const interval = (range.end - range.start) / 4;
    const lowerBound = range.start - interval;
    const upperBound = range.end + interval;
    const startSearchFunction = (value) => {
      if (value < lowerBound) {
        return -1;
      } else if (value <= upperBound) {
        return 0;
      } else {
        return 1;
      }
    };
    const endSearchFunction = (data) => {
      const {
        start,
        end
      } = data;
      if (end < lowerBound) {
        return -1;
      } else if (start <= upperBound) {
        return 0;
      } else {
        return 1;
      }
    };
    if (oldVisibleItems.length > 0) {
      for (let i = 0; i < oldVisibleItems.length; i++) {
        this._checkIfVisibleWithReference(oldVisibleItems[i], visibleItems, visibleItemsLookup, range);
      }
    }
    const initialPosByStart = availableUtils.binarySearchCustom(orderedItems.byStart, startSearchFunction, "data", "start");
    this._traceVisible(initialPosByStart, orderedItems.byStart, visibleItems, visibleItemsLookup, (item2) => item2.data.start < lowerBound || item2.data.start > upperBound);
    if (this.checkRangedItems == true) {
      this.checkRangedItems = false;
      for (let i = 0; i < orderedItems.byEnd.length; i++) {
        this._checkIfVisibleWithReference(orderedItems.byEnd[i], visibleItems, visibleItemsLookup, range);
      }
    } else {
      const initialPosByEnd = availableUtils.binarySearchCustom(orderedItems.byEnd, endSearchFunction, "data");
      this._traceVisible(initialPosByEnd, orderedItems.byEnd, visibleItems, visibleItemsLookup, (item2) => item2.data.end < lowerBound || item2.data.start > upperBound);
    }
    this._sortVisibleItems(orderedItems.byStart, visibleItems, visibleItemsLookup);
    const redrawQueue = {};
    let redrawQueueLength = 0;
    for (let i = 0; i < visibleItems.length; i++) {
      const item2 = visibleItems[i];
      if (!item2.displayed) {
        const returnQueue = true;
        redrawQueue[i] = item2.redraw(returnQueue);
        redrawQueueLength = redrawQueue[i].length;
      }
    }
    const needRedraw = redrawQueueLength > 0;
    if (needRedraw) {
      for (let j = 0; j < redrawQueueLength; j++) {
        _forEachInstanceProperty(availableUtils).call(availableUtils, redrawQueue, (fns) => {
          fns[j]();
        });
      }
    }
    for (let i = 0; i < visibleItems.length; i++) {
      visibleItems[i].repositionX();
    }
    return visibleItems;
  }
  /**
   * trace visible items in group
   * @param {number} initialPos
   * @param {array} items
   * @param {aray} visibleItems
   * @param {object} visibleItemsLookup
   * @param {function} breakCondition
   */
  _traceVisible(initialPos, items, visibleItems, visibleItemsLookup, breakCondition) {
    if (initialPos != -1) {
      for (let i = initialPos; i >= 0; i--) {
        let item = items[i];
        if (breakCondition(item)) {
          break;
        } else {
          if (!(item.isCluster && !item.hasItems()) && !item.cluster) {
            if (visibleItemsLookup[item.id] === void 0) {
              visibleItemsLookup[item.id] = true;
              visibleItems.unshift(item);
            }
          }
        }
      }
      for (let i = initialPos + 1; i < items.length; i++) {
        let item = items[i];
        if (breakCondition(item)) {
          break;
        } else {
          if (!(item.isCluster && !item.hasItems()) && !item.cluster) {
            if (visibleItemsLookup[item.id] === void 0) {
              visibleItemsLookup[item.id] = true;
              visibleItems.push(item);
            }
          }
        }
      }
    }
  }
  /**
   * by-ref reordering of visibleItems array to match
   * the specified item superset order
   * @param {array} orderedItems
   * @param {aray} visibleItems
   * @param {object} visibleItemsLookup
   */
  _sortVisibleItems(orderedItems, visibleItems, visibleItemsLookup) {
    visibleItems.length = 0;
    for (let i = 0; i < orderedItems.length; i++) {
      let item = orderedItems[i];
      if (visibleItemsLookup[item.id]) {
        visibleItems.push(item);
      }
    }
  }
  /**
   * this function is very similar to the _checkIfInvisible() but it does not
   * return booleans, hides the item if it should not be seen and always adds to
   * the visibleItems.
   * this one is for brute forcing and hiding.
   *
   * @param {Item} item
   * @param {Array} visibleItems
   * @param {{start:number, end:number}} range
   * @private
   */
  _checkIfVisible(item, visibleItems, range) {
    if (item.isVisible(range)) {
      if (!item.displayed) item.show();
      item.repositionX();
      visibleItems.push(item);
    } else {
      if (item.displayed) item.hide();
    }
  }
  /**
   * this function is very similar to the _checkIfInvisible() but it does not
   * return booleans, hides the item if it should not be seen and always adds to
   * the visibleItems.
   * this one is for brute forcing and hiding.
   *
   * @param {Item} item
   * @param {Array.<timeline.Item>} visibleItems
   * @param {Object<number, boolean>} visibleItemsLookup
   * @param {{start:number, end:number}} range
   * @private
   */
  _checkIfVisibleWithReference(item, visibleItems, visibleItemsLookup, range) {
    if (item.isVisible(range)) {
      if (visibleItemsLookup[item.id] === void 0) {
        visibleItemsLookup[item.id] = true;
        visibleItems.push(item);
      }
    } else {
      if (item.displayed) item.hide();
    }
  }
  /**
   * Update the visible items
   * @param {array} orderedClusters
   * @param {array} oldVisibleClusters
   * @param {{start: number, end: number}} range
   * @return {Item[]} visibleItems
   * @private
   */
  _updateClustersInRange(orderedClusters, oldVisibleClusters, range) {
    const visibleClusters = [];
    const visibleClustersLookup = {};
    if (oldVisibleClusters.length > 0) {
      for (let i = 0; i < oldVisibleClusters.length; i++) {
        this._checkIfVisibleWithReference(oldVisibleClusters[i], visibleClusters, visibleClustersLookup, range);
      }
    }
    for (let i = 0; i < orderedClusters.byStart.length; i++) {
      this._checkIfVisibleWithReference(orderedClusters.byStart[i], visibleClusters, visibleClustersLookup, range);
    }
    for (let i = 0; i < orderedClusters.byEnd.length; i++) {
      this._checkIfVisibleWithReference(orderedClusters.byEnd[i], visibleClusters, visibleClustersLookup, range);
    }
    const redrawQueue = {};
    let redrawQueueLength = 0;
    for (let i = 0; i < visibleClusters.length; i++) {
      const item = visibleClusters[i];
      if (!item.displayed) {
        const returnQueue = true;
        redrawQueue[i] = item.redraw(returnQueue);
        redrawQueueLength = redrawQueue[i].length;
      }
    }
    const needRedraw = redrawQueueLength > 0;
    if (needRedraw) {
      for (var j = 0; j < redrawQueueLength; j++) {
        _forEachInstanceProperty(availableUtils).call(availableUtils, redrawQueue, function(fns) {
          fns[j]();
        });
      }
    }
    for (let i = 0; i < visibleClusters.length; i++) {
      visibleClusters[i].repositionX();
    }
    return visibleClusters;
  }
  /**
   * change item subgroup
   * @param {object} item
   * @param {string} oldSubgroup
   * @param {string} newSubgroup
   */
  changeSubgroup(item, oldSubgroup, newSubgroup) {
    this._removeFromSubgroup(item, oldSubgroup);
    this._addToSubgroup(item, newSubgroup);
    this.orderSubgroups();
  }
  /**
   * Call this method before you lose the last reference to an instance of this.
   * It will remove listeners etc.
   */
  dispose() {
    this.hide();
    let disposeCallback;
    while (disposeCallback = this._disposeCallbacks.pop()) {
      disposeCallback();
    }
  }
};
var BackgroundGroup = class extends Group {
  /**
   * @param {number | string} groupId
   * @param {Object} data
   * @param {ItemSet} itemSet
   */
  constructor(groupId, data, itemSet) {
    super(groupId, data, itemSet);
    this.width = 0;
    this.height = 0;
    this.top = 0;
    this.left = 0;
  }
  /**
   * Repaint this group
   * @param {{start: number, end: number}} range
   * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
   * @return {boolean} Returns true if the group is resized
   */
  redraw(range, margin) {
    const resized = false;
    this.visibleItems = this._updateItemsInRange(this.orderedItems, this.visibleItems, range);
    this.width = this.dom.background.offsetWidth;
    this.dom.background.style.height = "0";
    for (let i = 0, ii = this.visibleItems.length; i < ii; i++) {
      const item = this.visibleItems[i];
      item.repositionY(margin);
    }
    return resized;
  }
  /**
   * Show this group: attach to the DOM
   */
  show() {
    if (!this.dom.background.parentNode) {
      this.itemSet.dom.background.appendChild(this.dom.background);
    }
  }
};
var Item = class {
  /**
   * @constructor Item
   * @param {Object} data             Object containing (optional) parameters type,
   *                                  start, end, content, group, className.
   * @param {{toScreen: function, toTime: function}} conversion
   *                                  Conversion functions from time to screen and vice versa
   * @param {Object} options          Configuration options
   *                                  // TODO: describe available options
   */
  constructor(data, conversion, options) {
    var _context;
    this.id = null;
    this.parent = null;
    this.data = data;
    this.dom = null;
    this.conversion = conversion || {};
    this.defaultOptions = {
      locales,
      locale: "en"
    };
    this.options = availableUtils.extend({}, this.defaultOptions, options);
    this.options.locales = availableUtils.extend({}, locales, this.options.locales);
    const defaultLocales = this.defaultOptions.locales[this.defaultOptions.locale];
    _forEachInstanceProperty(_context = _Object$keys(this.options.locales)).call(_context, (locale) => {
      this.options.locales[locale] = availableUtils.extend({}, defaultLocales, this.options.locales[locale]);
    });
    this.selected = false;
    this.displayed = false;
    this.groupShowing = true;
    this.selectable = options && options.selectable || false;
    this.dirty = true;
    this.top = null;
    this.right = null;
    this.left = null;
    this.width = null;
    this.height = null;
    this.setSelectability(data);
    this.editable = null;
    this._updateEditStatus();
  }
  /**
   * Select current item
   */
  select() {
    if (this.selectable) {
      this.selected = true;
      this.dirty = true;
      if (this.displayed) this.redraw();
    }
  }
  /**
   * Unselect current item
   */
  unselect() {
    this.selected = false;
    this.dirty = true;
    if (this.displayed) this.redraw();
  }
  /**
   * Set data for the item. Existing data will be updated. The id should not
   * be changed. When the item is displayed, it will be redrawn immediately.
   * @param {Object} data
   */
  setData(data) {
    const groupChanged = data.group != void 0 && this.data.group != data.group;
    if (groupChanged && this.parent != null) {
      this.parent.itemSet._moveToGroup(this, data.group);
    }
    this.setSelectability(data);
    if (this.parent) {
      this.parent.stackDirty = true;
    }
    const subGroupChanged = data.subgroup != void 0 && this.data.subgroup != data.subgroup;
    if (subGroupChanged && this.parent != null) {
      this.parent.changeSubgroup(this, this.data.subgroup, data.subgroup);
    }
    this.data = data;
    this._updateEditStatus();
    this.dirty = true;
    if (this.displayed) this.redraw();
  }
  /**
   * Set whether the item can be selected.
   * Can only be set/unset if the timeline's `selectable` configuration option is `true`.
   * @param {Object} data `data` from `constructor` and `setData`
   */
  setSelectability(data) {
    if (data) {
      this.selectable = typeof data.selectable === "undefined" ? true : Boolean(data.selectable);
    }
  }
  /**
   * Set a parent for the item
   * @param {Group} parent
   */
  setParent(parent) {
    if (this.displayed) {
      this.hide();
      this.parent = parent;
      if (this.parent) {
        this.show();
      }
    } else {
      this.parent = parent;
    }
  }
  /**
   * Check whether this item is visible inside given range
   * @returns {boolean} True if visible
   */
  isVisible() {
    return false;
  }
  /**
   * Show the Item in the DOM (when not already visible)
   * @return {Boolean} changed
   */
  show() {
    return false;
  }
  /**
   * Hide the Item from the DOM (when visible)
   * @return {Boolean} changed
   */
  hide() {
    return false;
  }
  /**
   * Repaint the item
   */
  redraw() {
  }
  /**
   * Reposition the Item horizontally
   */
  repositionX() {
  }
  /**
   * Reposition the Item vertically
   */
  repositionY() {
  }
  /**
   * Repaint a drag area on the center of the item when the item is selected
   * @protected
   */
  _repaintDragCenter() {
    if (this.selected && this.editable.updateTime && !this.dom.dragCenter) {
      var _context2, _context3;
      const me = this;
      const dragCenter = document.createElement("div");
      dragCenter.className = "vis-drag-center";
      dragCenter.dragCenterItem = this;
      this.hammerDragCenter = new Hammer(dragCenter);
      this.hammerDragCenter.on("tap", (event2) => {
        me.parent.itemSet.body.emitter.emit("click", {
          event: event2,
          item: me.id
        });
      });
      this.hammerDragCenter.on("doubletap", (event2) => {
        event2.stopPropagation();
        me.parent.itemSet._onUpdateItem(me);
        me.parent.itemSet.body.emitter.emit("doubleClick", {
          event: event2,
          item: me.id
        });
      });
      this.hammerDragCenter.on("panstart", (event2) => {
        event2.stopPropagation();
        me.parent.itemSet._onDragStart(event2);
      });
      this.hammerDragCenter.on("panmove", _bindInstanceProperty(_context2 = me.parent.itemSet._onDrag).call(_context2, me.parent.itemSet));
      this.hammerDragCenter.on("panend", _bindInstanceProperty(_context3 = me.parent.itemSet._onDragEnd).call(_context3, me.parent.itemSet));
      this.hammerDragCenter.get("press").set({
        time: 1e4
      });
      if (this.dom.box) {
        if (this.dom.dragLeft) {
          this.dom.box.insertBefore(dragCenter, this.dom.dragLeft);
        } else {
          this.dom.box.appendChild(dragCenter);
        }
      } else if (this.dom.point) {
        this.dom.point.appendChild(dragCenter);
      }
      this.dom.dragCenter = dragCenter;
    } else if (!this.selected && this.dom.dragCenter) {
      if (this.dom.dragCenter.parentNode) {
        this.dom.dragCenter.parentNode.removeChild(this.dom.dragCenter);
      }
      this.dom.dragCenter = null;
      if (this.hammerDragCenter) {
        this.hammerDragCenter.destroy();
        this.hammerDragCenter = null;
      }
    }
  }
  /**
   * Repaint a delete button on the top right of the item when the item is selected
   * @param {HTMLElement} anchor
   * @protected
   */
  _repaintDeleteButton(anchor) {
    const editable = (this.options.editable.overrideItems || this.editable == null) && this.options.editable.remove || !this.options.editable.overrideItems && this.editable != null && this.editable.remove;
    if (this.selected && editable && !this.dom.deleteButton) {
      const me = this;
      const deleteButton = document.createElement("div");
      if (this.options.rtl) {
        deleteButton.className = "vis-delete-rtl";
      } else {
        deleteButton.className = "vis-delete";
      }
      let optionsLocale = this.options.locales[this.options.locale];
      if (!optionsLocale) {
        if (!this.warned) {
          console.warn("WARNING: options.locales['".concat(this.options.locale, "'] not found. See https://visjs.github.io/vis-timeline/docs/timeline/#Localization"));
          this.warned = true;
        }
        optionsLocale = this.options.locales["en"];
      }
      deleteButton.title = optionsLocale.deleteSelected;
      this.hammerDeleteButton = new Hammer(deleteButton).on("tap", (event2) => {
        event2.stopPropagation();
        me.parent.removeFromDataSet(me);
      });
      anchor.appendChild(deleteButton);
      this.dom.deleteButton = deleteButton;
    } else if ((!this.selected || !editable) && this.dom.deleteButton) {
      if (this.dom.deleteButton.parentNode) {
        this.dom.deleteButton.parentNode.removeChild(this.dom.deleteButton);
      }
      this.dom.deleteButton = null;
      if (this.hammerDeleteButton) {
        this.hammerDeleteButton.destroy();
        this.hammerDeleteButton = null;
      }
    }
  }
  /**
   * Repaint a onChange tooltip on the top right of the item when the item is selected
   * @param {HTMLElement} anchor
   * @protected
   */
  _repaintOnItemUpdateTimeTooltip(anchor) {
    if (!this.options.tooltipOnItemUpdateTime) return;
    const editable = (this.options.editable.updateTime || this.data.editable === true) && this.data.editable !== false;
    if (this.selected && editable && !this.dom.onItemUpdateTimeTooltip) {
      const onItemUpdateTimeTooltip = document.createElement("div");
      onItemUpdateTimeTooltip.className = "vis-onUpdateTime-tooltip";
      anchor.appendChild(onItemUpdateTimeTooltip);
      this.dom.onItemUpdateTimeTooltip = onItemUpdateTimeTooltip;
    } else if (!this.selected && this.dom.onItemUpdateTimeTooltip) {
      if (this.dom.onItemUpdateTimeTooltip.parentNode) {
        this.dom.onItemUpdateTimeTooltip.parentNode.removeChild(this.dom.onItemUpdateTimeTooltip);
      }
      this.dom.onItemUpdateTimeTooltip = null;
    }
    if (this.dom.onItemUpdateTimeTooltip) {
      this.dom.onItemUpdateTimeTooltip.style.visibility = this.parent.itemSet.touchParams.itemIsDragging ? "visible" : "hidden";
      this.dom.onItemUpdateTimeTooltip.style.transform = "translateX(-50%)";
      this.dom.onItemUpdateTimeTooltip.style.left = "50%";
      const tooltipOffset = 50;
      const scrollTop = this.parent.itemSet.body.domProps.scrollTop;
      let itemDistanceFromTop;
      if (this.options.orientation.item == "top") {
        itemDistanceFromTop = this.top;
      } else {
        itemDistanceFromTop = this.parent.height - this.top - this.height;
      }
      const isCloseToTop = itemDistanceFromTop + this.parent.top - tooltipOffset < -scrollTop;
      if (isCloseToTop) {
        this.dom.onItemUpdateTimeTooltip.style.bottom = "";
        this.dom.onItemUpdateTimeTooltip.style.top = "".concat(this.height + 2, "px");
      } else {
        this.dom.onItemUpdateTimeTooltip.style.top = "";
        this.dom.onItemUpdateTimeTooltip.style.bottom = "".concat(this.height + 2, "px");
      }
      let content;
      let templateFunction;
      if (this.options.tooltipOnItemUpdateTime && this.options.tooltipOnItemUpdateTime.template) {
        var _context4;
        templateFunction = _bindInstanceProperty(_context4 = this.options.tooltipOnItemUpdateTime.template).call(_context4, this);
        content = templateFunction(this.data);
      } else {
        content = "start: ".concat(moment$2(this.data.start).format("MM/DD/YYYY hh:mm"));
        if (this.data.end) {
          content += "<br> end: ".concat(moment$2(this.data.end).format("MM/DD/YYYY hh:mm"));
        }
      }
      this.dom.onItemUpdateTimeTooltip.innerHTML = availableUtils.xss(content);
    }
  }
  /**
   * get item data
   * @return {object}
   * @private
   */
  _getItemData() {
    return this.parent.itemSet.itemsData.get(this.id);
  }
  /**
   * Set HTML contents for the item
   * @param {Element} element   HTML element to fill with the contents
   * @private
   */
  _updateContents(element) {
    let content;
    let changed;
    let templateFunction;
    let itemVisibleFrameContent;
    let visibleFrameTemplateFunction;
    const itemData = this._getItemData();
    const frameElement = this.dom.box || this.dom.point;
    const itemVisibleFrameContentElement = frameElement.getElementsByClassName("vis-item-visible-frame")[0];
    if (this.options.visibleFrameTemplate) {
      var _context5;
      visibleFrameTemplateFunction = _bindInstanceProperty(_context5 = this.options.visibleFrameTemplate).call(_context5, this);
      itemVisibleFrameContent = availableUtils.xss(visibleFrameTemplateFunction(itemData, itemVisibleFrameContentElement));
    } else {
      itemVisibleFrameContent = "";
    }
    if (itemVisibleFrameContentElement) {
      if (itemVisibleFrameContent instanceof Object && !(itemVisibleFrameContent instanceof Element)) {
        visibleFrameTemplateFunction(itemData, itemVisibleFrameContentElement);
      } else {
        changed = this._contentToString(this.itemVisibleFrameContent) !== this._contentToString(itemVisibleFrameContent);
        if (changed) {
          if (itemVisibleFrameContent instanceof Element) {
            itemVisibleFrameContentElement.innerHTML = "";
            itemVisibleFrameContentElement.appendChild(itemVisibleFrameContent);
          } else if (itemVisibleFrameContent != void 0) {
            itemVisibleFrameContentElement.innerHTML = availableUtils.xss(itemVisibleFrameContent);
          } else {
            if (!(this.data.type == "background" && this.data.content === void 0)) {
              throw new Error('Property "content" missing in item '.concat(this.id));
            }
          }
          this.itemVisibleFrameContent = itemVisibleFrameContent;
        }
      }
    }
    if (this.options.template) {
      var _context6;
      templateFunction = _bindInstanceProperty(_context6 = this.options.template).call(_context6, this);
      content = templateFunction(itemData, element, this.data);
    } else {
      content = this.data.content;
    }
    if (content instanceof Object && !(content instanceof Element)) {
      templateFunction(itemData, element);
    } else {
      changed = this._contentToString(this.content) !== this._contentToString(content);
      if (changed) {
        if (content instanceof Element) {
          element.innerHTML = "";
          element.appendChild(content);
        } else if (content != void 0) {
          element.innerHTML = availableUtils.xss(content);
        } else {
          if (!(this.data.type == "background" && this.data.content === void 0)) {
            throw new Error('Property "content" missing in item '.concat(this.id));
          }
        }
        this.content = content;
      }
    }
  }
  /**
   * Process dataAttributes timeline option and set as data- attributes on dom.content
   * @param {Element} element   HTML element to which the attributes will be attached
   * @private
   */
  _updateDataAttributes(element) {
    if (this.options.dataAttributes && this.options.dataAttributes.length > 0) {
      let attributes = [];
      if (_Array$isArray(this.options.dataAttributes)) {
        attributes = this.options.dataAttributes;
      } else if (this.options.dataAttributes == "all") {
        attributes = _Object$keys(this.data);
      } else {
        return;
      }
      for (const name of attributes) {
        const value = this.data[name];
        if (value != null) {
          element.setAttribute("data-".concat(name), value);
        } else {
          element.removeAttribute("data-".concat(name));
        }
      }
    }
  }
  /**
   * Update custom styles of the element
   * @param {Element} element
   * @private
   */
  _updateStyle(element) {
    if (this.style) {
      availableUtils.removeCssText(element, this.style);
      this.style = null;
    }
    if (this.data.style) {
      availableUtils.addCssText(element, this.data.style);
      this.style = this.data.style;
    }
  }
  /**
   * Stringify the items contents
   * @param {string | Element | undefined} content
   * @returns {string | undefined}
   * @private
   */
  _contentToString(content) {
    if (typeof content === "string") return content;
    if (content && "outerHTML" in content) return content.outerHTML;
    return content;
  }
  /**
   * Update the editability of this item.
   */
  _updateEditStatus() {
    if (this.options) {
      if (typeof this.options.editable === "boolean") {
        this.editable = {
          updateTime: this.options.editable,
          updateGroup: this.options.editable,
          remove: this.options.editable
        };
      } else if (typeof this.options.editable === "object") {
        this.editable = {};
        availableUtils.selectiveExtend(["updateTime", "updateGroup", "remove"], this.editable, this.options.editable);
      }
    }
    if (!this.options || !this.options.editable || this.options.editable.overrideItems !== true) {
      if (this.data) {
        if (typeof this.data.editable === "boolean") {
          this.editable = {
            updateTime: this.data.editable,
            updateGroup: this.data.editable,
            remove: this.data.editable
          };
        } else if (typeof this.data.editable === "object") {
          this.editable = {};
          availableUtils.selectiveExtend(["updateTime", "updateGroup", "remove"], this.editable, this.data.editable);
        }
      }
    }
  }
  /**
   * Return the width of the item left from its start date
   * @return {number}
   */
  getWidthLeft() {
    return 0;
  }
  /**
   * Return the width of the item right from the max of its start and end date
   * @return {number}
   */
  getWidthRight() {
    return 0;
  }
  /**
   * Return the title of the item
   * @return {string | undefined}
   */
  getTitle() {
    if (this.options.tooltip && this.options.tooltip.template) {
      var _context7;
      const templateFunction = _bindInstanceProperty(_context7 = this.options.tooltip.template).call(_context7, this);
      return templateFunction(this._getItemData(), this.data);
    }
    return this.data.title;
  }
};
Item.prototype.stack = true;
var BoxItem = class extends Item {
  /**
   * @param {Object} data             Object containing parameters start
   *                                  content, className.
   * @param {{toScreen: function, toTime: function}} conversion
   *                                  Conversion functions from time to screen and vice versa
   * @param {Object} [options]        Configuration options
   *                                  // TODO: describe available options
   */
  constructor(data, conversion, options) {
    super(data, conversion, options);
    this.props = {
      dot: {
        width: 0,
        height: 0
      },
      line: {
        width: 0,
        height: 0
      }
    };
    if (data) {
      if (data.start == void 0) {
        throw new Error('Property "start" missing in item '.concat(data));
      }
    }
  }
  /**
   * Check whether this item is visible inside given range
   * @param {{start: number, end: number}} range with a timestamp for start and end
   * @returns {boolean} True if visible
   */
  isVisible(range) {
    if (this.cluster) {
      return false;
    }
    let isVisible;
    const align = this.data.align || this.options.align;
    const widthInMs = this.width * range.getMillisecondsPerPixel();
    if (align == "right") {
      isVisible = this.data.start.getTime() > range.start && this.data.start.getTime() - widthInMs < range.end;
    } else if (align == "left") {
      isVisible = this.data.start.getTime() + widthInMs > range.start && this.data.start.getTime() < range.end;
    } else {
      isVisible = this.data.start.getTime() + widthInMs / 2 > range.start && this.data.start.getTime() - widthInMs / 2 < range.end;
    }
    return isVisible;
  }
  /**
   * create DOM element
   * @private
   */
  _createDomElement() {
    if (!this.dom) {
      this.dom = {};
      this.dom.box = document.createElement("DIV");
      this.dom.content = document.createElement("DIV");
      this.dom.content.className = "vis-item-content";
      this.dom.box.appendChild(this.dom.content);
      this.dom.line = document.createElement("DIV");
      this.dom.line.className = "vis-line";
      this.dom.dot = document.createElement("DIV");
      this.dom.dot.className = "vis-dot";
      this.dom.box["vis-item"] = this;
      this.dirty = true;
    }
  }
  /**
   * append DOM element
   * @private
   */
  _appendDomElement() {
    if (!this.parent) {
      throw new Error("Cannot redraw item: no parent attached");
    }
    if (!this.dom.box.parentNode) {
      const foreground = this.parent.dom.foreground;
      if (!foreground) throw new Error("Cannot redraw item: parent has no foreground container element");
      foreground.appendChild(this.dom.box);
    }
    if (!this.dom.line.parentNode) {
      var background = this.parent.dom.background;
      if (!background) throw new Error("Cannot redraw item: parent has no background container element");
      background.appendChild(this.dom.line);
    }
    if (!this.dom.dot.parentNode) {
      const axis = this.parent.dom.axis;
      if (!background) throw new Error("Cannot redraw item: parent has no axis container element");
      axis.appendChild(this.dom.dot);
    }
    this.displayed = true;
  }
  /**
   * update dirty DOM element
   * @private
   */
  _updateDirtyDomComponents() {
    if (this.dirty) {
      this._updateContents(this.dom.content);
      this._updateDataAttributes(this.dom.box);
      this._updateStyle(this.dom.box);
      const editable = this.editable.updateTime || this.editable.updateGroup;
      const className = (this.data.className ? " " + this.data.className : "") + (this.selected ? " vis-selected" : "") + (editable ? " vis-editable" : " vis-readonly");
      this.dom.box.className = "vis-item vis-box".concat(className);
      this.dom.line.className = "vis-item vis-line".concat(className);
      this.dom.dot.className = "vis-item vis-dot".concat(className);
    }
  }
  /**
   * get DOM components sizes
   * @return {object}
   * @private
   */
  _getDomComponentsSizes() {
    return {
      previous: {
        right: this.dom.box.style.right,
        left: this.dom.box.style.left
      },
      dot: {
        height: this.dom.dot.offsetHeight,
        width: this.dom.dot.offsetWidth
      },
      line: {
        width: this.dom.line.offsetWidth
      },
      box: {
        width: this.dom.box.offsetWidth,
        height: this.dom.box.offsetHeight
      }
    };
  }
  /**
   * update DOM components sizes
   * @param {object} sizes
   * @private
   */
  _updateDomComponentsSizes(sizes) {
    if (this.options.rtl) {
      this.dom.box.style.right = "0px";
    } else {
      this.dom.box.style.left = "0px";
    }
    this.props.dot.height = sizes.dot.height;
    this.props.dot.width = sizes.dot.width;
    this.props.line.width = sizes.line.width;
    this.width = sizes.box.width;
    this.height = sizes.box.height;
    if (this.options.rtl) {
      this.dom.box.style.right = sizes.previous.right;
    } else {
      this.dom.box.style.left = sizes.previous.left;
    }
    this.dirty = false;
  }
  /**
   * repaint DOM additionals
   * @private
   */
  _repaintDomAdditionals() {
    this._repaintOnItemUpdateTimeTooltip(this.dom.box);
    this._repaintDragCenter();
    this._repaintDeleteButton(this.dom.box);
  }
  /**
   * Repaint the item
   * @param {boolean} [returnQueue=false]  return the queue
   * @return {boolean} the redraw queue if returnQueue=true
   */
  redraw(returnQueue) {
    var _context, _context2, _context3, _context5;
    let sizes;
    const queue = [
      // create item DOM
      _bindInstanceProperty(_context = this._createDomElement).call(_context, this),
      // append DOM to parent DOM
      _bindInstanceProperty(_context2 = this._appendDomElement).call(_context2, this),
      // update dirty DOM
      _bindInstanceProperty(_context3 = this._updateDirtyDomComponents).call(_context3, this),
      () => {
        if (this.dirty) {
          sizes = this._getDomComponentsSizes();
        }
      },
      () => {
        if (this.dirty) {
          var _context4;
          _bindInstanceProperty(_context4 = this._updateDomComponentsSizes).call(_context4, this)(sizes);
        }
      },
      // repaint DOM additionals
      _bindInstanceProperty(_context5 = this._repaintDomAdditionals).call(_context5, this)
    ];
    if (returnQueue) {
      return queue;
    } else {
      let result;
      _forEachInstanceProperty(queue).call(queue, (fn) => {
        result = fn();
      });
      return result;
    }
  }
  /**
   * Show the item in the DOM (when not already visible). The items DOM will
   * be created when needed.
   * @param {boolean} [returnQueue=false]  whether to return a queue of functions to execute instead of just executing them
   * @return {boolean} the redraw queue if returnQueue=true
   */
  show(returnQueue) {
    if (!this.displayed) {
      return this.redraw(returnQueue);
    }
  }
  /**
   * Hide the item from the DOM (when visible)
   */
  hide() {
    if (this.displayed) {
      const dom2 = this.dom;
      if (dom2.box.remove) dom2.box.remove();
      else if (dom2.box.parentNode) dom2.box.parentNode.removeChild(dom2.box);
      if (dom2.line.remove) dom2.line.remove();
      else if (dom2.line.parentNode) dom2.line.parentNode.removeChild(dom2.line);
      if (dom2.dot.remove) dom2.dot.remove();
      else if (dom2.dot.parentNode) dom2.dot.parentNode.removeChild(dom2.dot);
      this.displayed = false;
    }
  }
  /**
   * Reposition the item XY
   */
  repositionXY() {
    const rtl = this.options.rtl;
    const repositionXY = function(element, x, y) {
      var _context6;
      let rtl2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      if (x === void 0 && y === void 0) return;
      const directionX = rtl2 ? x * -1 : x;
      if (y === void 0) {
        element.style.transform = "translateX(".concat(directionX, "px)");
        return;
      }
      if (x === void 0) {
        element.style.transform = "translateY(".concat(y, "px)");
        return;
      }
      element.style.transform = _concatInstanceProperty(_context6 = "translate(".concat(directionX, "px, ")).call(_context6, y, "px)");
    };
    repositionXY(this.dom.box, this.boxX, this.boxY, rtl);
    repositionXY(this.dom.dot, this.dotX, this.dotY, rtl);
    repositionXY(this.dom.line, this.lineX, this.lineY, rtl);
  }
  /**
   * Reposition the item horizontally
   * @Override
   */
  repositionX() {
    const start = this.conversion.toScreen(this.data.start);
    const align = this.data.align === void 0 ? this.options.align : this.data.align;
    const lineWidth = this.props.line.width;
    const dotWidth = this.props.dot.width;
    if (align == "right") {
      this.boxX = start - this.width;
      this.lineX = start - lineWidth;
      this.dotX = start - lineWidth / 2 - dotWidth / 2;
    } else if (align == "left") {
      this.boxX = start;
      this.lineX = start;
      this.dotX = start + lineWidth / 2 - dotWidth / 2;
    } else {
      this.boxX = start - this.width / 2;
      this.lineX = this.options.rtl ? start - lineWidth : start - lineWidth / 2;
      this.dotX = start - dotWidth / 2;
    }
    if (this.options.rtl) this.right = this.boxX;
    else this.left = this.boxX;
    this.repositionXY();
  }
  /**
   * Reposition the item vertically
   * @Override
   */
  repositionY() {
    const orientation = this.options.orientation.item;
    const lineStyle = this.dom.line.style;
    if (orientation == "top") {
      const lineHeight = this.parent.top + this.top + 1;
      this.boxY = this.top || 0;
      lineStyle.height = "".concat(lineHeight, "px");
      lineStyle.bottom = "";
      lineStyle.top = "0";
    } else {
      const itemSetHeight = this.parent.itemSet.props.height;
      const lineHeight = itemSetHeight - this.parent.top - this.parent.height + this.top;
      this.boxY = this.parent.height - this.top - (this.height || 0);
      lineStyle.height = "".concat(lineHeight, "px");
      lineStyle.top = "";
      lineStyle.bottom = "0";
    }
    this.dotY = -this.props.dot.height / 2;
    this.repositionXY();
  }
  /**
   * Return the width of the item left from its start date
   * @return {number}
   */
  getWidthLeft() {
    return this.width / 2;
  }
  /**
   * Return the width of the item right from its start date
   * @return {number}
   */
  getWidthRight() {
    return this.width / 2;
  }
};
var PointItem = class extends Item {
  /**
   * @param {Object} data             Object containing parameters start
   *                                  content, className.
   * @param {{toScreen: function, toTime: function}} conversion
   *                                  Conversion functions from time to screen and vice versa
   * @param {Object} [options]        Configuration options
   *                                  // TODO: describe available options
   */
  constructor(data, conversion, options) {
    super(data, conversion, options);
    this.props = {
      dot: {
        top: 0,
        width: 0,
        height: 0
      },
      content: {
        height: 0,
        marginLeft: 0,
        marginRight: 0
      }
    };
    if (data) {
      if (data.start == void 0) {
        throw new Error('Property "start" missing in item '.concat(data));
      }
    }
  }
  /**
   * Check whether this item is visible inside given range
   * @param {{start: number, end: number}} range with a timestamp for start and end
   * @returns {boolean} True if visible
   */
  isVisible(range) {
    if (this.cluster) {
      return false;
    }
    const widthInMs = this.width * range.getMillisecondsPerPixel();
    return this.data.start.getTime() + widthInMs > range.start && this.data.start < range.end;
  }
  /**
   * create DOM element
   * @private
   */
  _createDomElement() {
    if (!this.dom) {
      this.dom = {};
      this.dom.point = document.createElement("div");
      this.dom.content = document.createElement("div");
      this.dom.content.className = "vis-item-content";
      this.dom.point.appendChild(this.dom.content);
      this.dom.dot = document.createElement("div");
      this.dom.point.appendChild(this.dom.dot);
      this.dom.point["vis-item"] = this;
      this.dirty = true;
    }
  }
  /**
   * append DOM element
   * @private
   */
  _appendDomElement() {
    if (!this.parent) {
      throw new Error("Cannot redraw item: no parent attached");
    }
    if (!this.dom.point.parentNode) {
      const foreground = this.parent.dom.foreground;
      if (!foreground) {
        throw new Error("Cannot redraw item: parent has no foreground container element");
      }
      foreground.appendChild(this.dom.point);
    }
    this.displayed = true;
  }
  /**
   * update dirty DOM components
   * @private
   */
  _updateDirtyDomComponents() {
    if (this.dirty) {
      this._updateContents(this.dom.content);
      this._updateDataAttributes(this.dom.point);
      this._updateStyle(this.dom.point);
      const editable = this.editable.updateTime || this.editable.updateGroup;
      const className = (this.data.className ? " " + this.data.className : "") + (this.selected ? " vis-selected" : "") + (editable ? " vis-editable" : " vis-readonly");
      this.dom.point.className = "vis-item vis-point".concat(className);
      this.dom.dot.className = "vis-item vis-dot".concat(className);
    }
  }
  /**
   * get DOM component sizes
   * @return {object}
   * @private
   */
  _getDomComponentsSizes() {
    return {
      dot: {
        width: this.dom.dot.offsetWidth,
        height: this.dom.dot.offsetHeight
      },
      content: {
        width: this.dom.content.offsetWidth,
        height: this.dom.content.offsetHeight
      },
      point: {
        width: this.dom.point.offsetWidth,
        height: this.dom.point.offsetHeight
      }
    };
  }
  /**
   * update DOM components sizes
   * @param {array} sizes
   * @private
   */
  _updateDomComponentsSizes(sizes) {
    this.props.dot.width = sizes.dot.width;
    this.props.dot.height = sizes.dot.height;
    this.props.content.height = sizes.content.height;
    if (this.options.rtl) {
      this.dom.content.style.marginRight = "".concat(this.props.dot.width / 2, "px");
    } else {
      this.dom.content.style.marginLeft = "".concat(this.props.dot.width / 2, "px");
    }
    this.width = sizes.point.width;
    this.height = sizes.point.height;
    this.dom.dot.style.top = "".concat((this.height - this.props.dot.height) / 2, "px");
    const dotWidth = this.props.dot.width;
    const translateX = this.options.rtl ? dotWidth / 2 : dotWidth / 2 * -1;
    this.dom.dot.style.transform = "translateX(".concat(translateX, "px");
    this.dirty = false;
  }
  /**
   * Repain DOM additionals
   * @private
   */
  _repaintDomAdditionals() {
    this._repaintOnItemUpdateTimeTooltip(this.dom.point);
    this._repaintDragCenter();
    this._repaintDeleteButton(this.dom.point);
  }
  /**
   * Repaint the item
   * @param {boolean} [returnQueue=false]  return the queue
   * @return {boolean} the redraw queue if returnQueue=true
   */
  redraw(returnQueue) {
    var _context, _context2, _context3, _context5;
    let sizes;
    const queue = [
      // create item DOM
      _bindInstanceProperty(_context = this._createDomElement).call(_context, this),
      // append DOM to parent DOM
      _bindInstanceProperty(_context2 = this._appendDomElement).call(_context2, this),
      // update dirty DOM
      _bindInstanceProperty(_context3 = this._updateDirtyDomComponents).call(_context3, this),
      () => {
        if (this.dirty) {
          sizes = this._getDomComponentsSizes();
        }
      },
      () => {
        if (this.dirty) {
          var _context4;
          _bindInstanceProperty(_context4 = this._updateDomComponentsSizes).call(_context4, this)(sizes);
        }
      },
      // repaint DOM additionals
      _bindInstanceProperty(_context5 = this._repaintDomAdditionals).call(_context5, this)
    ];
    if (returnQueue) {
      return queue;
    } else {
      let result;
      _forEachInstanceProperty(queue).call(queue, (fn) => {
        result = fn();
      });
      return result;
    }
  }
  /**
   * Reposition XY
   */
  repositionXY() {
    const rtl = this.options.rtl;
    const repositionXY = function(element, x, y) {
      var _context6;
      let rtl2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      if (x === void 0 && y === void 0) return;
      const directionX = rtl2 ? x * -1 : x;
      if (y === void 0) {
        element.style.transform = "translateX(".concat(directionX, "px)");
        return;
      }
      if (x === void 0) {
        element.style.transform = "translateY(".concat(y, "px)");
        return;
      }
      element.style.transform = _concatInstanceProperty(_context6 = "translate(".concat(directionX, "px, ")).call(_context6, y, "px)");
    };
    repositionXY(this.dom.point, this.pointX, this.pointY, rtl);
  }
  /**
   * Show the item in the DOM (when not already visible). The items DOM will
   * be created when needed.
   * @param {boolean} [returnQueue=false]  whether to return a queue of functions to execute instead of just executing them
   * @return {boolean} the redraw queue if returnQueue=true
   */
  show(returnQueue) {
    if (!this.displayed) {
      return this.redraw(returnQueue);
    }
  }
  /**
   * Hide the item from the DOM (when visible)
   */
  hide() {
    if (this.displayed) {
      if (this.dom.point.parentNode) {
        this.dom.point.parentNode.removeChild(this.dom.point);
      }
      this.displayed = false;
    }
  }
  /**
   * Reposition the item horizontally
   * @Override
   */
  repositionX() {
    const start = this.conversion.toScreen(this.data.start);
    this.pointX = start;
    if (this.options.rtl) {
      this.right = start - this.props.dot.width;
    } else {
      this.left = start - this.props.dot.width;
    }
    this.repositionXY();
  }
  /**
   * Reposition the item vertically
   * @Override
   */
  repositionY() {
    const orientation = this.options.orientation.item;
    if (orientation == "top") {
      this.pointY = this.top;
    } else {
      this.pointY = this.parent.height - this.top - this.height;
    }
    this.repositionXY();
  }
  /**
   * Return the width of the item left from its start date
   * @return {number}
   */
  getWidthLeft() {
    return this.props.dot.width;
  }
  /**
   * Return the width of the item right from  its start date
   * @return {number}
   */
  getWidthRight() {
    return this.props.dot.width;
  }
};
var RangeItem = class extends Item {
  /**
   * @param {Object} data             Object containing parameters start, end
   *                                  content, className.
   * @param {{toScreen: function, toTime: function}} conversion
   *                                  Conversion functions from time to screen and vice versa
   * @param {Object} [options]        Configuration options
   *                                  // TODO: describe options
   */
  constructor(data, conversion, options) {
    super(data, conversion, options);
    this.props = {
      content: {
        width: 0
      }
    };
    this.overflow = false;
    if (data) {
      if (data.start == void 0) {
        throw new Error('Property "start" missing in item '.concat(data.id));
      }
      if (data.end == void 0) {
        throw new Error('Property "end" missing in item '.concat(data.id));
      }
    }
  }
  /**
   * Check whether this item is visible inside given range
   *
   * @param {timeline.Range} range with a timestamp for start and end
   * @returns {boolean} True if visible
   */
  isVisible(range) {
    if (this.cluster) {
      return false;
    }
    return this.data.start < range.end && this.data.end > range.start;
  }
  /**
   * create DOM elements
   * @private
   */
  _createDomElement() {
    if (!this.dom) {
      this.dom = {};
      this.dom.box = document.createElement("div");
      this.dom.frame = document.createElement("div");
      this.dom.frame.className = "vis-item-overflow";
      this.dom.box.appendChild(this.dom.frame);
      this.dom.visibleFrame = document.createElement("div");
      this.dom.visibleFrame.className = "vis-item-visible-frame";
      this.dom.box.appendChild(this.dom.visibleFrame);
      this.dom.content = document.createElement("div");
      this.dom.content.className = "vis-item-content";
      this.dom.frame.appendChild(this.dom.content);
      this.dom.box["vis-item"] = this;
      this.dirty = true;
    }
  }
  /**
   * append element to DOM
   * @private
   */
  _appendDomElement() {
    if (!this.parent) {
      throw new Error("Cannot redraw item: no parent attached");
    }
    if (!this.dom.box.parentNode) {
      const foreground = this.parent.dom.foreground;
      if (!foreground) {
        throw new Error("Cannot redraw item: parent has no foreground container element");
      }
      foreground.appendChild(this.dom.box);
    }
    this.displayed = true;
  }
  /**
   * update dirty DOM components
   * @private
   */
  _updateDirtyDomComponents() {
    if (this.dirty) {
      this._updateContents(this.dom.content);
      this._updateDataAttributes(this.dom.box);
      this._updateStyle(this.dom.box);
      const editable = this.editable.updateTime || this.editable.updateGroup;
      const className = (this.data.className ? " " + this.data.className : "") + (this.selected ? " vis-selected" : "") + (editable ? " vis-editable" : " vis-readonly");
      this.dom.box.className = this.baseClassName + className;
      this.dom.content.style.maxWidth = "none";
    }
  }
  /**
   * get DOM component sizes
   * @return {object}
   * @private
   */
  _getDomComponentsSizes() {
    this.overflow = window.getComputedStyle(this.dom.frame).overflow !== "hidden";
    this.whiteSpace = window.getComputedStyle(this.dom.content).whiteSpace !== "nowrap";
    return {
      content: {
        width: this.dom.content.offsetWidth
      },
      box: {
        height: this.dom.box.offsetHeight
      }
    };
  }
  /**
   * update DOM component sizes
   * @param {array} sizes
   * @private
   */
  _updateDomComponentsSizes(sizes) {
    this.props.content.width = sizes.content.width;
    this.height = sizes.box.height;
    this.dom.content.style.maxWidth = "";
    this.dirty = false;
  }
  /**
   * repaint DOM additional components
   * @private
   */
  _repaintDomAdditionals() {
    this._repaintOnItemUpdateTimeTooltip(this.dom.box);
    this._repaintDeleteButton(this.dom.box);
    this._repaintDragCenter();
    this._repaintDragLeft();
    this._repaintDragRight();
  }
  /**
   * Repaint the item
   * @param {boolean} [returnQueue=false]  return the queue
   * @return {boolean} the redraw queue if returnQueue=true
   */
  redraw(returnQueue) {
    var _context, _context2, _context3, _context6;
    let sizes;
    const queue = [
      // create item DOM
      _bindInstanceProperty(_context = this._createDomElement).call(_context, this),
      // append DOM to parent DOM
      _bindInstanceProperty(_context2 = this._appendDomElement).call(_context2, this),
      // update dirty DOM
      _bindInstanceProperty(_context3 = this._updateDirtyDomComponents).call(_context3, this),
      () => {
        if (this.dirty) {
          var _context4;
          sizes = _bindInstanceProperty(_context4 = this._getDomComponentsSizes).call(_context4, this)();
        }
      },
      () => {
        if (this.dirty) {
          var _context5;
          _bindInstanceProperty(_context5 = this._updateDomComponentsSizes).call(_context5, this)(sizes);
        }
      },
      // repaint DOM additionals
      _bindInstanceProperty(_context6 = this._repaintDomAdditionals).call(_context6, this)
    ];
    if (returnQueue) {
      return queue;
    } else {
      let result;
      _forEachInstanceProperty(queue).call(queue, (fn) => {
        result = fn();
      });
      return result;
    }
  }
  /**
   * Show the item in the DOM (when not already visible). The items DOM will
   * be created when needed.
   * @param {boolean} [returnQueue=false]  whether to return a queue of functions to execute instead of just executing them
   * @return {boolean} the redraw queue if returnQueue=true
   */
  show(returnQueue) {
    if (!this.displayed) {
      return this.redraw(returnQueue);
    }
  }
  /**
   * Hide the item from the DOM (when visible)
   */
  hide() {
    if (this.displayed) {
      const box = this.dom.box;
      if (box.parentNode) {
        box.parentNode.removeChild(box);
      }
      this.displayed = false;
    }
  }
  /**
   * Reposition the item horizontally
   * @param {boolean} [limitSize=true] If true (default), the width of the range
   *                                   item will be limited, as the browser cannot
   *                                   display very wide divs. This means though
   *                                   that the applied left and width may
   *                                   not correspond to the ranges start and end
   * @Override
   */
  repositionX(limitSize) {
    const parentWidth = this.parent.width;
    let start = this.conversion.toScreen(this.data.start);
    let end = this.conversion.toScreen(this.data.end);
    const align = this.data.align === void 0 ? this.options.align : this.data.align;
    let contentStartPosition;
    let contentWidth;
    if (this.data.limitSize !== false && (limitSize === void 0 || limitSize === true)) {
      if (start < -parentWidth) {
        start = -parentWidth;
      }
      if (end > 2 * parentWidth) {
        end = 2 * parentWidth;
      }
    }
    const boxWidth = Math.max(Math.round((end - start) * 1e3) / 1e3, 1);
    if (this.overflow) {
      if (this.options.rtl) {
        this.right = start;
      } else {
        this.left = start;
      }
      this.width = boxWidth + this.props.content.width;
      contentWidth = this.props.content.width;
    } else {
      if (this.options.rtl) {
        this.right = start;
      } else {
        this.left = start;
      }
      this.width = boxWidth;
      contentWidth = Math.min(end - start, this.props.content.width);
    }
    if (this.options.rtl) {
      this.dom.box.style.transform = "translateX(".concat(this.right * -1, "px)");
    } else {
      this.dom.box.style.transform = "translateX(".concat(this.left, "px)");
    }
    this.dom.box.style.width = "".concat(boxWidth, "px");
    if (this.whiteSpace) {
      this.height = this.dom.box.offsetHeight;
    }
    switch (align) {
      case "left":
        this.dom.content.style.transform = "translateX(0)";
        break;
      case "right":
        if (this.options.rtl) {
          const translateX = Math.max(boxWidth - contentWidth, 0) * -1;
          this.dom.content.style.transform = "translateX(".concat(translateX, "px)");
        } else {
          this.dom.content.style.transform = "translateX(".concat(Math.max(boxWidth - contentWidth, 0), "px)");
        }
        break;
      case "center":
        if (this.options.rtl) {
          const translateX = Math.max((boxWidth - contentWidth) / 2, 0) * -1;
          this.dom.content.style.transform = "translateX(".concat(translateX, "px)");
        } else {
          this.dom.content.style.transform = "translateX(".concat(Math.max((boxWidth - contentWidth) / 2, 0), "px)");
        }
        break;
      default:
        if (this.overflow) {
          if (end > 0) {
            contentStartPosition = Math.max(-start, 0);
          } else {
            contentStartPosition = -contentWidth;
          }
        } else {
          if (start < 0) {
            contentStartPosition = -start;
          } else {
            contentStartPosition = 0;
          }
        }
        if (this.options.rtl) {
          const translateX = contentStartPosition * -1;
          this.dom.content.style.transform = "translateX(".concat(translateX, "px)");
        } else {
          this.dom.content.style.transform = "translateX(".concat(contentStartPosition, "px)");
        }
    }
  }
  /**
   * Reposition the item vertically
   * @Override
   */
  repositionY() {
    const orientation = this.options.orientation.item;
    const box = this.dom.box;
    if (orientation == "top") {
      box.style.top = "".concat(this.top, "px");
    } else {
      box.style.top = "".concat(this.parent.height - this.top - this.height, "px");
    }
  }
  /**
   * Repaint a drag area on the left side of the range when the range is selected
   * @protected
   */
  _repaintDragLeft() {
    if ((this.selected || this.options.itemsAlwaysDraggable.range) && this.editable.updateTime && !this.dom.dragLeft) {
      const dragLeft = document.createElement("div");
      dragLeft.className = "vis-drag-left";
      dragLeft.dragLeftItem = this;
      this.dom.box.appendChild(dragLeft);
      this.dom.dragLeft = dragLeft;
    } else if (!this.selected && !this.options.itemsAlwaysDraggable.range && this.dom.dragLeft) {
      if (this.dom.dragLeft.parentNode) {
        this.dom.dragLeft.parentNode.removeChild(this.dom.dragLeft);
      }
      this.dom.dragLeft = null;
    }
  }
  /**
   * Repaint a drag area on the right side of the range when the range is selected
   * @protected
   */
  _repaintDragRight() {
    if ((this.selected || this.options.itemsAlwaysDraggable.range) && this.editable.updateTime && !this.dom.dragRight) {
      const dragRight = document.createElement("div");
      dragRight.className = "vis-drag-right";
      dragRight.dragRightItem = this;
      this.dom.box.appendChild(dragRight);
      this.dom.dragRight = dragRight;
    } else if (!this.selected && !this.options.itemsAlwaysDraggable.range && this.dom.dragRight) {
      if (this.dom.dragRight.parentNode) {
        this.dom.dragRight.parentNode.removeChild(this.dom.dragRight);
      }
      this.dom.dragRight = null;
    }
  }
};
RangeItem.prototype.baseClassName = "vis-item vis-range";
var BackgroundItem = class extends Item {
  /**
   * @constructor BackgroundItem
   * @param {Object} data             Object containing parameters start, end
   *                                  content, className.
   * @param {{toScreen: function, toTime: function}} conversion
   *                                  Conversion functions from time to screen and vice versa
   * @param {Object} [options]        Configuration options
   *                                  // TODO: describe options
   * // TODO: implement support for the BackgroundItem just having a start, then being displayed as a sort of an annotation
   */
  constructor(data, conversion, options) {
    super(data, conversion, options);
    this.props = {
      content: {
        width: 0
      }
    };
    this.overflow = false;
    if (data) {
      if (data.start == void 0) {
        throw new Error('Property "start" missing in item '.concat(data.id));
      }
      if (data.end == void 0) {
        throw new Error('Property "end" missing in item '.concat(data.id));
      }
    }
  }
  /**
   * Check whether this item is visible inside given range
   * @param {timeline.Range} range with a timestamp for start and end
   * @returns {boolean} True if visible
   */
  isVisible(range) {
    return this.data.start < range.end && this.data.end > range.start;
  }
  /**
   * create DOM element
   * @private
   */
  _createDomElement() {
    if (!this.dom) {
      this.dom = {};
      this.dom.box = document.createElement("div");
      this.dom.frame = document.createElement("div");
      this.dom.frame.className = "vis-item-overflow";
      this.dom.box.appendChild(this.dom.frame);
      this.dom.content = document.createElement("div");
      this.dom.content.className = "vis-item-content";
      this.dom.frame.appendChild(this.dom.content);
      this.dirty = true;
    }
  }
  /**
   * append DOM element
   * @private
   */
  _appendDomElement() {
    if (!this.parent) {
      throw new Error("Cannot redraw item: no parent attached");
    }
    if (!this.dom.box.parentNode) {
      const background = this.parent.dom.background;
      if (!background) {
        throw new Error("Cannot redraw item: parent has no background container element");
      }
      background.appendChild(this.dom.box);
    }
    this.displayed = true;
  }
  /**
   * update DOM Dirty components
   * @private
   */
  _updateDirtyDomComponents() {
    if (this.dirty) {
      this._updateContents(this.dom.content);
      this._updateDataAttributes(this.dom.content);
      this._updateStyle(this.dom.box);
      const className = (this.data.className ? " " + this.data.className : "") + (this.selected ? " vis-selected" : "");
      this.dom.box.className = this.baseClassName + className;
    }
  }
  /**
   * get DOM components sizes
   * @return {object}
   * @private
   */
  _getDomComponentsSizes() {
    this.overflow = window.getComputedStyle(this.dom.content).overflow !== "hidden";
    return {
      content: {
        width: this.dom.content.offsetWidth
      }
    };
  }
  /**
   * update DOM components sizes
   * @param {object} sizes
   * @private
   */
  _updateDomComponentsSizes(sizes) {
    this.props.content.width = sizes.content.width;
    this.height = 0;
    this.dirty = false;
  }
  /**
   * repaint DOM additionals
   * @private
   */
  _repaintDomAdditionals() {
  }
  /**
   * Repaint the item
   * @param {boolean} [returnQueue=false]  return the queue
   * @return {boolean} the redraw result or the redraw queue if returnQueue=true
   */
  redraw(returnQueue) {
    var _context, _context2, _context3, _context6;
    let sizes;
    const queue = [
      // create item DOM
      _bindInstanceProperty(_context = this._createDomElement).call(_context, this),
      // append DOM to parent DOM
      _bindInstanceProperty(_context2 = this._appendDomElement).call(_context2, this),
      _bindInstanceProperty(_context3 = this._updateDirtyDomComponents).call(_context3, this),
      () => {
        if (this.dirty) {
          var _context4;
          sizes = _bindInstanceProperty(_context4 = this._getDomComponentsSizes).call(_context4, this)();
        }
      },
      () => {
        if (this.dirty) {
          var _context5;
          _bindInstanceProperty(_context5 = this._updateDomComponentsSizes).call(_context5, this)(sizes);
        }
      },
      // repaint DOM additionals
      _bindInstanceProperty(_context6 = this._repaintDomAdditionals).call(_context6, this)
    ];
    if (returnQueue) {
      return queue;
    } else {
      let result;
      _forEachInstanceProperty(queue).call(queue, (fn) => {
        result = fn();
      });
      return result;
    }
  }
  /**
   * Reposition the item vertically
   * @Override
   */
  repositionY() {
    let height;
    const orientation = this.options.orientation.item;
    if (this.data.subgroup !== void 0) {
      const itemSubgroup = this.data.subgroup;
      this.dom.box.style.height = "".concat(this.parent.subgroups[itemSubgroup].height, "px");
      if (orientation == "top") {
        this.dom.box.style.top = "".concat(this.parent.top + this.parent.subgroups[itemSubgroup].top, "px");
      } else {
        this.dom.box.style.top = "".concat(this.parent.top + this.parent.height - this.parent.subgroups[itemSubgroup].top - this.parent.subgroups[itemSubgroup].height, "px");
      }
      this.dom.box.style.bottom = "";
    } else {
      if (this.parent instanceof BackgroundGroup) {
        height = Math.max(this.parent.height, this.parent.itemSet.body.domProps.center.height, this.parent.itemSet.body.domProps.centerContainer.height);
        this.dom.box.style.bottom = orientation == "bottom" ? "0" : "";
        this.dom.box.style.top = orientation == "top" ? "0" : "";
      } else {
        height = this.parent.height;
        this.dom.box.style.top = "".concat(this.parent.top, "px");
        this.dom.box.style.bottom = "";
      }
    }
    this.dom.box.style.height = "".concat(height, "px");
  }
};
BackgroundItem.prototype.baseClassName = "vis-item vis-background";
BackgroundItem.prototype.stack = false;
BackgroundItem.prototype.show = RangeItem.prototype.show;
BackgroundItem.prototype.hide = RangeItem.prototype.hide;
BackgroundItem.prototype.repositionX = RangeItem.prototype.repositionX;
var Popup2 = class {
  /**
   * @param {Element} container       The container object.
   * @param {string}  overflowMethod  How the popup should act to overflowing ('flip', 'cap' or 'none')
   */
  constructor(container, overflowMethod) {
    this.container = container;
    this.overflowMethod = overflowMethod || "cap";
    this.x = 0;
    this.y = 0;
    this.padding = 5;
    this.hidden = false;
    this.frame = document.createElement("div");
    this.frame.className = "vis-tooltip";
    this.container.appendChild(this.frame);
  }
  /**
   * @param {number} x   Horizontal position of the popup window
   * @param {number} y   Vertical position of the popup window
   */
  setPosition(x, y) {
    this.x = _parseInt(x);
    this.y = _parseInt(y);
  }
  /**
   * Set the content for the popup window. This can be HTML code or text.
   * @param {string | Element} content
   */
  setText(content) {
    if (content instanceof Element) {
      this.frame.innerHTML = "";
      this.frame.appendChild(content);
    } else {
      this.frame.innerHTML = availableUtils.xss(content);
    }
  }
  /**
   * Show the popup window
   * @param {boolean} [doShow]    Show or hide the window
   */
  show(doShow) {
    if (doShow === void 0) {
      doShow = true;
    }
    if (doShow === true) {
      var height = this.frame.clientHeight;
      var width = this.frame.clientWidth;
      var maxHeight = this.frame.parentNode.clientHeight;
      var maxWidth = this.frame.parentNode.clientWidth;
      var left = 0, top = 0;
      if (this.overflowMethod == "flip" || this.overflowMethod == "none") {
        let isLeft = false, isTop = true;
        if (this.overflowMethod == "flip") {
          if (this.y - height < this.padding) {
            isTop = false;
          }
          if (this.x + width > maxWidth - this.padding) {
            isLeft = true;
          }
        }
        if (isLeft) {
          left = this.x - width;
        } else {
          left = this.x;
        }
        if (isTop) {
          top = this.y - height;
        } else {
          top = this.y;
        }
      } else {
        top = this.y - height;
        if (top + height + this.padding > maxHeight) {
          top = maxHeight - height - this.padding;
        }
        if (top < this.padding) {
          top = this.padding;
        }
        left = this.x;
        if (left + width + this.padding > maxWidth) {
          left = maxWidth - width - this.padding;
        }
        if (left < this.padding) {
          left = this.padding;
        }
      }
      this.frame.style.left = left + "px";
      this.frame.style.top = top + "px";
      this.frame.style.visibility = "visible";
      this.hidden = false;
    } else {
      this.hide();
    }
  }
  /**
   * Hide the popup window
   */
  hide() {
    this.hidden = true;
    this.frame.style.left = "0";
    this.frame.style.top = "0";
    this.frame.style.visibility = "hidden";
  }
  /**
   * Remove the popup window
   */
  destroy() {
    this.frame.parentNode.removeChild(this.frame);
  }
};
var es_array_every = {};
var hasRequiredEs_array_every;
function requireEs_array_every() {
  if (hasRequiredEs_array_every) return es_array_every;
  hasRequiredEs_array_every = 1;
  var $ = require_export();
  var $every = requireArrayIteration().every;
  var arrayMethodIsStrict2 = requireArrayMethodIsStrict();
  var STRICT_METHOD = arrayMethodIsStrict2("every");
  $({ target: "Array", proto: true, forced: !STRICT_METHOD }, {
    every: function every2(callbackfn) {
      return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    }
  });
  return es_array_every;
}
var every$3;
var hasRequiredEvery$3;
function requireEvery$3() {
  if (hasRequiredEvery$3) return every$3;
  hasRequiredEvery$3 = 1;
  requireEs_array_every();
  var getBuiltInPrototypeMethod2 = requireGetBuiltInPrototypeMethod();
  every$3 = getBuiltInPrototypeMethod2("Array", "every");
  return every$3;
}
var every$2;
var hasRequiredEvery$2;
function requireEvery$2() {
  if (hasRequiredEvery$2) return every$2;
  hasRequiredEvery$2 = 1;
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var method = requireEvery$3();
  var ArrayPrototype = Array.prototype;
  every$2 = function(it2) {
    var own = it2.every;
    return it2 === ArrayPrototype || isPrototypeOf(ArrayPrototype, it2) && own === ArrayPrototype.every ? method : own;
  };
  return every$2;
}
var every$1;
var hasRequiredEvery$1;
function requireEvery$1() {
  if (hasRequiredEvery$1) return every$1;
  hasRequiredEvery$1 = 1;
  var parent = requireEvery$2();
  every$1 = parent;
  return every$1;
}
var every;
var hasRequiredEvery;
function requireEvery() {
  if (hasRequiredEvery) return every;
  hasRequiredEvery = 1;
  every = requireEvery$1();
  return every;
}
var everyExports = requireEvery();
var _everyInstanceProperty = getDefaultExportFromCjs(everyExports);
var ClusterItem = class _ClusterItem extends Item {
  /**
   * @constructor Item
   * @param {Object} data             Object containing (optional) parameters type,
   *                                  start, end, content, group, className.
   * @param {{toScreen: function, toTime: function}} conversion
   *                                  Conversion functions from time to screen and vice versa
   * @param {Object} options          Configuration options
   *                                  // TODO: describe available options
   */
  constructor(data, conversion, options) {
    const modifiedOptions = _Object$assign({}, {
      fitOnDoubleClick: true
    }, options, {
      editable: false
    });
    super(data, conversion, modifiedOptions);
    this.props = {
      content: {
        width: 0,
        height: 0
      }
    };
    if (!data || data.uiItems == void 0) {
      throw new Error('Property "uiItems" missing in item ' + data.id);
    }
    this.id = v4();
    this.group = data.group;
    this._setupRange();
    this.emitter = this.data.eventEmitter;
    this.range = this.data.range;
    this.attached = false;
    this.isCluster = true;
    this.data.isCluster = true;
  }
  /**
   * check if there are items
   * @return {boolean}
   */
  hasItems() {
    return this.data.uiItems && this.data.uiItems.length && this.attached;
  }
  /**
   * set UI items
   * @param {array} items
   */
  setUiItems(items) {
    this.detach();
    this.data.uiItems = items;
    this._setupRange();
    this.attach();
  }
  /**
   * check is visible
   * @param {object} range
   * @return {boolean}
   */
  isVisible(range) {
    const rangeWidth = this.data.end ? this.data.end - this.data.start : 0;
    const widthInMs = this.width * range.getMillisecondsPerPixel();
    const end = Math.max(this.data.start.getTime() + rangeWidth, this.data.start.getTime() + widthInMs);
    return this.data.start < range.end && end > range.start && this.hasItems();
  }
  /**
   * get cluster data
   * @return {object}
   */
  getData() {
    return {
      isCluster: true,
      id: this.id,
      items: this.data.items || [],
      data: this.data
    };
  }
  /**
   * redraw cluster item
   * @param {boolean} returnQueue
   * @return {boolean}
   */
  redraw(returnQueue) {
    var _context, _context2, _context3, _context4, _context5, _context7;
    var sizes;
    var queue = [
      // create item DOM
      _bindInstanceProperty(_context = this._createDomElement).call(_context, this),
      // append DOM to parent DOM
      _bindInstanceProperty(_context2 = this._appendDomElement).call(_context2, this),
      // update dirty DOM
      _bindInstanceProperty(_context3 = this._updateDirtyDomComponents).call(_context3, this),
      _bindInstanceProperty(_context4 = function() {
        if (this.dirty) {
          sizes = this._getDomComponentsSizes();
        }
      }).call(_context4, this),
      _bindInstanceProperty(_context5 = function() {
        if (this.dirty) {
          var _context6;
          _bindInstanceProperty(_context6 = this._updateDomComponentsSizes).call(_context6, this)(sizes);
        }
      }).call(_context5, this),
      // repaint DOM additionals
      _bindInstanceProperty(_context7 = this._repaintDomAdditionals).call(_context7, this)
    ];
    if (returnQueue) {
      return queue;
    } else {
      var result;
      _forEachInstanceProperty(queue).call(queue, function(fn) {
        result = fn();
      });
      return result;
    }
  }
  /**
   * show cluster item
   */
  show() {
    if (!this.displayed) {
      this.redraw();
    }
  }
  /**
   * Hide the item from the DOM (when visible)
   */
  hide() {
    if (this.displayed) {
      var dom2 = this.dom;
      if (dom2.box.parentNode) {
        dom2.box.parentNode.removeChild(dom2.box);
      }
      if (this.options.showStipes) {
        if (dom2.line.parentNode) {
          dom2.line.parentNode.removeChild(dom2.line);
        }
        if (dom2.dot.parentNode) {
          dom2.dot.parentNode.removeChild(dom2.dot);
        }
      }
      this.displayed = false;
    }
  }
  /**
   * reposition item x axis
   */
  repositionX() {
    let start = this.conversion.toScreen(this.data.start);
    let end = this.data.end ? this.conversion.toScreen(this.data.end) : 0;
    if (end) {
      this.repositionXWithRanges(start, end);
    } else {
      let align = this.data.align === void 0 ? this.options.align : this.data.align;
      this.repositionXWithoutRanges(start, align);
    }
    if (this.options.showStipes) {
      this.dom.line.style.display = this._isStipeVisible() ? "block" : "none";
      this.dom.dot.style.display = this._isStipeVisible() ? "block" : "none";
      if (this._isStipeVisible()) {
        this.repositionStype(start, end);
      }
    }
  }
  /**
   * reposition item stype
   * @param {date} start
   * @param {date} end
   */
  repositionStype(start, end) {
    this.dom.line.style.display = "block";
    this.dom.dot.style.display = "block";
    const lineOffsetWidth = this.dom.line.offsetWidth;
    const dotOffsetWidth = this.dom.dot.offsetWidth;
    if (end) {
      const lineOffset = lineOffsetWidth + start + (end - start) / 2;
      const dotOffset = lineOffset - dotOffsetWidth / 2;
      const lineOffsetDirection = this.options.rtl ? lineOffset * -1 : lineOffset;
      const dotOffsetDirection = this.options.rtl ? dotOffset * -1 : dotOffset;
      this.dom.line.style.transform = "translateX(".concat(lineOffsetDirection, "px)");
      this.dom.dot.style.transform = "translateX(".concat(dotOffsetDirection, "px)");
    } else {
      const lineOffsetDirection = this.options.rtl ? start * -1 : start;
      const dotOffsetDirection = this.options.rtl ? (start - dotOffsetWidth / 2) * -1 : start - dotOffsetWidth / 2;
      this.dom.line.style.transform = "translateX(".concat(lineOffsetDirection, "px)");
      this.dom.dot.style.transform = "translateX(".concat(dotOffsetDirection, "px)");
    }
  }
  /**
   * reposition x without ranges
   * @param {date} start
   * @param {string} align
   */
  repositionXWithoutRanges(start, align) {
    if (align == "right") {
      if (this.options.rtl) {
        this.right = start - this.width;
        this.dom.box.style.right = this.right + "px";
      } else {
        this.left = start - this.width;
        this.dom.box.style.left = this.left + "px";
      }
    } else if (align == "left") {
      if (this.options.rtl) {
        this.right = start;
        this.dom.box.style.right = this.right + "px";
      } else {
        this.left = start;
        this.dom.box.style.left = this.left + "px";
      }
    } else {
      if (this.options.rtl) {
        this.right = start - this.width / 2;
        this.dom.box.style.right = this.right + "px";
      } else {
        this.left = start - this.width / 2;
        this.dom.box.style.left = this.left + "px";
      }
    }
  }
  /**
   * reposition x with ranges
   * @param {date} start
   * @param {date} end
   */
  repositionXWithRanges(start, end) {
    let boxWidth = Math.round(Math.max(end - start + 0.5, 1));
    if (this.options.rtl) {
      this.right = start;
    } else {
      this.left = start;
    }
    this.width = Math.max(boxWidth, this.minWidth || 0);
    if (this.options.rtl) {
      this.dom.box.style.right = this.right + "px";
    } else {
      this.dom.box.style.left = this.left + "px";
    }
    this.dom.box.style.width = boxWidth + "px";
  }
  /**
   * reposition item y axis
   */
  repositionY() {
    var orientation = this.options.orientation.item;
    var box = this.dom.box;
    if (orientation == "top") {
      box.style.top = (this.top || 0) + "px";
    } else {
      box.style.top = (this.parent.height - this.top - this.height || 0) + "px";
    }
    if (this.options.showStipes) {
      if (orientation == "top") {
        this.dom.line.style.top = "0";
        this.dom.line.style.height = this.parent.top + this.top + 1 + "px";
        this.dom.line.style.bottom = "";
      } else {
        var itemSetHeight = this.parent.itemSet.props.height;
        var lineHeight = itemSetHeight - this.parent.top - this.parent.height + this.top;
        this.dom.line.style.top = itemSetHeight - lineHeight + "px";
        this.dom.line.style.bottom = "0";
      }
      this.dom.dot.style.top = -this.dom.dot.offsetHeight / 2 + "px";
    }
  }
  /**
   * get width left
   * @return {number}
   */
  getWidthLeft() {
    return this.width / 2;
  }
  /**
   * get width right
   * @return {number}
   */
  getWidthRight() {
    return this.width / 2;
  }
  /**
   * move cluster item
   */
  move() {
    this.repositionX();
    this.repositionY();
  }
  /**
   * attach
   */
  attach() {
    var _context8;
    for (let item of this.data.uiItems) {
      item.cluster = this;
    }
    this.data.items = _mapInstanceProperty(_context8 = this.data.uiItems).call(_context8, (item) => item.data);
    this.attached = true;
    this.dirty = true;
  }
  /**
   * detach
   * @param {boolean} detachFromParent
   * @return {void}
   */
  detach() {
    let detachFromParent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    if (!this.hasItems()) {
      return;
    }
    for (let item of this.data.uiItems) {
      delete item.cluster;
    }
    this.attached = false;
    if (detachFromParent && this.group) {
      this.group.remove(this);
      this.group = null;
    }
    this.data.items = [];
    this.dirty = true;
  }
  /**
   * handle on double click
   */
  _onDoubleClick() {
    this._fit();
  }
  /**
   * set range
   */
  _setupRange() {
    var _context9, _context0, _context1;
    const stats = _mapInstanceProperty(_context9 = this.data.uiItems).call(_context9, (item) => ({
      start: item.data.start.valueOf(),
      end: item.data.end ? item.data.end.valueOf() : item.data.start.valueOf()
    }));
    this.data.min = Math.min(..._mapInstanceProperty(stats).call(stats, (s) => Math.min(s.start, s.end || s.start)));
    this.data.max = Math.max(..._mapInstanceProperty(stats).call(stats, (s) => Math.max(s.start, s.end || s.start)));
    const centers = _mapInstanceProperty(_context0 = this.data.uiItems).call(_context0, (item) => item.center);
    const avg = _reduceInstanceProperty(centers).call(centers, (sum, value) => sum + value, 0) / this.data.uiItems.length;
    if (_someInstanceProperty(_context1 = this.data.uiItems).call(_context1, (item) => item.data.end)) {
      this.data.start = new Date(this.data.min);
      this.data.end = new Date(this.data.max);
    } else {
      this.data.start = new Date(avg);
      this.data.end = null;
    }
  }
  /**
   * get UI items
   * @return {array}
   */
  _getUiItems() {
    if (this.data.uiItems && this.data.uiItems.length) {
      var _context10;
      return _filterInstanceProperty(_context10 = this.data.uiItems).call(_context10, (item) => item.cluster === this);
    }
    return [];
  }
  /**
   * create DOM element
   */
  _createDomElement() {
    if (!this.dom) {
      this.dom = {};
      this.dom.box = document.createElement("DIV");
      this.dom.content = document.createElement("DIV");
      this.dom.content.className = "vis-item-content";
      this.dom.box.appendChild(this.dom.content);
      if (this.options.showStipes) {
        this.dom.line = document.createElement("DIV");
        this.dom.line.className = "vis-cluster-line";
        this.dom.line.style.display = "none";
        this.dom.dot = document.createElement("DIV");
        this.dom.dot.className = "vis-cluster-dot";
        this.dom.dot.style.display = "none";
      }
      if (this.options.fitOnDoubleClick) {
        var _context11;
        this.dom.box.ondblclick = _bindInstanceProperty(_context11 = _ClusterItem.prototype._onDoubleClick).call(_context11, this);
      }
      this.dom.box["vis-item"] = this;
      this.dirty = true;
    }
  }
  /**
   * append element to DOM
   */
  _appendDomElement() {
    if (!this.parent) {
      throw new Error("Cannot redraw item: no parent attached");
    }
    if (!this.dom.box.parentNode) {
      const foreground = this.parent.dom.foreground;
      if (!foreground) {
        throw new Error("Cannot redraw item: parent has no foreground container element");
      }
      foreground.appendChild(this.dom.box);
    }
    const background = this.parent.dom.background;
    if (this.options.showStipes) {
      if (!this.dom.line.parentNode) {
        if (!background) throw new Error("Cannot redraw item: parent has no background container element");
        background.appendChild(this.dom.line);
      }
      if (!this.dom.dot.parentNode) {
        var axis = this.parent.dom.axis;
        if (!background) throw new Error("Cannot redraw item: parent has no axis container element");
        axis.appendChild(this.dom.dot);
      }
    }
    this.displayed = true;
  }
  /**
   * update dirty DOM components
   */
  _updateDirtyDomComponents() {
    if (this.dirty) {
      this._updateContents(this.dom.content);
      this._updateDataAttributes(this.dom.box);
      this._updateStyle(this.dom.box);
      const className = this.baseClassName + " " + (this.data.className ? " " + this.data.className : "") + (this.selected ? " vis-selected" : "") + " vis-readonly";
      this.dom.box.className = "vis-item " + className;
      if (this.options.showStipes) {
        this.dom.line.className = "vis-item vis-cluster-line " + (this.selected ? " vis-selected" : "");
        this.dom.dot.className = "vis-item vis-cluster-dot " + (this.selected ? " vis-selected" : "");
      }
      if (this.data.end) {
        this.dom.content.style.maxWidth = "none";
      }
    }
  }
  /**
   * get DOM components sizes
   * @return {object}
   */
  _getDomComponentsSizes() {
    const sizes = {
      previous: {
        right: this.dom.box.style.right,
        left: this.dom.box.style.left
      },
      box: {
        width: this.dom.box.offsetWidth,
        height: this.dom.box.offsetHeight
      }
    };
    if (this.options.showStipes) {
      sizes.dot = {
        height: this.dom.dot.offsetHeight,
        width: this.dom.dot.offsetWidth
      };
      sizes.line = {
        width: this.dom.line.offsetWidth
      };
    }
    return sizes;
  }
  /**
   * update DOM components sizes
   * @param {object} sizes
   */
  _updateDomComponentsSizes(sizes) {
    if (this.options.rtl) {
      this.dom.box.style.right = "0px";
    } else {
      this.dom.box.style.left = "0px";
    }
    if (!this.data.end) {
      this.width = sizes.box.width;
    } else {
      this.minWidth = sizes.box.width;
    }
    this.height = sizes.box.height;
    if (this.options.rtl) {
      this.dom.box.style.right = sizes.previous.right;
    } else {
      this.dom.box.style.left = sizes.previous.left;
    }
    this.dirty = false;
  }
  /**
   * repaint DOM additional components
   */
  _repaintDomAdditionals() {
    this._repaintOnItemUpdateTimeTooltip(this.dom.box);
  }
  /**
   * check is stripe visible
   * @return {number}
   * @private
   */
  _isStipeVisible() {
    return this.minWidth >= this.width || !this.data.end;
  }
  /**
   * get fit range
   * @return {object}
   * @private
   */
  _getFitRange() {
    const offset = 0.05 * (this.data.max - this.data.min) / 2;
    return {
      fitStart: this.data.min - offset,
      fitEnd: this.data.max + offset
    };
  }
  /**
   * fit
   * @private
   */
  _fit() {
    if (this.emitter) {
      const {
        fitStart,
        fitEnd
      } = this._getFitRange();
      const fitArgs = {
        start: new Date(fitStart),
        end: new Date(fitEnd),
        animation: true
      };
      this.emitter.emit("fit", fitArgs);
    }
  }
  /**
   * get item data
   * @return {object}
   * @private
   */
  _getItemData() {
    return this.data;
  }
};
ClusterItem.prototype.baseClassName = "vis-item vis-range vis-cluster";
var UNGROUPED$2 = "__ungrouped__";
var ReservedGroupIds = {
  UNGROUPED: UNGROUPED$2
};
var ClusterGenerator = class {
  /**
   * @param {ItemSet} itemSet itemsSet instance
   * @constructor ClusterGenerator
   */
  constructor(itemSet) {
    this.itemSet = itemSet;
    this.groups = {};
    this.cache = {};
    this.cache[-1] = [];
  }
  /**
   * @param {Object} itemData             Object containing parameters start content, className.
   * @param {{toScreen: function, toTime: function}} conversion
   *                                  Conversion functions from time to screen and vice versa
   * @param {Object} [options]        Configuration options
   * @return {Object} newItem
   */
  createClusterItem(itemData, conversion, options) {
    const newItem = new ClusterItem(itemData, conversion, options);
    return newItem;
  }
  /**
   * Set the items to be clustered.
   * This will clear cached clusters.
   * @param {Item[]} items
   * @param {Object} [options]  Available options:
   *                            {boolean} applyOnChangedLevel
   *                                If true (default), the changed data is applied
   *                                as soon the cluster level changes. If false,
   *                                The changed data is applied immediately
   */
  setItems(items, options) {
    this.items = items || [];
    this.dataChanged = true;
    this.applyOnChangedLevel = false;
    if (options && options.applyOnChangedLevel) {
      this.applyOnChangedLevel = options.applyOnChangedLevel;
    }
  }
  /**
   * Update the current data set: clear cache, and recalculate the clustering for
   * the current level
   */
  updateData() {
    this.dataChanged = true;
    this.applyOnChangedLevel = false;
  }
  /**
   * Cluster the items which are too close together
   * @param {array} oldClusters
   * @param {number} scale      The scale of the current window : (windowWidth / (endDate - startDate))
   * @param {{maxItems: number, clusterCriteria: function, titleTemplate: string}} options
   * @return {array} clusters
   */
  getClusters(oldClusters, scale, options) {
    let {
      maxItems,
      clusterCriteria
    } = typeof options === "boolean" ? {} : options;
    if (!clusterCriteria) {
      clusterCriteria = () => true;
    }
    maxItems = maxItems || 1;
    let level = -1;
    let granularity = 2;
    let timeWindow = 0;
    if (scale > 0) {
      if (scale >= 1) {
        return [];
      }
      level = Math.abs(Math.round(Math.log(100 / scale) / Math.log(granularity)));
      timeWindow = Math.abs(Math.pow(granularity, level));
    }
    if (this.dataChanged) {
      const levelChanged = level != this.cacheLevel;
      const applyDataNow = this.applyOnChangedLevel ? levelChanged : true;
      if (applyDataNow) {
        this._dropLevelsCache();
        this._filterData();
      }
    }
    this.cacheLevel = level;
    let clusters = this.cache[level];
    if (!clusters) {
      clusters = [];
      for (let groupName in this.groups) {
        if (!Object.prototype.hasOwnProperty.call(this.groups, groupName)) continue;
        const items = this.groups[groupName];
        const iMax = items.length;
        let i = 0;
        while (i < iMax) {
          let item = items[i];
          let neighbors = 1;
          let j = i - 1;
          while (j >= 0 && item.center - items[j].center < timeWindow / 2) {
            if (!items[j].cluster && clusterCriteria(item.data, items[j].data)) {
              neighbors++;
            }
            j--;
          }
          let k = i + 1;
          while (k < items.length && items[k].center - item.center < timeWindow / 2) {
            if (clusterCriteria(item.data, items[k].data)) {
              neighbors++;
            }
            k++;
          }
          let l = clusters.length - 1;
          while (l >= 0 && item.center - clusters[l].center < timeWindow) {
            if (item.group == clusters[l].group && clusterCriteria(item.data, clusters[l].data)) {
              neighbors++;
            }
            l--;
          }
          if (neighbors > maxItems) {
            const num = neighbors - maxItems + 1;
            const clusterItems = [];
            let m = i;
            while (clusterItems.length < num && m < items.length) {
              if (clusterCriteria(items[i].data, items[m].data)) {
                clusterItems.push(items[m]);
              }
              m++;
            }
            const groupId = this.itemSet.getGroupId(item.data);
            const group = this.itemSet.groups[groupId] || this.itemSet.groups[ReservedGroupIds.UNGROUPED];
            let cluster = this._getClusterForItems(clusterItems, group, oldClusters, options);
            clusters.push(cluster);
            i += num;
          } else {
            delete item.cluster;
            i += 1;
          }
        }
      }
      this.cache[level] = clusters;
    }
    return clusters;
  }
  /**
   * Filter the items per group.
   * @private
   */
  _filterData() {
    const groups = {};
    this.groups = groups;
    for (const item of _Object$values(this.items)) {
      const groupName = item.parent ? item.parent.groupId : "";
      let group = groups[groupName];
      if (!group) {
        group = [];
        groups[groupName] = group;
      }
      group.push(item);
      if (item.data.start) {
        if (item.data.end) {
          item.center = (item.data.start.valueOf() + item.data.end.valueOf()) / 2;
        } else {
          item.center = item.data.start.valueOf();
        }
      }
    }
    for (let currentGroupName in groups) {
      var _context;
      if (!Object.prototype.hasOwnProperty.call(groups, currentGroupName)) continue;
      _sortInstanceProperty(_context = groups[currentGroupName]).call(_context, (a, b) => a.center - b.center);
    }
    this.dataChanged = false;
  }
  /**
   * Create new cluster or return existing
   * @private
   * @param {array} clusterItems
   * @param {object} group
   * @param {array} oldClusters
   * @param {object} options
   * @returns {object} cluster
   */
  _getClusterForItems(clusterItems, group, oldClusters, options) {
    var _context2;
    const oldClustersLookup = _mapInstanceProperty(_context2 = oldClusters || []).call(_context2, (cluster2) => {
      var _context3;
      return {
        cluster: cluster2,
        itemsIds: new _Set(_mapInstanceProperty(_context3 = cluster2.data.uiItems).call(_context3, (item) => item.id))
      };
    });
    let cluster;
    if (oldClustersLookup.length) {
      for (let oldClusterData of oldClustersLookup) {
        if (oldClusterData.itemsIds.size === clusterItems.length && _everyInstanceProperty(clusterItems).call(clusterItems, (clusterItem) => oldClusterData.itemsIds.has(clusterItem.id))) {
          cluster = oldClusterData.cluster;
          break;
        }
      }
    }
    if (cluster) {
      cluster.setUiItems(clusterItems);
      if (cluster.group !== group) {
        if (cluster.group) {
          cluster.group.remove(cluster);
        }
        if (group) {
          group.add(cluster);
          cluster.group = group;
        }
      }
      return cluster;
    }
    let titleTemplate = options.titleTemplate || "";
    const conversion = {
      toScreen: this.itemSet.body.util.toScreen,
      toTime: this.itemSet.body.util.toTime
    };
    const title = titleTemplate.replace(/{count}/, clusterItems.length);
    const clusterContent = '<div title="' + title + '">' + clusterItems.length + "</div>";
    const clusterOptions = _Object$assign({}, options, this.itemSet.options);
    const data = {
      content: clusterContent,
      title,
      group,
      uiItems: clusterItems,
      eventEmitter: this.itemSet.body.emitter,
      range: this.itemSet.body.range
    };
    cluster = this.createClusterItem(data, conversion, clusterOptions);
    if (group) {
      group.add(cluster);
      cluster.group = group;
    }
    cluster.attach();
    return cluster;
  }
  /**
   * Drop cache
   * @private
   */
  _dropLevelsCache() {
    this.cache = {};
    this.cacheLevel = -1;
    this.cache[this.cacheLevel] = [];
  }
};
var UNGROUPED$1 = "__ungrouped__";
var BACKGROUND = "__background__";
var ItemSet = class _ItemSet extends Component {
  /**
   * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} body
   * @param {Object} [options]      See ItemSet.setOptions for the available options.
   * @constructor ItemSet
   * @extends Component
   */
  constructor(body, options) {
    super();
    this.body = body;
    this.defaultOptions = {
      type: null,
      // 'box', 'point', 'range', 'background'
      orientation: {
        item: "bottom"
        // item orientation: 'top' or 'bottom'
      },
      align: "auto",
      // alignment of box items
      stack: true,
      stackSubgroups: true,
      groupOrderSwap(fromGroup, toGroup) {
        const targetOrder = toGroup.order;
        toGroup.order = fromGroup.order;
        fromGroup.order = targetOrder;
      },
      groupOrder: "order",
      selectable: true,
      multiselect: false,
      longSelectPressTime: 251,
      itemsAlwaysDraggable: {
        item: false,
        range: false
      },
      editable: {
        updateTime: false,
        updateGroup: false,
        add: false,
        remove: false,
        overrideItems: false
      },
      groupEditable: {
        order: false,
        add: false,
        remove: false
      },
      snap: TimeStep.snap,
      // Only called when `objectData.target === 'item'.
      onDropObjectOnItem(_objectData, item, callback) {
        callback(item);
      },
      onAdd(item, callback) {
        callback(item);
      },
      onUpdate(item, callback) {
        callback(item);
      },
      onMove(item, callback) {
        callback(item);
      },
      onRemove(item, callback) {
        callback(item);
      },
      onMoving(item, callback) {
        callback(item);
      },
      onAddGroup(item, callback) {
        callback(item);
      },
      onMoveGroup(item, callback) {
        callback(item);
      },
      onRemoveGroup(item, callback) {
        callback(item);
      },
      margin: {
        item: {
          horizontal: 10,
          vertical: 10
        },
        axis: 20
      },
      showTooltips: true,
      tooltip: {
        followMouse: false,
        overflowMethod: "flip",
        delay: 500
      },
      tooltipOnItemUpdateTime: false
    };
    this.options = availableUtils.extend({}, this.defaultOptions);
    this.options.rtl = options.rtl;
    this.options.onTimeout = options.onTimeout;
    this.conversion = {
      toScreen: body.util.toScreen,
      toTime: body.util.toTime
    };
    this.dom = {};
    this.props = {};
    this.hammer = null;
    const me = this;
    this.itemsData = null;
    this.groupsData = null;
    this.itemsSettingTime = null;
    this.initialItemSetDrawn = false;
    this.userContinueNotBail = null;
    this.sequentialSelection = false;
    this.itemListeners = {
      add(_event, params) {
        me._onAdd(params.items);
        if (me.options.cluster) {
          me.clusterGenerator.setItems(me.items, {
            applyOnChangedLevel: false
          });
        }
        me.redraw();
      },
      update(_event, params) {
        me._onUpdate(params.items);
        if (me.options.cluster) {
          me.clusterGenerator.setItems(me.items, {
            applyOnChangedLevel: false
          });
        }
        me.redraw();
      },
      remove(_event, params) {
        me._onRemove(params.items);
        if (me.options.cluster) {
          me.clusterGenerator.setItems(me.items, {
            applyOnChangedLevel: false
          });
        }
        me.redraw();
      }
    };
    this.groupListeners = {
      add(_event, params, senderId) {
        me._onAddGroups(params.items);
        if (me.groupsData && me.groupsData.length > 0) {
          var _context;
          const groupsData = me.groupsData.getDataSet();
          _forEachInstanceProperty(_context = groupsData.get()).call(_context, (groupData) => {
            if (groupData.nestedGroups) {
              var _context2;
              if (groupData.showNested != false) {
                groupData.showNested = true;
              }
              let updatedGroups = [];
              _forEachInstanceProperty(_context2 = groupData.nestedGroups).call(_context2, (nestedGroupId) => {
                const updatedNestedGroup = groupsData.get(nestedGroupId);
                if (!updatedNestedGroup) {
                  return;
                }
                updatedNestedGroup.nestedInGroup = groupData.id;
                if (groupData.showNested == false) {
                  updatedNestedGroup.visible = false;
                }
                updatedGroups = _concatInstanceProperty(updatedGroups).call(updatedGroups, updatedNestedGroup);
              });
              groupsData.update(updatedGroups, senderId);
            }
          });
        }
      },
      update(_event, params) {
        me._onUpdateGroups(params.items);
      },
      remove(_event, params) {
        me._onRemoveGroups(params.items);
      }
    };
    this.items = {};
    this.groups = {};
    this.groupIds = [];
    this.selection = [];
    this.popup = null;
    this.popupTimer = null;
    this.touchParams = {};
    this.groupTouchParams = {
      group: null,
      isDragging: false
    };
    this._create();
    this.setOptions(options);
    this.clusters = [];
  }
  /**
   * Create the HTML DOM for the ItemSet
   */
  _create() {
    var _context3, _context4, _context5, _context6, _context7, _context8, _context9, _context0, _context1, _context10, _context11, _context12, _context13, _context14, _context15;
    const frame = document.createElement("div");
    frame.className = "vis-itemset";
    frame["vis-itemset"] = this;
    this.dom.frame = frame;
    const background = document.createElement("div");
    background.className = "vis-background";
    frame.appendChild(background);
    this.dom.background = background;
    const foreground = document.createElement("div");
    foreground.className = "vis-foreground";
    frame.appendChild(foreground);
    this.dom.foreground = foreground;
    const axis = document.createElement("div");
    axis.className = "vis-axis";
    this.dom.axis = axis;
    const labelSet = document.createElement("div");
    labelSet.className = "vis-labelset";
    this.dom.labelSet = labelSet;
    this._updateUngrouped();
    const backgroundGroup = new BackgroundGroup(BACKGROUND, null, this);
    backgroundGroup.show();
    this.groups[BACKGROUND] = backgroundGroup;
    this.hammer = new Hammer(this.body.dom.centerContainer);
    this.hammer.on("hammer.input", (event2) => {
      if (event2.isFirst) {
        this._onTouch(event2);
      }
    });
    this.hammer.on("panstart", _bindInstanceProperty(_context3 = this._onDragStart).call(_context3, this));
    this.hammer.on("panmove", _bindInstanceProperty(_context4 = this._onDrag).call(_context4, this));
    this.hammer.on("panend", _bindInstanceProperty(_context5 = this._onDragEnd).call(_context5, this));
    this.hammer.get("pan").set({
      threshold: 5,
      direction: Hammer.ALL
    });
    this.hammer.get("press").set({
      time: 1e4
    });
    this.hammer.on("tap", _bindInstanceProperty(_context6 = this._onSelectItem).call(_context6, this));
    this.hammer.on("press", _bindInstanceProperty(_context7 = this._onMultiSelectItem).call(_context7, this));
    this.hammer.get("press").set({
      time: 1e4
    });
    this.hammer.on("doubletap", _bindInstanceProperty(_context8 = this._onAddItem).call(_context8, this));
    if (this.options.rtl) {
      this.groupHammer = new Hammer(this.body.dom.rightContainer);
    } else {
      this.groupHammer = new Hammer(this.body.dom.leftContainer);
    }
    this.groupHammer.on("tap", _bindInstanceProperty(_context9 = this._onGroupClick).call(_context9, this));
    this.groupHammer.on("panstart", _bindInstanceProperty(_context0 = this._onGroupDragStart).call(_context0, this));
    this.groupHammer.on("panmove", _bindInstanceProperty(_context1 = this._onGroupDrag).call(_context1, this));
    this.groupHammer.on("panend", _bindInstanceProperty(_context10 = this._onGroupDragEnd).call(_context10, this));
    this.groupHammer.get("pan").set({
      threshold: 5,
      direction: Hammer.DIRECTION_VERTICAL
    });
    this.body.dom.centerContainer.addEventListener("mouseover", _bindInstanceProperty(_context11 = this._onMouseOver).call(_context11, this));
    this.body.dom.centerContainer.addEventListener("mouseout", _bindInstanceProperty(_context12 = this._onMouseOut).call(_context12, this));
    this.body.dom.centerContainer.addEventListener("mousemove", _bindInstanceProperty(_context13 = this._onMouseMove).call(_context13, this));
    this.body.dom.centerContainer.addEventListener("contextmenu", _bindInstanceProperty(_context14 = this._onDragEnd).call(_context14, this));
    this.body.dom.centerContainer.addEventListener("mousewheel", _bindInstanceProperty(_context15 = this._onMouseWheel).call(_context15, this));
    this.show();
  }
  /**
   * Set options for the ItemSet. Existing options will be extended/overwritten.
   * @param {Object} [options] The following options are available:
   *                           {string} type
   *                              Default type for the items. Choose from 'box'
   *                              (default), 'point', 'range', or 'background'.
   *                              The default style can be overwritten by
   *                              individual items.
   *                           {string} align
   *                              Alignment for the items, only applicable for
   *                              BoxItem. Choose 'center' (default), 'left', or
   *                              'right'.
   *                           {string} orientation.item
   *                              Orientation of the item set. Choose 'top' or
   *                              'bottom' (default).
   *                           {Function} groupOrder
   *                              A sorting function for ordering groups
   *                           {boolean} stack
   *                              If true (default), items will be stacked on
   *                              top of each other.
   *                           {number} margin.axis
   *                              Margin between the axis and the items in pixels.
   *                              Default is 20.
   *                           {number} margin.item.horizontal
   *                              Horizontal margin between items in pixels.
   *                              Default is 10.
   *                           {number} margin.item.vertical
   *                              Vertical Margin between items in pixels.
   *                              Default is 10.
   *                           {number} margin.item
   *                              Margin between items in pixels in both horizontal
   *                              and vertical direction. Default is 10.
   *                           {number} margin
   *                              Set margin for both axis and items in pixels.
   *                           {boolean} selectable
   *                              If true (default), items can be selected.
   *                           {boolean} multiselect
   *                              If true, multiple items can be selected.
   *                              False by default.
   *                           {boolean} editable
   *                              Set all editable options to true or false
   *                           {boolean} editable.updateTime
   *                              Allow dragging an item to an other moment in time
   *                           {boolean} editable.updateGroup
   *                              Allow dragging an item to an other group
   *                           {boolean} editable.add
   *                              Allow creating new items on double tap
   *                           {boolean} editable.remove
   *                              Allow removing items by clicking the delete button
   *                              top right of a selected item.
   *                           {Function(item: Item, callback: Function)} onAdd
   *                              Callback function triggered when an item is about to be added:
   *                              when the user double taps an empty space in the Timeline.
   *                           {Function(item: Item, callback: Function)} onUpdate
   *                              Callback function fired when an item is about to be updated.
   *                              This function typically has to show a dialog where the user
   *                              change the item. If not implemented, nothing happens.
   *                           {Function(item: Item, callback: Function)} onMove
   *                              Fired when an item has been moved. If not implemented,
   *                              the move action will be accepted.
   *                           {Function(item: Item, callback: Function)} onRemove
   *                              Fired when an item is about to be deleted.
   *                              If not implemented, the item will be always removed.
   */
  setOptions(options) {
    if (options) {
      var _context16, _context18;
      const fields = ["type", "rtl", "align", "order", "stack", "stackSubgroups", "selectable", "multiselect", "sequentialSelection", "multiselectPerGroup", "longSelectPressTime", "groupOrder", "dataAttributes", "template", "groupTemplate", "visibleFrameTemplate", "hide", "snap", "groupOrderSwap", "showTooltips", "tooltip", "tooltipOnItemUpdateTime", "groupHeightMode", "onTimeout"];
      availableUtils.selectiveExtend(fields, this.options, options);
      if ("itemsAlwaysDraggable" in options) {
        if (typeof options.itemsAlwaysDraggable === "boolean") {
          this.options.itemsAlwaysDraggable.item = options.itemsAlwaysDraggable;
          this.options.itemsAlwaysDraggable.range = false;
        } else if (typeof options.itemsAlwaysDraggable === "object") {
          availableUtils.selectiveExtend(["item", "range"], this.options.itemsAlwaysDraggable, options.itemsAlwaysDraggable);
          if (!this.options.itemsAlwaysDraggable.item) {
            this.options.itemsAlwaysDraggable.range = false;
          }
        }
      }
      if ("sequentialSelection" in options) {
        if (typeof options.sequentialSelection === "boolean") {
          this.options.sequentialSelection = options.sequentialSelection;
        }
      }
      if ("orientation" in options) {
        if (typeof options.orientation === "string") {
          this.options.orientation.item = options.orientation === "top" ? "top" : "bottom";
        } else if (typeof options.orientation === "object" && "item" in options.orientation) {
          this.options.orientation.item = options.orientation.item;
        }
      }
      if ("margin" in options) {
        if (typeof options.margin === "number") {
          this.options.margin.axis = options.margin;
          this.options.margin.item.horizontal = options.margin;
          this.options.margin.item.vertical = options.margin;
        } else if (typeof options.margin === "object") {
          availableUtils.selectiveExtend(["axis"], this.options.margin, options.margin);
          if ("item" in options.margin) {
            if (typeof options.margin.item === "number") {
              this.options.margin.item.horizontal = options.margin.item;
              this.options.margin.item.vertical = options.margin.item;
            } else if (typeof options.margin.item === "object") {
              availableUtils.selectiveExtend(["horizontal", "vertical"], this.options.margin.item, options.margin.item);
            }
          }
        }
      }
      _forEachInstanceProperty(_context16 = ["locale", "locales"]).call(_context16, (key) => {
        if (key in options) {
          this.options[key] = options[key];
        }
      });
      if ("editable" in options) {
        if (typeof options.editable === "boolean") {
          this.options.editable.updateTime = options.editable;
          this.options.editable.updateGroup = options.editable;
          this.options.editable.add = options.editable;
          this.options.editable.remove = options.editable;
          this.options.editable.overrideItems = false;
        } else if (typeof options.editable === "object") {
          availableUtils.selectiveExtend(["updateTime", "updateGroup", "add", "remove", "overrideItems"], this.options.editable, options.editable);
        }
      }
      if ("groupEditable" in options) {
        if (typeof options.groupEditable === "boolean") {
          this.options.groupEditable.order = options.groupEditable;
          this.options.groupEditable.add = options.groupEditable;
          this.options.groupEditable.remove = options.groupEditable;
        } else if (typeof options.groupEditable === "object") {
          availableUtils.selectiveExtend(["order", "add", "remove"], this.options.groupEditable, options.groupEditable);
        }
      }
      const addCallback = (name) => {
        const fn = options[name];
        if (fn) {
          if (!(typeof fn === "function")) {
            var _context17;
            throw new Error(_concatInstanceProperty(_context17 = "option ".concat(name, " must be a function ")).call(_context17, name, "(item, callback)"));
          }
          this.options[name] = fn;
        }
      };
      _forEachInstanceProperty(_context18 = ["onDropObjectOnItem", "onAdd", "onUpdate", "onRemove", "onMove", "onMoving", "onAddGroup", "onMoveGroup", "onRemoveGroup"]).call(_context18, addCallback);
      if (options.cluster) {
        _Object$assign(this.options, {
          cluster: options.cluster
        });
        if (!this.clusterGenerator) {
          this.clusterGenerator = new ClusterGenerator(this);
        }
        this.clusterGenerator.setItems(this.items, {
          applyOnChangedLevel: false
        });
        this.markDirty({
          refreshItems: true,
          restackGroups: true
        });
        this.redraw();
      } else if (this.clusterGenerator) {
        this._detachAllClusters();
        this.clusters = [];
        this.clusterGenerator = null;
        this.options.cluster = void 0;
        this.markDirty({
          refreshItems: true,
          restackGroups: true
        });
        this.redraw();
      } else {
        this.markDirty();
      }
    }
  }
  /**
   * Mark the ItemSet dirty so it will refresh everything with next redraw.
   * Optionally, all items can be marked as dirty and be refreshed.
   * @param {{refreshItems: boolean}} [options]
   */
  markDirty(options) {
    this.groupIds = [];
    if (options) {
      if (options.refreshItems) {
        _forEachInstanceProperty(availableUtils).call(availableUtils, this.items, (item) => {
          item.dirty = true;
          if (item.displayed) item.redraw();
        });
      }
      if (options.restackGroups) {
        _forEachInstanceProperty(availableUtils).call(availableUtils, this.groups, (group, key) => {
          if (key === BACKGROUND) return;
          group.stackDirty = true;
        });
      }
    }
  }
  /**
   * Destroy the ItemSet
   */
  destroy() {
    this.clearPopupTimer();
    this.hide();
    this.setItems(null);
    this.setGroups(null);
    this.hammer && this.hammer.destroy();
    this.groupHammer && this.groupHammer.destroy();
    this.hammer = null;
    this.body = null;
    this.conversion = null;
  }
  /**
   * Hide the component from the DOM
   */
  hide() {
    if (this.dom.frame.parentNode) {
      this.dom.frame.parentNode.removeChild(this.dom.frame);
    }
    if (this.dom.axis.parentNode) {
      this.dom.axis.parentNode.removeChild(this.dom.axis);
    }
    if (this.dom.labelSet.parentNode) {
      this.dom.labelSet.parentNode.removeChild(this.dom.labelSet);
    }
  }
  /**
   * Show the component in the DOM (when not already visible).
   */
  show() {
    if (!this.dom.frame.parentNode) {
      this.body.dom.center.appendChild(this.dom.frame);
    }
    if (!this.dom.axis.parentNode) {
      this.body.dom.backgroundVertical.appendChild(this.dom.axis);
    }
    if (!this.dom.labelSet.parentNode) {
      if (this.options.rtl) {
        this.body.dom.right.appendChild(this.dom.labelSet);
      } else {
        this.body.dom.left.appendChild(this.dom.labelSet);
      }
    }
  }
  /**
   * Activates the popup timer to show the given popup after a fixed time.
   * @param {Popup} popup
   */
  setPopupTimer(popup) {
    this.clearPopupTimer();
    if (popup) {
      const delay = this.options.tooltip.delay || typeof this.options.tooltip.delay === "number" ? this.options.tooltip.delay : 500;
      this.popupTimer = _setTimeout(function() {
        popup.show();
      }, delay);
    }
  }
  /**
   * Clears the popup timer for the tooltip.
   */
  clearPopupTimer() {
    if (this.popupTimer != null) {
      clearTimeout(this.popupTimer);
      this.popupTimer = null;
    }
  }
  /**
   * Set selected items by their id. Replaces the current selection
   * Unknown id's are silently ignored.
   * @param {string[] | string} [ids] An array with zero or more id's of the items to be
   *                                  selected, or a single item id. If ids is undefined
   *                                  or an empty array, all items will be unselected.
   */
  setSelection(ids) {
    var _context19;
    if (ids == void 0) {
      ids = [];
    }
    if (!_Array$isArray(ids)) {
      ids = [ids];
    }
    const idsToDeselect = _filterInstanceProperty(_context19 = this.selection).call(_context19, (id) => _indexOfInstanceProperty(ids).call(ids, id) === -1);
    for (let selectedId of idsToDeselect) {
      const item = this.getItemById(selectedId);
      if (item) {
        item.unselect();
      }
    }
    this.selection = [...ids];
    for (let id of ids) {
      const item = this.getItemById(id);
      if (item) {
        item.select();
      }
    }
  }
  /**
   * Get the selected items by their id
   * @return {Array} ids  The ids of the selected items
   */
  getSelection() {
    var _context20;
    return _concatInstanceProperty(_context20 = this.selection).call(_context20, []);
  }
  /**
   * Get the id's of the currently visible items.
   * @returns {Array} The ids of the visible items
   */
  getVisibleItems() {
    const range = this.body.range.getRange();
    let right;
    let left;
    if (this.options.rtl) {
      right = this.body.util.toScreen(range.start);
      left = this.body.util.toScreen(range.end);
    } else {
      left = this.body.util.toScreen(range.start);
      right = this.body.util.toScreen(range.end);
    }
    const ids = [];
    for (const groupId in this.groups) {
      if (!Object.prototype.hasOwnProperty.call(this.groups, groupId)) continue;
      const group = this.groups[groupId];
      const rawVisibleItems = group.isVisible ? group.visibleItems : [];
      for (const item of rawVisibleItems) {
        if (this.options.rtl) {
          if (item.right < left && item.right + item.width > right) {
            ids.push(item.id);
          }
        } else {
          if (item.left < right && item.left + item.width > left) {
            ids.push(item.id);
          }
        }
      }
    }
    return ids;
  }
  /**
   * Get the id's of the items at specific time, where a click takes place on the timeline.
   * @param {Date} timeOfEvent The point in time to query items.
   * @returns {Array} The ids of all items in existence at the time of click event on the timeline.
   */
  getItemsAtCurrentTime(timeOfEvent) {
    let right;
    let left;
    if (this.options.rtl) {
      right = this.body.util.toScreen(timeOfEvent);
      left = this.body.util.toScreen(timeOfEvent);
    } else {
      left = this.body.util.toScreen(timeOfEvent);
      right = this.body.util.toScreen(timeOfEvent);
    }
    const ids = [];
    for (const groupId in this.groups) {
      if (!Object.prototype.hasOwnProperty.call(this.groups, groupId)) continue;
      const group = this.groups[groupId];
      const rawVisibleItems = group.isVisible ? group.visibleItems : [];
      for (const item of rawVisibleItems) {
        if (this.options.rtl) {
          if (item.right < left && item.right + item.width > right) {
            ids.push(item.id);
          }
        } else {
          if (item.left < right && item.left + item.width > left) {
            ids.push(item.id);
          }
        }
      }
    }
    return ids;
  }
  /**
   * Get the id's of the currently visible groups.
   * @returns {Array} The ids of the visible groups
   */
  getVisibleGroups() {
    const ids = [];
    for (const groupId in this.groups) {
      if (!Object.prototype.hasOwnProperty.call(this.groups, groupId)) continue;
      const group = this.groups[groupId];
      if (group.isVisible) ids.push(groupId);
    }
    return ids;
  }
  /**
   * get item by id
   * @param {string} id
   * @return {object} item
   */
  getItemById(id) {
    var _context21;
    return this.items[id] || _findInstanceProperty(_context21 = this.clusters).call(_context21, (cluster) => cluster.id === id);
  }
  /**
   * Deselect a selected item
   * @param {string | number} id
   * @private
   */
  _deselect(id) {
    const selection = this.selection;
    for (let i = 0, ii = selection.length; i < ii; i++) {
      if (selection[i] == id) {
        _spliceInstanceProperty(selection).call(selection, i, 1);
        break;
      }
    }
  }
  /**
   * Repaint the component
   * @return {boolean} Returns true if the component is resized
   */
  redraw() {
    const margin = this.options.margin;
    const range = this.body.range;
    const asSize = availableUtils.option.asSize;
    const options = this.options;
    const orientation = options.orientation.item;
    let resized = false;
    const frame = this.dom.frame;
    this.props.top = this.body.domProps.top.height + this.body.domProps.border.top;
    if (this.options.rtl) {
      this.props.right = this.body.domProps.right.width + this.body.domProps.border.right;
    } else {
      this.props.left = this.body.domProps.left.width + this.body.domProps.border.left;
    }
    frame.className = "vis-itemset";
    if (this.options.cluster) {
      this._clusterItems();
    }
    resized = this._orderGroups() || resized;
    const visibleInterval = range.end - range.start;
    const zoomed = visibleInterval != this.lastVisibleInterval || this.props.width != this.props.lastWidth;
    const scrolled = range.start != this.lastRangeStart;
    const changedStackOption = options.stack != this.lastStack;
    const changedStackSubgroupsOption = options.stackSubgroups != this.lastStackSubgroups;
    const forceRestack = zoomed || scrolled || changedStackOption || changedStackSubgroupsOption;
    this.lastVisibleInterval = visibleInterval;
    this.lastRangeStart = range.start;
    this.lastStack = options.stack;
    this.lastStackSubgroups = options.stackSubgroups;
    this.props.lastWidth = this.props.width;
    const firstGroup = this._firstGroup();
    const firstMargin = {
      item: margin.item,
      axis: margin.axis
    };
    const nonFirstMargin = {
      item: margin.item,
      axis: margin.item.vertical / 2
    };
    let height = 0;
    const minHeight = margin.axis + margin.item.vertical;
    this.groups[BACKGROUND].redraw(range, nonFirstMargin, forceRestack);
    const redrawQueue = {};
    let redrawQueueLength = 0;
    _forEachInstanceProperty(availableUtils).call(availableUtils, this.groups, (group, key) => {
      if (key === BACKGROUND) return;
      const groupMargin = group == firstGroup ? firstMargin : nonFirstMargin;
      const returnQueue = true;
      redrawQueue[key] = group.redraw(range, groupMargin, forceRestack, returnQueue);
      redrawQueueLength = redrawQueue[key].length;
    });
    const needRedraw = redrawQueueLength > 0;
    if (needRedraw) {
      const redrawResults = {};
      for (let i = 0; i < redrawQueueLength; i++) {
        _forEachInstanceProperty(availableUtils).call(availableUtils, redrawQueue, (fns, key) => {
          redrawResults[key] = fns[i]();
        });
      }
      _forEachInstanceProperty(availableUtils).call(availableUtils, this.groups, (group, key) => {
        if (key === BACKGROUND) return;
        const groupResized = redrawResults[key];
        resized = groupResized || resized;
        height += group.height;
      });
      height = Math.max(height, minHeight);
    }
    height = Math.max(height, minHeight);
    frame.style.height = asSize(height);
    this.props.width = frame.offsetWidth;
    this.props.height = height;
    this.dom.axis.style.top = asSize(orientation == "top" ? this.body.domProps.top.height + this.body.domProps.border.top : this.body.domProps.top.height + this.body.domProps.centerContainer.height);
    if (this.options.rtl) {
      this.dom.axis.style.right = "0";
    } else {
      this.dom.axis.style.left = "0";
    }
    this.hammer.get("press").set({
      time: this.options.longSelectPressTime
    });
    this.initialItemSetDrawn = true;
    resized = this._isResized() || resized;
    return resized;
  }
  /**
   * Get the first group, aligned with the axis
   * @return {Group | null} firstGroup
   * @private
   */
  _firstGroup() {
    const firstGroupIndex = this.options.orientation.item == "top" ? 0 : this.groupIds.length - 1;
    const firstGroupId = this.groupIds[firstGroupIndex];
    const firstGroup = this.groups[firstGroupId] || this.groups[UNGROUPED$1];
    return firstGroup || null;
  }
  /**
   * Create or delete the group holding all ungrouped items. This group is used when
   * there are no groups specified.
   * @protected
   */
  _updateUngrouped() {
    let ungrouped = this.groups[UNGROUPED$1];
    let item;
    let itemId;
    if (this.groupsData) {
      if (ungrouped) {
        ungrouped.dispose();
        delete this.groups[UNGROUPED$1];
        for (itemId in this.items) {
          if (!Object.prototype.hasOwnProperty.call(this.items, itemId)) continue;
          item = this.items[itemId];
          item.parent && item.parent.remove(item);
          const groupId = this.getGroupId(item.data);
          const group = this.groups[groupId];
          group && group.add(item) || item.hide();
        }
      }
    } else {
      if (!ungrouped) {
        const id = null;
        const data = null;
        ungrouped = new Group(id, data, this);
        this.groups[UNGROUPED$1] = ungrouped;
        for (itemId in this.items) {
          if (!Object.prototype.hasOwnProperty.call(this.items, itemId)) continue;
          item = this.items[itemId];
          ungrouped.add(item);
        }
        ungrouped.show();
      }
    }
  }
  /**
   * Get the element for the labelset
   * @return {HTMLElement} labelSet
   */
  getLabelSet() {
    return this.dom.labelSet;
  }
  /**
   * Set items
   * @param {vis.DataSet | null} items
   */
  setItems(items) {
    this.itemsSettingTime = /* @__PURE__ */ new Date();
    const me = this;
    let ids;
    const oldItemsData = this.itemsData;
    if (!items) {
      this.itemsData = null;
    } else if (isDataViewLike(items)) {
      this.itemsData = typeCoerceDataSet(items);
    } else {
      throw new TypeError("Data must implement the interface of DataSet or DataView");
    }
    if (oldItemsData) {
      _forEachInstanceProperty(availableUtils).call(availableUtils, this.itemListeners, (callback, event2) => {
        oldItemsData.off(event2, callback);
      });
      oldItemsData.dispose();
      ids = oldItemsData.getIds();
      this._onRemove(ids);
    }
    if (this.itemsData) {
      const id = this.id;
      _forEachInstanceProperty(availableUtils).call(availableUtils, this.itemListeners, (callback, event2) => {
        me.itemsData.on(event2, callback, id);
      });
      ids = this.itemsData.getIds();
      this._onAdd(ids);
      this._updateUngrouped();
    }
    this.body.emitter.emit("_change", {
      queue: true
    });
  }
  /**
   * Get the current items
   * @returns {vis.DataSet | null}
   */
  getItems() {
    return this.itemsData != null ? this.itemsData.rawDS : null;
  }
  /**
   * Set groups
   * @param {vis.DataSet} groups
   */
  setGroups(groups) {
    const me = this;
    let ids;
    if (this.groupsData) {
      _forEachInstanceProperty(availableUtils).call(availableUtils, this.groupListeners, (callback, event2) => {
        me.groupsData.off(event2, callback);
      });
      ids = this.groupsData.getIds();
      this.groupsData = null;
      this._onRemoveGroups(ids);
    }
    if (!groups) {
      this.groupsData = null;
    } else if (isDataViewLike(groups)) {
      this.groupsData = groups;
    } else {
      throw new TypeError("Data must implement the interface of DataSet or DataView");
    }
    if (this.groupsData) {
      var _context22;
      const groupsData = this.groupsData.getDataSet();
      _forEachInstanceProperty(_context22 = groupsData.get()).call(_context22, (group) => {
        if (group.nestedGroups) {
          var _context23;
          _forEachInstanceProperty(_context23 = group.nestedGroups).call(_context23, (nestedGroupId) => {
            const updatedNestedGroup = groupsData.get(nestedGroupId);
            updatedNestedGroup.nestedInGroup = group.id;
            if (group.showNested == false) {
              updatedNestedGroup.visible = false;
            }
            groupsData.update(updatedNestedGroup);
          });
        }
      });
      const id = this.id;
      _forEachInstanceProperty(availableUtils).call(availableUtils, this.groupListeners, (callback, event2) => {
        me.groupsData.on(event2, callback, id);
      });
      ids = this.groupsData.getIds();
      this._onAddGroups(ids);
    }
    this._updateUngrouped();
    this._order();
    if (this.options.cluster) {
      this.clusterGenerator.updateData();
      this._clusterItems();
      this.markDirty({
        refreshItems: true,
        restackGroups: true
      });
    }
    this.body.emitter.emit("_change", {
      queue: true
    });
  }
  /**
   * Get the current groups
   * @returns {vis.DataSet | null} groups
   */
  getGroups() {
    return this.groupsData;
  }
  /**
   * Remove an item by its id
   * @param {string | number} id
   */
  removeItem(id) {
    const item = this.itemsData.get(id);
    if (item) {
      this.options.onRemove(item, (item2) => {
        if (item2) {
          this.itemsData.remove(id);
        }
      });
    }
  }
  /**
   * Get the time of an item based on it's data and options.type
   * @param {Object} itemData
   * @returns {string} Returns the type
   * @private
   */
  _getType(itemData) {
    return itemData.type || this.options.type || (itemData.end ? "range" : "box");
  }
  /**
   * Get the group id for an item
   * @param {Object} itemData
   * @returns {string} Returns the groupId
   * @private
   */
  getGroupId(itemData) {
    const type = this._getType(itemData);
    if (type == "background" && itemData.group == void 0) {
      return BACKGROUND;
    } else {
      return this.groupsData ? itemData.group : UNGROUPED$1;
    }
  }
  /**
   * Handle updated items
   * @param {number[]} ids
   * @protected
   */
  _onUpdate(ids) {
    const me = this;
    _forEachInstanceProperty(ids).call(ids, (id) => {
      const itemData = me.itemsData.get(id);
      let item = me.items[id];
      const type = itemData ? me._getType(itemData) : null;
      const constructor = _ItemSet.types[type];
      let selected;
      if (item) {
        if (!constructor || !(item instanceof constructor)) {
          selected = item.selected;
          me._removeItem(item);
          item = null;
        } else {
          me._updateItem(item, itemData);
        }
      }
      if (!item && itemData) {
        if (constructor) {
          item = new constructor(itemData, me.conversion, me.options);
          item.id = id;
          me._addItem(item);
          if (selected) {
            this.selection.push(id);
            item.select();
          }
        } else {
          throw new TypeError('Unknown item type "'.concat(type, '"'));
        }
      }
    });
    this._order();
    if (this.options.cluster) {
      this.clusterGenerator.setItems(this.items, {
        applyOnChangedLevel: false
      });
      this._clusterItems();
    }
    this.body.emitter.emit("_change", {
      queue: true
    });
  }
  /**
   * Handle removed items
   * @param {number[]} ids
   * @protected
   */
  _onRemove(ids) {
    let count = 0;
    const me = this;
    _forEachInstanceProperty(ids).call(ids, (id) => {
      const item = me.items[id];
      if (item) {
        count++;
        me._removeItem(item);
      }
    });
    if (count) {
      this._order();
      this.body.emitter.emit("_change", {
        queue: true
      });
    }
  }
  /**
   * Update the order of item in all groups
   * @private
   */
  _order() {
    _forEachInstanceProperty(availableUtils).call(availableUtils, this.groups, (group) => {
      group.order();
    });
  }
  /**
   * Handle updated groups
   * @param {number[]} ids
   * @private
   */
  _onUpdateGroups(ids) {
    this._onAddGroups(ids);
  }
  /**
   * Handle changed groups (added or updated)
   * @param {number[]} ids
   * @private
   */
  _onAddGroups(ids) {
    const me = this;
    _forEachInstanceProperty(ids).call(ids, (id) => {
      const groupData = me.groupsData.get(id);
      let group = me.groups[id];
      if (!group) {
        if (id == UNGROUPED$1 || id == BACKGROUND) {
          throw new Error("Illegal group id. ".concat(id, " is a reserved id."));
        }
        const groupOptions = _Object$create(me.options);
        availableUtils.extend(groupOptions, {
          height: null
        });
        group = new Group(id, groupData, me);
        me.groups[id] = group;
        for (const itemId in me.items) {
          if (!Object.prototype.hasOwnProperty.call(me.items, itemId)) continue;
          const item = me.items[itemId];
          if (item.data.group == id) group.add(item);
        }
        group.order();
        group.show();
      } else {
        group.setData(groupData);
      }
    });
    this.body.emitter.emit("_change", {
      queue: true
    });
  }
  /**
   * Handle removed groups
   * @param {number[]} ids
   * @private
   */
  _onRemoveGroups(ids) {
    _forEachInstanceProperty(ids).call(ids, (id) => {
      const group = this.groups[id];
      if (group) {
        group.dispose();
        delete this.groups[id];
      }
    });
    if (this.options.cluster) {
      this.clusterGenerator.updateData();
      this._clusterItems();
    }
    this.markDirty({
      restackGroups: !!this.options.cluster
    });
    this.body.emitter.emit("_change", {
      queue: true
    });
  }
  /**
   * Reorder the groups if needed
   * @return {boolean} changed
   * @private
   */
  _orderGroups() {
    if (this.groupsData) {
      let groupIds = this.groupsData.getIds({
        order: this.options.groupOrder
      });
      groupIds = this._orderNestedGroups(groupIds);
      const changed = !availableUtils.equalArray(groupIds, this.groupIds);
      if (changed) {
        const groups = this.groups;
        _forEachInstanceProperty(groupIds).call(groupIds, (groupId) => {
          groups[groupId].hide();
        });
        _forEachInstanceProperty(groupIds).call(groupIds, (groupId) => {
          groups[groupId].show();
        });
        this.groupIds = groupIds;
      }
      return changed;
    } else {
      return false;
    }
  }
  /**
   * Reorder the nested groups
   *
   * @param {Array.<number>} groupIds
   * @returns {Array.<number>}
   * @private
   */
  _orderNestedGroups(groupIds) {
    function getOrderedNestedGroups(t, groupIds2) {
      let result = [];
      _forEachInstanceProperty(groupIds2).call(groupIds2, (groupId) => {
        result.push(groupId);
        const groupData = t.groupsData.get(groupId);
        if (groupData.nestedGroups) {
          var _context24;
          const nestedGroupIds = _mapInstanceProperty(_context24 = t.groupsData.get({
            filter(nestedGroup) {
              return nestedGroup.nestedInGroup == groupId;
            },
            order: t.options.groupOrder
          })).call(_context24, (nestedGroup) => nestedGroup.id);
          result = _concatInstanceProperty(result).call(result, getOrderedNestedGroups(t, nestedGroupIds));
        }
      });
      return result;
    }
    const topGroupIds = _filterInstanceProperty(groupIds).call(groupIds, (groupId) => !this.groupsData.get(groupId).nestedInGroup);
    return getOrderedNestedGroups(this, topGroupIds);
  }
  /**
   * Add a new item
   * @param {Item} item
   * @private
   */
  _addItem(item) {
    this.items[item.id] = item;
    const groupId = this.getGroupId(item.data);
    const group = this.groups[groupId];
    if (!group) {
      item.groupShowing = false;
    } else if (group && group.data && group.data.showNested) {
      item.groupShowing = true;
    }
    if (group) group.add(item);
  }
  /**
   * Update an existing item
   * @param {Item} item
   * @param {Object} itemData
   * @private
   */
  _updateItem(item, itemData) {
    item.setData(itemData);
    const groupId = this.getGroupId(item.data);
    const group = this.groups[groupId];
    if (!group) {
      item.groupShowing = false;
    } else if (group && group.data && group.data.showNested) {
      item.groupShowing = true;
    }
  }
  /**
   * Delete an item from the ItemSet: remove it from the DOM, from the map
   * with items, and from the map with visible items, and from the selection
   * @param {Item} item
   * @private
   */
  _removeItem(item) {
    var _context25, _context26;
    item.hide();
    delete this.items[item.id];
    const index = _indexOfInstanceProperty(_context25 = this.selection).call(_context25, item.id);
    if (index != -1) _spliceInstanceProperty(_context26 = this.selection).call(_context26, index, 1);
    item.parent && item.parent.remove(item);
    if (this.popup != null) {
      this.popup.hide();
    }
  }
  /**
   * Create an array containing all items being a range (having an end date)
   * @param {Array.<Object>} array
   * @returns {Array}
   * @private
   */
  _constructByEndArray(array2) {
    const endArray = [];
    for (let i = 0; i < array2.length; i++) {
      if (array2[i] instanceof RangeItem) {
        endArray.push(array2[i]);
      }
    }
    return endArray;
  }
  /**
   * Register the clicked item on touch, before dragStart is initiated.
   *
   * dragStart is initiated from a mousemove event, AFTER the mouse/touch is
   * already moving. Therefore, the mouse/touch can sometimes be above an other
   * DOM element than the item itself.
   *
   * @param {Event} event
   * @private
   */
  _onTouch(event2) {
    this.touchParams.item = this.itemFromTarget(event2);
    this.touchParams.dragLeftItem = event2.target.dragLeftItem || false;
    this.touchParams.dragRightItem = event2.target.dragRightItem || false;
    this.touchParams.itemProps = null;
  }
  /**
   * Given an group id, returns the index it has.
   *
   * @param {number} groupId
   * @returns {number} index / groupId
   * @private
   */
  _getGroupIndex(groupId) {
    for (let i = 0; i < this.groupIds.length; i++) {
      if (groupId == this.groupIds[i]) return i;
    }
  }
  /**
   * Start dragging the selected events
   * @param {Event} event
   * @private
   */
  _onDragStart(event2) {
    if (this.touchParams.itemIsDragging) {
      return;
    }
    const item = this.touchParams.item || null;
    const me = this;
    let props;
    if (item && (item.selected || this.options.itemsAlwaysDraggable.item)) {
      if (this.options.editable.overrideItems && !this.options.editable.updateTime && !this.options.editable.updateGroup) {
        return;
      }
      if (item.editable != null && !item.editable.updateTime && !item.editable.updateGroup && !this.options.editable.overrideItems) {
        return;
      }
      const dragLeftItem = this.touchParams.dragLeftItem;
      const dragRightItem = this.touchParams.dragRightItem;
      this.touchParams.itemIsDragging = true;
      this.touchParams.selectedItem = item;
      if (dragLeftItem) {
        props = {
          item: dragLeftItem,
          initialX: event2.center.x,
          dragLeft: true,
          data: this._cloneItemData(item.data)
        };
        this.touchParams.itemProps = [props];
      } else if (dragRightItem) {
        props = {
          item: dragRightItem,
          initialX: event2.center.x,
          dragRight: true,
          data: this._cloneItemData(item.data)
        };
        this.touchParams.itemProps = [props];
      } else if (this.options.editable.add && (event2.srcEvent.ctrlKey || event2.srcEvent.metaKey)) {
        this._onDragStartAddItem(event2);
      } else {
        if (this.groupIds.length < 1) {
          this.redraw();
        }
        const baseGroupIndex = this._getGroupIndex(item.data.group);
        const itemsToDrag = this.options.itemsAlwaysDraggable.item && !item.selected ? [item.id] : this.getSelection();
        this.touchParams.itemProps = _mapInstanceProperty(itemsToDrag).call(itemsToDrag, (id) => {
          const item2 = me.items[id];
          const groupIndex = me._getGroupIndex(item2.data.group);
          return {
            item: item2,
            initialX: event2.center.x,
            groupOffset: baseGroupIndex - groupIndex,
            data: this._cloneItemData(item2.data)
          };
        });
      }
      event2.stopPropagation();
    } else if (this.options.editable.add && (event2.srcEvent.ctrlKey || event2.srcEvent.metaKey)) {
      this._onDragStartAddItem(event2);
    }
  }
  /**
   * Start creating a new range item by dragging.
   * @param {Event} event
   * @private
   */
  _onDragStartAddItem(event2) {
    const snap = this.options.snap || null;
    const frameRect = this.dom.frame.getBoundingClientRect();
    const x = this.options.rtl ? frameRect.right - event2.center.x + 10 : event2.center.x - frameRect.left - 10;
    const time = this.body.util.toTime(x);
    const scale = this.body.util.getScale();
    const step = this.body.util.getStep();
    const start = snap ? snap(time, scale, step) : time;
    const end = start;
    const itemData = {
      type: "range",
      start,
      end,
      content: "new item"
    };
    const id = v4();
    itemData[this.itemsData.idProp] = id;
    const group = this.groupFromTarget(event2);
    if (group) {
      itemData.group = group.groupId;
    }
    const newItem = new RangeItem(itemData, this.conversion, this.options);
    newItem.id = id;
    newItem.data = this._cloneItemData(itemData);
    this._addItem(newItem);
    this.touchParams.selectedItem = newItem;
    const props = {
      item: newItem,
      initialX: event2.center.x,
      data: newItem.data
    };
    if (this.options.rtl) {
      props.dragLeft = true;
    } else {
      props.dragRight = true;
    }
    this.touchParams.itemProps = [props];
    event2.stopPropagation();
  }
  /**
   * Drag selected items
   * @param {Event} event
   * @private
   */
  _onDrag(event2) {
    if (this.popup != null && this.options.showTooltips && !this.popup.hidden) {
      const container = this.body.dom.centerContainer;
      const containerRect = container.getBoundingClientRect();
      this.popup.setPosition(event2.center.x - containerRect.left + container.offsetLeft, event2.center.y - containerRect.top + container.offsetTop);
      this.popup.show();
    }
    if (this.touchParams.itemProps) {
      var _context27;
      event2.stopPropagation();
      const me = this;
      const snap = this.options.snap || null;
      const domRootOffsetLeft = this.body.dom.root.offsetLeft;
      const xOffset = this.options.rtl ? domRootOffsetLeft + this.body.domProps.right.width : domRootOffsetLeft + this.body.domProps.left.width;
      const scale = this.body.util.getScale();
      const step = this.body.util.getStep();
      const selectedItem = this.touchParams.selectedItem;
      const updateGroupAllowed = (this.options.editable.overrideItems || selectedItem.editable == null) && this.options.editable.updateGroup || !this.options.editable.overrideItems && selectedItem.editable != null && selectedItem.editable.updateGroup;
      let newGroupBase = null;
      if (updateGroupAllowed && selectedItem) {
        if (selectedItem.data.group != void 0) {
          const group = me.groupFromTarget(event2);
          if (group) {
            newGroupBase = this._getGroupIndex(group.groupId);
          }
        }
      }
      _forEachInstanceProperty(_context27 = this.touchParams.itemProps).call(_context27, (props) => {
        const current = me.body.util.toTime(event2.center.x - xOffset);
        const initial = me.body.util.toTime(props.initialX - xOffset);
        let offset;
        let initialStart;
        let initialEnd;
        let start;
        let end;
        if (this.options.rtl) {
          offset = -(current - initial);
        } else {
          offset = current - initial;
        }
        let itemData = this._cloneItemData(props.item.data);
        if (props.item.editable != null && !props.item.editable.updateTime && !props.item.editable.updateGroup && !me.options.editable.overrideItems) {
          return;
        }
        const updateTimeAllowed = (this.options.editable.overrideItems || selectedItem.editable == null) && this.options.editable.updateTime || !this.options.editable.overrideItems && selectedItem.editable != null && selectedItem.editable.updateTime;
        if (updateTimeAllowed) {
          if (props.dragLeft) {
            if (this.options.rtl) {
              if (itemData.end != void 0) {
                initialEnd = availableUtils.convert(props.data.end, "Date");
                end = new Date(initialEnd.valueOf() + offset);
                itemData.end = snap ? snap(end, scale, step) : end;
              }
            } else {
              if (itemData.start != void 0) {
                initialStart = availableUtils.convert(props.data.start, "Date");
                start = new Date(initialStart.valueOf() + offset);
                itemData.start = snap ? snap(start, scale, step) : start;
              }
            }
          } else if (props.dragRight) {
            if (this.options.rtl) {
              if (itemData.start != void 0) {
                initialStart = availableUtils.convert(props.data.start, "Date");
                start = new Date(initialStart.valueOf() + offset);
                itemData.start = snap ? snap(start, scale, step) : start;
              }
            } else {
              if (itemData.end != void 0) {
                initialEnd = availableUtils.convert(props.data.end, "Date");
                end = new Date(initialEnd.valueOf() + offset);
                itemData.end = snap ? snap(end, scale, step) : end;
              }
            }
          } else {
            if (itemData.start != void 0) {
              initialStart = availableUtils.convert(props.data.start, "Date").valueOf();
              start = new Date(initialStart + offset);
              if (itemData.end != void 0) {
                initialEnd = availableUtils.convert(props.data.end, "Date");
                const duration = initialEnd.valueOf() - initialStart.valueOf();
                itemData.start = snap ? snap(start, scale, step) : start;
                itemData.end = new Date(itemData.start.valueOf() + duration);
              } else {
                itemData.start = snap ? snap(start, scale, step) : start;
              }
            }
          }
        }
        if (updateGroupAllowed && !props.dragLeft && !props.dragRight && newGroupBase != null) {
          if (itemData.group != void 0) {
            let newOffset = newGroupBase - props.groupOffset;
            newOffset = Math.max(0, newOffset);
            newOffset = Math.min(me.groupIds.length - 1, newOffset);
            itemData.group = me.groupIds[newOffset];
          }
        }
        itemData = this._cloneItemData(itemData);
        me.options.onMoving(itemData, (itemData2) => {
          if (itemData2) {
            props.item.setData(this._cloneItemData(itemData2, "Date"));
          }
        });
      });
      this.body.emitter.emit("_change");
    }
  }
  /**
   * Move an item to another group
   * @param {Item} item
   * @param {string | number} groupId
   * @private
   */
  _moveToGroup(item, groupId) {
    const group = this.groups[groupId];
    if (group && group.groupId != item.data.group) {
      const oldGroup = item.parent;
      oldGroup.remove(item);
      oldGroup.order();
      item.data.group = group.groupId;
      group.add(item);
      group.order();
    }
  }
  /**
   * End of dragging selected items
   * @param {Event} event
   * @private
   */
  _onDragEnd(event2) {
    this.touchParams.itemIsDragging = false;
    if (this.touchParams.itemProps) {
      event2.stopPropagation();
      const me = this;
      const itemProps = this.touchParams.itemProps;
      this.touchParams.itemProps = null;
      _forEachInstanceProperty(itemProps).call(itemProps, (props) => {
        const id = props.item.id;
        const exists = me.itemsData.get(id) != null;
        if (!exists) {
          me.options.onAdd(props.item.data, (itemData) => {
            me._removeItem(props.item);
            if (itemData) {
              me.itemsData.add(itemData);
            }
            me.body.emitter.emit("_change");
          });
        } else {
          const itemData = this._cloneItemData(props.item.data);
          me.options.onMove(itemData, (itemData2) => {
            if (itemData2) {
              itemData2[this.itemsData.idProp] = id;
              this.itemsData.update(itemData2);
            } else {
              props.item.setData(props.data);
              me.body.emitter.emit("_change");
            }
          });
        }
      });
    }
  }
  /**
   * On group click
   * @param {Event} event
   * @private
   */
  _onGroupClick(event2) {
    const group = this.groupFromTarget(event2);
    _setTimeout(() => {
      this.toggleGroupShowNested(group);
    }, 1);
  }
  /**
   * Toggle show nested
   * @param {object} group
   * @param {boolean} force
   */
  toggleGroupShowNested(group) {
    let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
    if (!group || !group.nestedGroups) return;
    const groupsData = this.groupsData.getDataSet();
    if (force != void 0) {
      group.showNested = !!force;
    } else {
      group.showNested = !group.showNested;
    }
    let nestingGroup = groupsData.get(group.groupId);
    nestingGroup.showNested = group.showNested;
    let fullNestedGroups = group.nestedGroups;
    let nextLevel = fullNestedGroups;
    while (nextLevel.length > 0) {
      let current = nextLevel;
      nextLevel = [];
      for (let i = 0; i < current.length; i++) {
        let node = groupsData.get(current[i]);
        if (node.nestedGroups) {
          nextLevel = _concatInstanceProperty(nextLevel).call(nextLevel, node.nestedGroups);
        }
      }
      if (nextLevel.length > 0) {
        fullNestedGroups = _concatInstanceProperty(fullNestedGroups).call(fullNestedGroups, nextLevel);
      }
    }
    var nestedGroups;
    if (nestingGroup.showNested) {
      var showNestedGroups = groupsData.get(nestingGroup.nestedGroups);
      for (let i = 0; i < showNestedGroups.length; i++) {
        let group2 = showNestedGroups[i];
        if (group2.nestedGroups && group2.nestedGroups.length > 0 && (group2.showNested == void 0 || group2.showNested == true)) {
          showNestedGroups.push(...groupsData.get(group2.nestedGroups));
        }
      }
      nestedGroups = _mapInstanceProperty(showNestedGroups).call(showNestedGroups, function(nestedGroup) {
        if (nestedGroup.visible == void 0) {
          nestedGroup.visible = true;
        }
        nestedGroup.visible = !!nestingGroup.showNested;
        return nestedGroup;
      });
    } else {
      var _context28;
      nestedGroups = _mapInstanceProperty(_context28 = groupsData.get(fullNestedGroups)).call(_context28, function(nestedGroup) {
        if (nestedGroup.visible == void 0) {
          nestedGroup.visible = true;
        }
        nestedGroup.visible = !!nestingGroup.showNested;
        return nestedGroup;
      });
    }
    groupsData.update(_concatInstanceProperty(nestedGroups).call(nestedGroups, nestingGroup));
    if (nestingGroup.showNested) {
      availableUtils.removeClassName(group.dom.label, "collapsed");
      availableUtils.addClassName(group.dom.label, "expanded");
    } else {
      availableUtils.removeClassName(group.dom.label, "expanded");
      availableUtils.addClassName(group.dom.label, "collapsed");
    }
  }
  /**
   * Toggle group drag classname
   * @param {object} group
   */
  toggleGroupDragClassName(group) {
    group.dom.label.classList.toggle("vis-group-is-dragging");
    group.dom.foreground.classList.toggle("vis-group-is-dragging");
  }
  /**
   * on drag start
   * @param {Event} event
   * @return {void}
   * @private
   */
  _onGroupDragStart(event2) {
    if (this.groupTouchParams.isDragging) return;
    if (this.options.groupEditable.order) {
      this.groupTouchParams.group = this.groupFromTarget(event2);
      if (this.groupTouchParams.group) {
        event2.stopPropagation();
        this.groupTouchParams.isDragging = true;
        this.toggleGroupDragClassName(this.groupTouchParams.group);
        this.groupTouchParams.originalOrder = this.groupsData.getIds({
          order: this.options.groupOrder
        });
      }
    }
  }
  /**
   * on drag
   * @param {Event} event
   * @return {void}
   * @private
   */
  _onGroupDrag(event2) {
    if (this.options.groupEditable.order && this.groupTouchParams.group) {
      event2.stopPropagation();
      const groupsData = this.groupsData.getDataSet();
      const group = this.groupFromTarget(event2);
      if (group && group.height != this.groupTouchParams.group.height) {
        const movingUp = group.top < this.groupTouchParams.group.top;
        const clientY = event2.center ? event2.center.y : event2.clientY;
        const targetGroup = group.dom.foreground.getBoundingClientRect();
        const draggedGroupHeight = this.groupTouchParams.group.height;
        if (movingUp) {
          if (targetGroup.top + draggedGroupHeight < clientY) {
            return;
          }
        } else {
          const targetGroupHeight = group.height;
          if (targetGroup.top + targetGroupHeight - draggedGroupHeight > clientY) {
            return;
          }
        }
      }
      if (group && group != this.groupTouchParams.group) {
        const targetGroup = groupsData.get(group.groupId);
        const draggedGroup = groupsData.get(this.groupTouchParams.group.groupId);
        if (draggedGroup && targetGroup) {
          this.options.groupOrderSwap(draggedGroup, targetGroup, groupsData);
          groupsData.update(draggedGroup);
          groupsData.update(targetGroup);
        }
        const newOrder = groupsData.getIds({
          order: this.options.groupOrder
        });
        if (!availableUtils.equalArray(newOrder, this.groupTouchParams.originalOrder)) {
          const origOrder = this.groupTouchParams.originalOrder;
          const draggedId = this.groupTouchParams.group.groupId;
          const numGroups = Math.min(origOrder.length, newOrder.length);
          let curPos = 0;
          let newOffset = 0;
          let orgOffset = 0;
          while (curPos < numGroups) {
            while (curPos + newOffset < numGroups && curPos + orgOffset < numGroups && newOrder[curPos + newOffset] == origOrder[curPos + orgOffset]) {
              curPos++;
            }
            if (curPos + newOffset >= numGroups) {
              break;
            }
            if (newOrder[curPos + newOffset] == draggedId) {
              newOffset = 1;
            } else if (origOrder[curPos + orgOffset] == draggedId) {
              orgOffset = 1;
            } else {
              const slippedPosition = _indexOfInstanceProperty(newOrder).call(newOrder, origOrder[curPos + orgOffset]);
              const switchGroup = groupsData.get(newOrder[curPos + newOffset]);
              const shouldBeGroup = groupsData.get(origOrder[curPos + orgOffset]);
              this.options.groupOrderSwap(switchGroup, shouldBeGroup, groupsData);
              groupsData.update(switchGroup);
              groupsData.update(shouldBeGroup);
              const switchGroupId = newOrder[curPos + newOffset];
              newOrder[curPos + newOffset] = origOrder[curPos + orgOffset];
              newOrder[slippedPosition] = switchGroupId;
              curPos++;
            }
          }
        }
      }
    }
  }
  /**
   * on drag end
   * @param {Event} event
   * @return {void}
   * @private
   */
  _onGroupDragEnd(event2) {
    this.groupTouchParams.isDragging = false;
    if (this.options.groupEditable.order && this.groupTouchParams.group) {
      event2.stopPropagation();
      const me = this;
      const id = me.groupTouchParams.group.groupId;
      const dataset = me.groupsData.getDataSet();
      const groupData = availableUtils.extend({}, dataset.get(id));
      me.options.onMoveGroup(groupData, (groupData2) => {
        if (groupData2) {
          groupData2[dataset._idProp] = id;
          dataset.update(groupData2);
        } else {
          const newOrder = dataset.getIds({
            order: me.options.groupOrder
          });
          if (!availableUtils.equalArray(newOrder, me.groupTouchParams.originalOrder)) {
            const origOrder = me.groupTouchParams.originalOrder;
            const numGroups = Math.min(origOrder.length, newOrder.length);
            let curPos = 0;
            while (curPos < numGroups) {
              while (curPos < numGroups && newOrder[curPos] == origOrder[curPos]) {
                curPos++;
              }
              if (curPos >= numGroups) {
                break;
              }
              const slippedPosition = _indexOfInstanceProperty(newOrder).call(newOrder, origOrder[curPos]);
              const switchGroup = dataset.get(newOrder[curPos]);
              const shouldBeGroup = dataset.get(origOrder[curPos]);
              me.options.groupOrderSwap(switchGroup, shouldBeGroup, dataset);
              dataset.update(switchGroup);
              dataset.update(shouldBeGroup);
              const switchGroupId = newOrder[curPos];
              newOrder[curPos] = origOrder[curPos];
              newOrder[slippedPosition] = switchGroupId;
              curPos++;
            }
          }
        }
      });
      me.body.emitter.emit("groupDragged", {
        groupId: id
      });
      this.toggleGroupDragClassName(this.groupTouchParams.group);
      this.groupTouchParams.group = null;
    }
  }
  /**
   * Handle selecting/deselecting an item when tapping it
   * @param {Event} event
   * @private
   */
  _onSelectItem(event2) {
    if (!this.options.selectable) return;
    const ctrlKey = event2.srcEvent && (event2.srcEvent.ctrlKey || event2.srcEvent.metaKey);
    const shiftKey = event2.srcEvent && event2.srcEvent.shiftKey;
    if (ctrlKey || shiftKey) {
      this._onMultiSelectItem(event2);
      return;
    }
    const oldSelection = this.getSelection();
    const item = this.itemFromTarget(event2);
    const selection = item && item.selectable ? [item.id] : [];
    this.setSelection(selection);
    const newSelection = this.getSelection();
    if (newSelection.length > 0 || oldSelection.length > 0) {
      this.body.emitter.emit("select", {
        items: newSelection,
        event: event2
      });
    }
  }
  /**
   * Handle hovering an item
   * @param {Event} event
   * @private
   */
  _onMouseOver(event2) {
    const item = this.itemFromTarget(event2);
    if (!item) return;
    const related = this.itemFromRelatedTarget(event2);
    if (item === related) {
      return;
    }
    const title = item.getTitle();
    if (this.options.showTooltips && title) {
      if (this.popup == null) {
        this.popup = new Popup2(this.body.dom.root, this.options.tooltip.overflowMethod || "flip");
      }
      this.popup.setText(title);
      const container = this.body.dom.centerContainer;
      const containerRect = container.getBoundingClientRect();
      this.popup.setPosition(event2.clientX - containerRect.left + container.offsetLeft, event2.clientY - containerRect.top + container.offsetTop);
      this.setPopupTimer(this.popup);
    } else {
      this.clearPopupTimer();
      if (this.popup != null) {
        this.popup.hide();
      }
    }
    this.body.emitter.emit("itemover", {
      item: item.id,
      event: event2
    });
  }
  /**
   * on mouse start
   * @param {Event} event
   * @return {void}
   * @private
   */
  _onMouseOut(event2) {
    const item = this.itemFromTarget(event2);
    if (!item) return;
    const related = this.itemFromRelatedTarget(event2);
    if (item === related) {
      return;
    }
    this.clearPopupTimer();
    if (this.popup != null) {
      this.popup.hide();
    }
    this.body.emitter.emit("itemout", {
      item: item.id,
      event: event2
    });
  }
  /**
   * on mouse move
   * @param {Event} event
   * @return {void}
   * @private
   */
  _onMouseMove(event2) {
    const item = this.itemFromTarget(event2);
    if (!item) return;
    if (this.popupTimer != null) {
      this.setPopupTimer(this.popup);
    }
    if (this.options.showTooltips && this.options.tooltip.followMouse && this.popup && !this.popup.hidden) {
      const container = this.body.dom.centerContainer;
      const containerRect = container.getBoundingClientRect();
      this.popup.setPosition(event2.clientX - containerRect.left + container.offsetLeft, event2.clientY - containerRect.top + container.offsetTop);
      this.popup.show();
    }
  }
  /**
   * Handle mousewheel
   * @param {Event}  event   The event
   * @private
   */
  _onMouseWheel(event2) {
    if (this.touchParams.itemIsDragging) {
      this._onDragEnd(event2);
    }
  }
  /**
   * Handle updates of an item on double tap
   * @param {timeline.Item}  item   The item
   * @private
   */
  _onUpdateItem(item) {
    if (!this.options.selectable) return;
    if (!this.options.editable.updateTime && !this.options.editable.updateGroup) return;
    const me = this;
    if (item) {
      const itemData = me.itemsData.get(item.id);
      this.options.onUpdate(itemData, (itemData2) => {
        if (itemData2) {
          me.itemsData.update(itemData2);
        }
      });
    }
  }
  /**
   * Handle drop event of data on item
   * Only called when `objectData.target === 'item'.
   * @param {Event} event The event
   * @private
   */
  _onDropObjectOnItem(event2) {
    const item = this.itemFromTarget(event2);
    const objectData = JSON.parse(event2.dataTransfer.getData("text"));
    this.options.onDropObjectOnItem(objectData, item);
  }
  /**
   * Handle creation of an item on double tap or drop of a drag event
   * @param {Event} event   The event
   * @private
   */
  _onAddItem(event2) {
    if (!this.options.selectable) return;
    if (!this.options.editable.add) return;
    const me = this;
    const snap = this.options.snap || null;
    const frameRect = this.dom.frame.getBoundingClientRect();
    const x = this.options.rtl ? frameRect.right - event2.center.x : event2.center.x - frameRect.left;
    const start = this.body.util.toTime(x);
    const scale = this.body.util.getScale();
    const step = this.body.util.getStep();
    let end;
    let newItemData;
    if (event2.type == "drop") {
      newItemData = JSON.parse(event2.dataTransfer.getData("text"));
      newItemData.content = newItemData.content ? newItemData.content : "new item";
      newItemData.start = newItemData.start ? newItemData.start : snap ? snap(start, scale, step) : start;
      newItemData.type = newItemData.type || "box";
      newItemData[this.itemsData.idProp] = newItemData.id || v4();
      if (newItemData.type == "range" && !newItemData.end) {
        end = this.body.util.toTime(x + this.props.width / 5);
        newItemData.end = snap ? snap(end, scale, step) : end;
      }
    } else {
      newItemData = {
        start: snap ? snap(start, scale, step) : start,
        content: "new item"
      };
      newItemData[this.itemsData.idProp] = v4();
      if (this.options.type === "range") {
        end = this.body.util.toTime(x + this.props.width / 5);
        newItemData.end = snap ? snap(end, scale, step) : end;
      }
    }
    const group = this.groupFromTarget(event2);
    if (group) {
      newItemData.group = group.groupId;
    }
    newItemData = this._cloneItemData(newItemData);
    this.options.onAdd(newItemData, (item) => {
      if (item) {
        me.itemsData.add(item);
        if (event2.type == "drop") {
          me.setSelection([item.id]);
        }
      }
    });
  }
  /**
   * Handle selecting/deselecting multiple items when holding an item
   * @param {Event} event
   * @private
   */
  _onMultiSelectItem(event2) {
    if (!this.options.selectable) return;
    const item = this.itemFromTarget(event2);
    if (item) {
      let selection = this.options.multiselect ? this.getSelection() : [];
      const shiftKey = event2.srcEvent && event2.srcEvent.shiftKey || false;
      if ((shiftKey || this.options.sequentialSelection) && this.options.multiselect) {
        const itemGroup = this.itemsData.get(item.id).group;
        let lastSelectedGroup = void 0;
        if (this.options.multiselectPerGroup) {
          if (selection.length > 0) {
            lastSelectedGroup = this.itemsData.get(selection[0]).group;
          }
        }
        if (!this.options.multiselectPerGroup || lastSelectedGroup == void 0 || lastSelectedGroup == itemGroup) {
          selection.push(item.id);
        }
        const range = _ItemSet._getItemRange(this.itemsData.get(selection));
        if (!this.options.multiselectPerGroup || lastSelectedGroup == itemGroup) {
          selection = [];
          for (const id in this.items) {
            if (!Object.prototype.hasOwnProperty.call(this.items, id)) continue;
            const _item = this.items[id];
            const start = _item.data.start;
            const end = _item.data.end !== void 0 ? _item.data.end : start;
            if (start >= range.min && end <= range.max && (!this.options.multiselectPerGroup || lastSelectedGroup == this.itemsData.get(_item.id).group) && !(_item instanceof BackgroundItem)) {
              selection.push(_item.id);
            }
          }
        }
      } else {
        const index = _indexOfInstanceProperty(selection).call(selection, item.id);
        if (index == -1) {
          selection.push(item.id);
        } else {
          _spliceInstanceProperty(selection).call(selection, index, 1);
        }
      }
      const filteredSelection = _filterInstanceProperty(selection).call(selection, (item2) => this.getItemById(item2).selectable);
      this.setSelection(filteredSelection);
      this.body.emitter.emit("select", {
        items: this.getSelection(),
        event: event2
      });
    }
  }
  /**
   * Calculate the time range of a list of items
   * @param {Array.<Object>} itemsData
   * @return {{min: Date, max: Date}} Returns the range of the provided items
   * @private
   */
  static _getItemRange(itemsData) {
    let max = null;
    let min = null;
    _forEachInstanceProperty(itemsData).call(itemsData, (data) => {
      if (min == null || data.start < min) {
        min = data.start;
      }
      if (data.end != void 0) {
        if (max == null || data.end > max) {
          max = data.end;
        }
      } else {
        if (max == null || data.start > max) {
          max = data.start;
        }
      }
    });
    return {
      min,
      max
    };
  }
  /**
   * Find an item from an element:
   * searches for the attribute 'vis-item' in the element's tree
   * @param {HTMLElement} element
   * @return {Item | null} item
   */
  itemFromElement(element) {
    let cur = element;
    while (cur) {
      if (Object.prototype.hasOwnProperty.call(cur, "vis-item")) {
        return cur["vis-item"];
      }
      cur = cur.parentNode;
    }
    return null;
  }
  /**
   * Find an item from an event target:
   * searches for the attribute 'vis-item' in the event target's element tree
   * @param {Event} event
   * @return {Item | null} item
   */
  itemFromTarget(event2) {
    return this.itemFromElement(event2.target);
  }
  /**
   * Find an item from an event's related target:
   * searches for the attribute 'vis-item' in the related target's element tree
   * @param {Event} event
   * @return {Item | null} item
   */
  itemFromRelatedTarget(event2) {
    return this.itemFromElement(event2.relatedTarget);
  }
  /**
   * Find the Group from an event target:
   * searches for the attribute 'vis-group' in the event target's element tree
   * @param {Event} event
   * @return {Group | null} group
   */
  groupFromTarget(event2) {
    const clientY = event2.center ? event2.center.y : event2.clientY;
    let groupIds = this.groupIds;
    if (groupIds.length <= 0 && this.groupsData) {
      groupIds = this.groupsData.getIds({
        order: this.options.groupOrder
      });
    }
    for (let i = 0; i < groupIds.length; i++) {
      const groupId = groupIds[i];
      const group = this.groups[groupId];
      const foreground = group.dom.foreground;
      const foregroundRect = foreground.getBoundingClientRect();
      if (clientY >= foregroundRect.top && clientY < foregroundRect.top + foreground.offsetHeight) {
        return group;
      }
      if (this.options.orientation.item === "top") {
        if (i === this.groupIds.length - 1 && clientY > foregroundRect.top) {
          return group;
        }
      } else {
        if (i === 0 && clientY < foregroundRect.top + foreground.offset) {
          return group;
        }
      }
    }
    return null;
  }
  /**
   * Find the ItemSet from an event target:
   * searches for the attribute 'vis-itemset' in the event target's element tree
   * @param {Event} event
   * @return {ItemSet | null} item
   */
  static itemSetFromTarget(event2) {
    let target = event2.target;
    while (target) {
      if (Object.prototype.hasOwnProperty.call(target, "vis-itemset")) {
        return target["vis-itemset"];
      }
      target = target.parentNode;
    }
    return null;
  }
  /**
   * Clone the data of an item, and "normalize" it: convert the start and end date
   * to the type (Date, Moment, ...) configured in the DataSet. If not configured,
   * start and end are converted to Date.
   * @param {Object} itemData, typically `item.data`
   * @param {string} [type]  Optional Date type. If not provided, the type from the DataSet is taken
   * @return {Object} The cloned object
   * @private
   */
  _cloneItemData(itemData, type) {
    const clone2 = availableUtils.extend({}, itemData);
    if (!type) {
      type = this.itemsData.type;
    }
    if (clone2.start != void 0) {
      clone2.start = availableUtils.convert(clone2.start, type && type.start || "Date");
    }
    if (clone2.end != void 0) {
      clone2.end = availableUtils.convert(clone2.end, type && type.end || "Date");
    }
    return clone2;
  }
  /**
   * cluster items
   * @return {void}
   * @private
   */
  _clusterItems() {
    if (!this.options.cluster) {
      return;
    }
    const {
      scale
    } = this.body.range.conversion(this.body.domProps.center.width);
    const clusters = this.clusterGenerator.getClusters(this.clusters, scale, this.options.cluster);
    if (this.clusters != clusters) {
      this._detachAllClusters();
      if (clusters) {
        for (let cluster of clusters) {
          cluster.attach();
        }
        this.clusters = clusters;
      }
      this._updateClusters(clusters);
    }
  }
  /**
   * detach all cluster items
   * @private
   */
  _detachAllClusters() {
    if (this.options.cluster) {
      if (this.clusters && this.clusters.length) {
        for (let cluster of this.clusters) {
          cluster.detach();
        }
      }
    }
  }
  /**
   * update clusters
   * @param {array} clusters
   * @private
   */
  _updateClusters(clusters) {
    if (this.clusters && this.clusters.length) {
      var _context29;
      const newClustersIds = new _Set(_mapInstanceProperty(clusters).call(clusters, (cluster) => cluster.id));
      const clustersToUnselect = _filterInstanceProperty(_context29 = this.clusters).call(_context29, (cluster) => !newClustersIds.has(cluster.id));
      let selectionChanged = false;
      for (let cluster of clustersToUnselect) {
        var _context30;
        const selectedIdx = _indexOfInstanceProperty(_context30 = this.selection).call(_context30, cluster.id);
        if (selectedIdx !== -1) {
          var _context31;
          cluster.unselect();
          _spliceInstanceProperty(_context31 = this.selection).call(_context31, selectedIdx, 1);
          selectionChanged = true;
        }
      }
      if (selectionChanged) {
        const newSelection = this.getSelection();
        this.body.emitter.emit("select", {
          items: newSelection,
          event
        });
      }
    }
    this.clusters = clusters || [];
  }
};
ItemSet.types = {
  background: BackgroundItem,
  box: BoxItem,
  range: RangeItem,
  point: PointItem
};
ItemSet.prototype._onAdd = ItemSet.prototype._onUpdate;
var errorFound = false;
var allOptions$2;
var printStyle = "background: #FFeeee; color: #dd0000";
var Validator2 = class _Validator {
  /**
   * @ignore
   */
  constructor() {
  }
  /**
   * Main function to be called
   * @param {Object} options
   * @param {Object} referenceOptions
   * @param {Object} subObject
   * @returns {boolean}
   * @static
   */
  static validate(options, referenceOptions, subObject) {
    errorFound = false;
    allOptions$2 = referenceOptions;
    let usedOptions = referenceOptions;
    if (subObject !== void 0) {
      usedOptions = referenceOptions[subObject];
    }
    _Validator.parse(options, usedOptions, []);
    return errorFound;
  }
  /**
   * Will traverse an object recursively and check every value
   * @param {Object} options
   * @param {Object} referenceOptions
   * @param {array} path    | where to look for the actual option
   * @static
   */
  static parse(options, referenceOptions, path2) {
    for (let option2 in options) {
      if (!Object.prototype.hasOwnProperty.call(options, option2)) continue;
      _Validator.check(option2, options, referenceOptions, path2);
    }
  }
  /**
   * Check every value. If the value is an object, call the parse function on that object.
   * @param {string} option
   * @param {Object} options
   * @param {Object} referenceOptions
   * @param {array} path    | where to look for the actual option
   * @static
   */
  static check(option2, options, referenceOptions, path2) {
    if (referenceOptions[option2] === void 0 && referenceOptions.__any__ === void 0) {
      _Validator.getSuggestion(option2, referenceOptions, path2);
      return;
    }
    let referenceOption = option2;
    let is_object = true;
    if (referenceOptions[option2] === void 0 && referenceOptions.__any__ !== void 0) {
      referenceOption = "__any__";
      is_object = _Validator.getType(options[option2]) === "object";
    }
    let refOptionObj = referenceOptions[referenceOption];
    if (is_object && refOptionObj.__type__ !== void 0) {
      refOptionObj = refOptionObj.__type__;
    }
    _Validator.checkFields(option2, options, referenceOptions, referenceOption, refOptionObj, path2);
  }
  /**
   *
   * @param {string}  option           | the option property
   * @param {Object}  options          | The supplied options object
   * @param {Object}  referenceOptions | The reference options containing all options and their allowed formats
   * @param {string}  referenceOption  | Usually this is the same as option, except when handling an __any__ tag.
   * @param {string}  refOptionObj     | This is the type object from the reference options
   * @param {Array}   path             | where in the object is the option
   * @static
   */
  static checkFields(option2, options, referenceOptions, referenceOption, refOptionObj, path2) {
    let log = function(message) {
      console.log("%c" + message + _Validator.printLocation(path2, option2), printStyle);
    };
    let optionType = _Validator.getType(options[option2]);
    let refOptionType = refOptionObj[optionType];
    if (refOptionType !== void 0) {
      if (_Validator.getType(refOptionType) === "array" && _indexOfInstanceProperty(refOptionType).call(refOptionType, options[option2]) === -1) {
        log('Invalid option detected in "' + option2 + '". Allowed values are:' + _Validator.print(refOptionType) + ' not "' + options[option2] + '". ');
        errorFound = true;
      } else if (optionType === "object" && referenceOption !== "__any__") {
        path2 = availableUtils.copyAndExtendArray(path2, option2);
        _Validator.parse(options[option2], referenceOptions[referenceOption], path2);
      }
    } else if (refOptionObj["any"] === void 0) {
      log('Invalid type received for "' + option2 + '". Expected: ' + _Validator.print(_Object$keys(refOptionObj)) + ". Received [" + optionType + '] "' + options[option2] + '"');
      errorFound = true;
    }
  }
  /**
   *
   * @param {Object|boolean|number|string|Array.<number>|Date|Node|Moment|undefined|null} object
   * @returns {string}
   * @static
   */
  static getType(object2) {
    var type = typeof object2;
    if (type === "object") {
      if (object2 === null) {
        return "null";
      }
      if (object2 instanceof Boolean) {
        return "boolean";
      }
      if (object2 instanceof Number) {
        return "number";
      }
      if (object2 instanceof String) {
        return "string";
      }
      if (_Array$isArray(object2)) {
        return "array";
      }
      if (object2 instanceof Date) {
        return "date";
      }
      if (object2.nodeType !== void 0) {
        return "dom";
      }
      if (object2._isAMomentObject === true) {
        return "moment";
      }
      return "object";
    } else if (type === "number") {
      return "number";
    } else if (type === "boolean") {
      return "boolean";
    } else if (type === "string") {
      return "string";
    } else if (type === void 0) {
      return "undefined";
    }
    return type;
  }
  /**
   * @param {string} option
   * @param {Object} options
   * @param {Array.<string>} path
   * @static
   */
  static getSuggestion(option2, options, path2) {
    let localSearch = _Validator.findInOptions(option2, options, path2, false);
    let globalSearch = _Validator.findInOptions(option2, allOptions$2, [], true);
    let localSearchThreshold = 8;
    let globalSearchThreshold = 4;
    let msg;
    if (localSearch.indexMatch !== void 0) {
      msg = " in " + _Validator.printLocation(localSearch.path, option2, "") + 'Perhaps it was incomplete? Did you mean: "' + localSearch.indexMatch + '"?\n\n';
    } else if (globalSearch.distance <= globalSearchThreshold && localSearch.distance > globalSearch.distance) {
      msg = " in " + _Validator.printLocation(localSearch.path, option2, "") + "Perhaps it was misplaced? Matching option found at: " + _Validator.printLocation(globalSearch.path, globalSearch.closestMatch, "");
    } else if (localSearch.distance <= localSearchThreshold) {
      msg = '. Did you mean "' + localSearch.closestMatch + '"?' + _Validator.printLocation(localSearch.path, option2);
    } else {
      msg = ". Did you mean one of these: " + _Validator.print(_Object$keys(options)) + _Validator.printLocation(path2, option2);
    }
    console.log('%cUnknown option detected: "' + option2 + '"' + msg, printStyle);
    errorFound = true;
  }
  /**
   * traverse the options in search for a match.
   * @param {string} option
   * @param {Object} options
   * @param {Array} path    | where to look for the actual option
   * @param {boolean} [recursive=false]
   * @returns {{closestMatch: string, path: Array, distance: number}}
   * @static
   */
  static findInOptions(option2, options, path2) {
    let recursive = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    let min = 1e9;
    let closestMatch = "";
    let closestMatchPath = [];
    let lowerCaseOption = option2.toLowerCase();
    let indexMatch = void 0;
    for (let op in options) {
      if (!Object.prototype.hasOwnProperty.call(options, op)) continue;
      let distance;
      if (options[op].__type__ !== void 0 && recursive === true) {
        let result = _Validator.findInOptions(option2, options[op], availableUtils.copyAndExtendArray(path2, op));
        if (min > result.distance) {
          closestMatch = result.closestMatch;
          closestMatchPath = result.path;
          min = result.distance;
          indexMatch = result.indexMatch;
        }
      } else {
        var _context;
        if (_indexOfInstanceProperty(_context = op.toLowerCase()).call(_context, lowerCaseOption) !== -1) {
          indexMatch = op;
        }
        distance = _Validator.levenshteinDistance(option2, op);
        if (min > distance) {
          closestMatch = op;
          closestMatchPath = availableUtils.copyArray(path2);
          min = distance;
        }
      }
    }
    return {
      closestMatch,
      path: closestMatchPath,
      distance: min,
      indexMatch
    };
  }
  /**
   * @param {Array.<string>} path
   * @param {Object} option
   * @param {string} prefix
   * @returns {String}
   * @static
   */
  static printLocation(path2, option2) {
    let prefix = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "Problem value found at: \n";
    let str = "\n\n" + prefix + "options = {\n";
    for (let i = 0; i < path2.length; i++) {
      for (let j = 0; j < i + 1; j++) {
        str += "  ";
      }
      str += path2[i] + ": {\n";
    }
    for (let j = 0; j < path2.length + 1; j++) {
      str += "  ";
    }
    str += option2 + "\n";
    for (let i = 0; i < path2.length + 1; i++) {
      for (let j = 0; j < path2.length - i; j++) {
        str += "  ";
      }
      str += "}\n";
    }
    return str + "\n\n";
  }
  /**
   * @param {Object} options
   * @returns {String}
   * @static
   */
  static print(options) {
    return _JSON$stringify(options).replace(/(\")|(\[)|(\])|(,"__type__")/g, "").replace(/(\,)/g, ", ");
  }
  /**
   *  Compute the edit distance between the two given strings
   * http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript
   *
   * Copyright (c) 2011 Andrei Mackenzie
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   *
   * @param {string} a
   * @param {string} b
   * @returns {Array.<Array.<number>>}}
   * @static
   */
  static levenshteinDistance(a, b) {
    if (a.length === 0) return b.length;
    if (b.length === 0) return a.length;
    var matrix = [];
    var i;
    for (i = 0; i <= b.length; i++) {
      matrix[i] = [i];
    }
    var j;
    for (j = 0; j <= a.length; j++) {
      matrix[0][j] = j;
    }
    for (i = 1; i <= b.length; i++) {
      for (j = 1; j <= a.length; j++) {
        if (b.charAt(i - 1) == a.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            // substitution
            Math.min(
              matrix[i][j - 1] + 1,
              // insertion
              matrix[i - 1][j] + 1
            )
          );
        }
      }
    }
    return matrix[b.length][a.length];
  }
};
var string$1 = "string";
var bool$1 = "boolean";
var number$1 = "number";
var array$1 = "array";
var date$1 = "date";
var object$1 = "object";
var dom$1 = "dom";
var moment$1 = "moment";
var any$1 = "any";
var allOptions$1 = {
  configure: {
    enabled: {
      boolean: bool$1
    },
    filter: {
      boolean: bool$1,
      function: "function"
    },
    container: {
      dom: dom$1
    },
    __type__: {
      object: object$1,
      boolean: bool$1,
      function: "function"
    }
  },
  //globals :
  align: {
    string: string$1
  },
  alignCurrentTime: {
    string: string$1,
    undefined: "undefined"
  },
  rtl: {
    boolean: bool$1,
    undefined: "undefined"
  },
  rollingMode: {
    follow: {
      boolean: bool$1
    },
    offset: {
      number: number$1,
      undefined: "undefined"
    },
    __type__: {
      object: object$1
    }
  },
  onTimeout: {
    timeoutMs: {
      number: number$1
    },
    callback: {
      function: "function"
    },
    __type__: {
      object: object$1
    }
  },
  verticalScroll: {
    boolean: bool$1,
    undefined: "undefined"
  },
  horizontalScroll: {
    boolean: bool$1,
    undefined: "undefined"
  },
  horizontalScrollKey: {
    string: string$1,
    undefined: "undefined"
  },
  horizontalScrollInvert: {
    boolean: bool$1,
    undefined: "undefined"
  },
  autoResize: {
    boolean: bool$1
  },
  throttleRedraw: {
    number: number$1
  },
  // TODO: DEPRICATED see https://github.com/almende/vis/issues/2511
  clickToUse: {
    boolean: bool$1
  },
  dataAttributes: {
    string: string$1,
    array: array$1
  },
  editable: {
    add: {
      boolean: bool$1,
      undefined: "undefined"
    },
    remove: {
      boolean: bool$1,
      undefined: "undefined"
    },
    updateGroup: {
      boolean: bool$1,
      undefined: "undefined"
    },
    updateTime: {
      boolean: bool$1,
      undefined: "undefined"
    },
    overrideItems: {
      boolean: bool$1,
      undefined: "undefined"
    },
    __type__: {
      boolean: bool$1,
      object: object$1
    }
  },
  end: {
    number: number$1,
    date: date$1,
    string: string$1,
    moment: moment$1
  },
  format: {
    minorLabels: {
      millisecond: {
        string: string$1,
        undefined: "undefined"
      },
      second: {
        string: string$1,
        undefined: "undefined"
      },
      minute: {
        string: string$1,
        undefined: "undefined"
      },
      hour: {
        string: string$1,
        undefined: "undefined"
      },
      weekday: {
        string: string$1,
        undefined: "undefined"
      },
      day: {
        string: string$1,
        undefined: "undefined"
      },
      week: {
        string: string$1,
        undefined: "undefined"
      },
      month: {
        string: string$1,
        undefined: "undefined"
      },
      year: {
        string: string$1,
        undefined: "undefined"
      },
      __type__: {
        object: object$1,
        function: "function"
      }
    },
    majorLabels: {
      millisecond: {
        string: string$1,
        undefined: "undefined"
      },
      second: {
        string: string$1,
        undefined: "undefined"
      },
      minute: {
        string: string$1,
        undefined: "undefined"
      },
      hour: {
        string: string$1,
        undefined: "undefined"
      },
      weekday: {
        string: string$1,
        undefined: "undefined"
      },
      day: {
        string: string$1,
        undefined: "undefined"
      },
      week: {
        string: string$1,
        undefined: "undefined"
      },
      month: {
        string: string$1,
        undefined: "undefined"
      },
      year: {
        string: string$1,
        undefined: "undefined"
      },
      __type__: {
        object: object$1,
        function: "function"
      }
    },
    __type__: {
      object: object$1
    }
  },
  moment: {
    function: "function"
  },
  groupHeightMode: {
    string: string$1
  },
  groupOrder: {
    string: string$1,
    function: "function"
  },
  groupEditable: {
    add: {
      boolean: bool$1,
      undefined: "undefined"
    },
    remove: {
      boolean: bool$1,
      undefined: "undefined"
    },
    order: {
      boolean: bool$1,
      undefined: "undefined"
    },
    __type__: {
      boolean: bool$1,
      object: object$1
    }
  },
  groupOrderSwap: {
    function: "function"
  },
  height: {
    string: string$1,
    number: number$1
  },
  hiddenDates: {
    start: {
      date: date$1,
      number: number$1,
      string: string$1,
      moment: moment$1
    },
    end: {
      date: date$1,
      number: number$1,
      string: string$1,
      moment: moment$1
    },
    repeat: {
      string: string$1
    },
    __type__: {
      object: object$1,
      array: array$1
    }
  },
  itemsAlwaysDraggable: {
    item: {
      boolean: bool$1,
      undefined: "undefined"
    },
    range: {
      boolean: bool$1,
      undefined: "undefined"
    },
    __type__: {
      boolean: bool$1,
      object: object$1
    }
  },
  limitSize: {
    boolean: bool$1
  },
  locale: {
    string: string$1
  },
  locales: {
    __any__: {
      any: any$1
    },
    __type__: {
      object: object$1
    }
  },
  longSelectPressTime: {
    number: number$1
  },
  margin: {
    axis: {
      number: number$1
    },
    item: {
      horizontal: {
        number: number$1,
        undefined: "undefined"
      },
      vertical: {
        number: number$1,
        undefined: "undefined"
      },
      __type__: {
        object: object$1,
        number: number$1
      }
    },
    __type__: {
      object: object$1,
      number: number$1
    }
  },
  max: {
    date: date$1,
    number: number$1,
    string: string$1,
    moment: moment$1
  },
  maxHeight: {
    number: number$1,
    string: string$1
  },
  maxMinorChars: {
    number: number$1
  },
  min: {
    date: date$1,
    number: number$1,
    string: string$1,
    moment: moment$1
  },
  minHeight: {
    number: number$1,
    string: string$1
  },
  moveable: {
    boolean: bool$1
  },
  multiselect: {
    boolean: bool$1
  },
  multiselectPerGroup: {
    boolean: bool$1
  },
  onAdd: {
    function: "function"
  },
  onDropObjectOnItem: {
    function: "function"
  },
  onUpdate: {
    function: "function"
  },
  onMove: {
    function: "function"
  },
  onMoving: {
    function: "function"
  },
  onRemove: {
    function: "function"
  },
  onAddGroup: {
    function: "function"
  },
  onMoveGroup: {
    function: "function"
  },
  onRemoveGroup: {
    function: "function"
  },
  onInitialDrawComplete: {
    function: "function"
  },
  order: {
    function: "function"
  },
  orientation: {
    axis: {
      string: string$1,
      undefined: "undefined"
    },
    item: {
      string: string$1,
      undefined: "undefined"
    },
    __type__: {
      string: string$1,
      object: object$1
    }
  },
  selectable: {
    boolean: bool$1
  },
  sequentialSelection: {
    boolean: bool$1
  },
  showCurrentTime: {
    boolean: bool$1
  },
  showMajorLabels: {
    boolean: bool$1
  },
  showMinorLabels: {
    boolean: bool$1
  },
  showWeekScale: {
    boolean: bool$1
  },
  stack: {
    boolean: bool$1
  },
  stackSubgroups: {
    boolean: bool$1
  },
  cluster: {
    maxItems: {
      number: number$1,
      undefined: "undefined"
    },
    titleTemplate: {
      string: string$1,
      undefined: "undefined"
    },
    clusterCriteria: {
      function: "function",
      undefined: "undefined"
    },
    showStipes: {
      boolean: bool$1,
      undefined: "undefined"
    },
    fitOnDoubleClick: {
      boolean: bool$1,
      undefined: "undefined"
    },
    __type__: {
      boolean: bool$1,
      object: object$1
    }
  },
  snap: {
    function: "function",
    null: "null"
  },
  start: {
    date: date$1,
    number: number$1,
    string: string$1,
    moment: moment$1
  },
  template: {
    function: "function"
  },
  loadingScreenTemplate: {
    function: "function"
  },
  groupTemplate: {
    function: "function"
  },
  visibleFrameTemplate: {
    string: string$1,
    function: "function"
  },
  showTooltips: {
    boolean: bool$1
  },
  tooltip: {
    followMouse: {
      boolean: bool$1
    },
    overflowMethod: {
      string: ["cap", "flip", "none"]
    },
    delay: {
      number: number$1
    },
    template: {
      function: "function"
    },
    __type__: {
      object: object$1
    }
  },
  tooltipOnItemUpdateTime: {
    template: {
      function: "function"
    },
    __type__: {
      boolean: bool$1,
      object: object$1
    }
  },
  timeAxis: {
    scale: {
      string: string$1,
      undefined: "undefined"
    },
    step: {
      number: number$1,
      undefined: "undefined"
    },
    __type__: {
      object: object$1
    }
  },
  type: {
    string: string$1
  },
  width: {
    string: string$1,
    number: number$1
  },
  preferZoom: {
    boolean: bool$1
  },
  zoomable: {
    boolean: bool$1
  },
  zoomKey: {
    string: ["ctrlKey", "altKey", "shiftKey", "metaKey", ""]
  },
  zoomFriction: {
    number: number$1
  },
  zoomMax: {
    number: number$1
  },
  zoomMin: {
    number: number$1
  },
  xss: {
    disabled: {
      boolean: bool$1
    },
    filterOptions: {
      __any__: {
        any: any$1
      },
      __type__: {
        object: object$1
      }
    },
    __type__: {
      object: object$1
    }
  },
  __type__: {
    object: object$1
  }
};
var configureOptions$1 = {
  global: {
    align: ["center", "left", "right"],
    alignCurrentTime: ["none", "year", "month", "quarter", "week", "isoWeek", "day", "date", "hour", "minute", "second"],
    direction: false,
    autoResize: true,
    clickToUse: false,
    // dataAttributes: ['all'], // FIXME: can be 'all' or string[]
    editable: {
      add: false,
      remove: false,
      updateGroup: false,
      updateTime: false
    },
    end: "",
    format: {
      minorLabels: {
        millisecond: "SSS",
        second: "s",
        minute: "HH:mm",
        hour: "HH:mm",
        weekday: "ddd D",
        day: "D",
        week: "w",
        month: "MMM",
        year: "YYYY"
      },
      majorLabels: {
        millisecond: "HH:mm:ss",
        second: "D MMMM HH:mm",
        minute: "ddd D MMMM",
        hour: "ddd D MMMM",
        weekday: "MMMM YYYY",
        day: "MMMM YYYY",
        week: "MMMM YYYY",
        month: "YYYY",
        year: ""
      }
    },
    groupHeightMode: ["auto", "fixed", "fitItems"],
    //groupOrder: {string, 'function': 'function'},
    groupsDraggable: false,
    height: "",
    //hiddenDates: {object, array},
    locale: "",
    longSelectPressTime: 251,
    margin: {
      axis: [20, 0, 100, 1],
      item: {
        horizontal: [10, 0, 100, 1],
        vertical: [10, 0, 100, 1]
      }
    },
    max: "",
    maxHeight: "",
    maxMinorChars: [7, 0, 20, 1],
    min: "",
    minHeight: "",
    moveable: false,
    multiselect: false,
    multiselectPerGroup: false,
    //onAdd: {'function': 'function'},
    //onUpdate: {'function': 'function'},
    //onMove: {'function': 'function'},
    //onMoving: {'function': 'function'},
    //onRename: {'function': 'function'},
    //order: {'function': 'function'},
    orientation: {
      axis: ["both", "bottom", "top"],
      item: ["bottom", "top"]
    },
    preferZoom: false,
    selectable: true,
    showCurrentTime: false,
    showMajorLabels: true,
    showMinorLabels: true,
    stack: true,
    stackSubgroups: true,
    cluster: false,
    //snap: {'function': 'function', nada},
    start: "",
    //template: {'function': 'function'},
    //timeAxis: {
    //  scale: ['millisecond', 'second', 'minute', 'hour', 'weekday', 'day', 'week', 'month', 'year'],
    //  step: [1, 1, 10, 1]
    //},
    showTooltips: true,
    tooltip: {
      followMouse: false,
      overflowMethod: "flip",
      delay: [500, 0, 99999, 100]
    },
    tooltipOnItemUpdateTime: false,
    type: ["box", "point", "range", "background"],
    width: "100%",
    zoomable: true,
    zoomKey: ["ctrlKey", "altKey", "shiftKey", "metaKey", ""],
    zoomMax: [31536e10, 10, 31536e10, 1],
    zoomMin: [10, 10, 31536e10, 1],
    xss: {
      disabled: false
    }
  }
};
var htmlColors = {
  black: "#000000",
  navy: "#000080",
  darkblue: "#00008B",
  mediumblue: "#0000CD",
  blue: "#0000FF",
  darkgreen: "#006400",
  green: "#008000",
  teal: "#008080",
  darkcyan: "#008B8B",
  deepskyblue: "#00BFFF",
  darkturquoise: "#00CED1",
  mediumspringgreen: "#00FA9A",
  lime: "#00FF00",
  springgreen: "#00FF7F",
  aqua: "#00FFFF",
  cyan: "#00FFFF",
  midnightblue: "#191970",
  dodgerblue: "#1E90FF",
  lightseagreen: "#20B2AA",
  forestgreen: "#228B22",
  seagreen: "#2E8B57",
  darkslategray: "#2F4F4F",
  limegreen: "#32CD32",
  mediumseagreen: "#3CB371",
  turquoise: "#40E0D0",
  royalblue: "#4169E1",
  steelblue: "#4682B4",
  darkslateblue: "#483D8B",
  mediumturquoise: "#48D1CC",
  indigo: "#4B0082",
  darkolivegreen: "#556B2F",
  cadetblue: "#5F9EA0",
  cornflowerblue: "#6495ED",
  mediumaquamarine: "#66CDAA",
  dimgray: "#696969",
  slateblue: "#6A5ACD",
  olivedrab: "#6B8E23",
  slategray: "#708090",
  lightslategray: "#778899",
  mediumslateblue: "#7B68EE",
  lawngreen: "#7CFC00",
  chartreuse: "#7FFF00",
  aquamarine: "#7FFFD4",
  maroon: "#800000",
  purple: "#800080",
  olive: "#808000",
  gray: "#808080",
  skyblue: "#87CEEB",
  lightskyblue: "#87CEFA",
  blueviolet: "#8A2BE2",
  darkred: "#8B0000",
  darkmagenta: "#8B008B",
  saddlebrown: "#8B4513",
  darkseagreen: "#8FBC8F",
  lightgreen: "#90EE90",
  mediumpurple: "#9370D8",
  darkviolet: "#9400D3",
  palegreen: "#98FB98",
  darkorchid: "#9932CC",
  yellowgreen: "#9ACD32",
  sienna: "#A0522D",
  brown: "#A52A2A",
  darkgray: "#A9A9A9",
  lightblue: "#ADD8E6",
  greenyellow: "#ADFF2F",
  paleturquoise: "#AFEEEE",
  lightsteelblue: "#B0C4DE",
  powderblue: "#B0E0E6",
  firebrick: "#B22222",
  darkgoldenrod: "#B8860B",
  mediumorchid: "#BA55D3",
  rosybrown: "#BC8F8F",
  darkkhaki: "#BDB76B",
  silver: "#C0C0C0",
  mediumvioletred: "#C71585",
  indianred: "#CD5C5C",
  peru: "#CD853F",
  chocolate: "#D2691E",
  tan: "#D2B48C",
  lightgrey: "#D3D3D3",
  palevioletred: "#D87093",
  thistle: "#D8BFD8",
  orchid: "#DA70D6",
  goldenrod: "#DAA520",
  crimson: "#DC143C",
  gainsboro: "#DCDCDC",
  plum: "#DDA0DD",
  burlywood: "#DEB887",
  lightcyan: "#E0FFFF",
  lavender: "#E6E6FA",
  darksalmon: "#E9967A",
  violet: "#EE82EE",
  palegoldenrod: "#EEE8AA",
  lightcoral: "#F08080",
  khaki: "#F0E68C",
  aliceblue: "#F0F8FF",
  honeydew: "#F0FFF0",
  azure: "#F0FFFF",
  sandybrown: "#F4A460",
  wheat: "#F5DEB3",
  beige: "#F5F5DC",
  whitesmoke: "#F5F5F5",
  mintcream: "#F5FFFA",
  ghostwhite: "#F8F8FF",
  salmon: "#FA8072",
  antiquewhite: "#FAEBD7",
  linen: "#FAF0E6",
  lightgoldenrodyellow: "#FAFAD2",
  oldlace: "#FDF5E6",
  red: "#FF0000",
  fuchsia: "#FF00FF",
  magenta: "#FF00FF",
  deeppink: "#FF1493",
  orangered: "#FF4500",
  tomato: "#FF6347",
  hotpink: "#FF69B4",
  coral: "#FF7F50",
  darkorange: "#FF8C00",
  lightsalmon: "#FFA07A",
  orange: "#FFA500",
  lightpink: "#FFB6C1",
  pink: "#FFC0CB",
  gold: "#FFD700",
  peachpuff: "#FFDAB9",
  navajowhite: "#FFDEAD",
  moccasin: "#FFE4B5",
  bisque: "#FFE4C4",
  mistyrose: "#FFE4E1",
  blanchedalmond: "#FFEBCD",
  papayawhip: "#FFEFD5",
  lavenderblush: "#FFF0F5",
  seashell: "#FFF5EE",
  cornsilk: "#FFF8DC",
  lemonchiffon: "#FFFACD",
  floralwhite: "#FFFAF0",
  snow: "#FFFAFA",
  yellow: "#FFFF00",
  lightyellow: "#FFFFE0",
  ivory: "#FFFFF0",
  white: "#FFFFFF"
};
var ColorPicker2 = class {
  /**
   * @param {number} [pixelRatio=1]
   */
  constructor() {
    let pixelRatio = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
    this.pixelRatio = pixelRatio;
    this.generated = false;
    this.centerCoordinates = {
      x: 289 / 2,
      y: 289 / 2
    };
    this.r = 289 * 0.49;
    this.color = {
      r: 255,
      g: 255,
      b: 255,
      a: 1
    };
    this.hueCircle = void 0;
    this.initialColor = {
      r: 255,
      g: 255,
      b: 255,
      a: 1
    };
    this.previousColor = void 0;
    this.applied = false;
    this.updateCallback = () => {
    };
    this.closeCallback = () => {
    };
    this._create();
  }
  /**
   * this inserts the colorPicker into a div from the DOM
   * @param {Element} container
   */
  insertTo(container) {
    if (this.hammer !== void 0) {
      this.hammer.destroy();
      this.hammer = void 0;
    }
    this.container = container;
    this.container.appendChild(this.frame);
    this._bindHammer();
    this._setSize();
  }
  /**
   * the callback is executed on apply and save. Bind it to the application
   * @param {function} callback
   */
  setUpdateCallback(callback) {
    if (typeof callback === "function") {
      this.updateCallback = callback;
    } else {
      throw new Error("Function attempted to set as colorPicker update callback is not a function.");
    }
  }
  /**
   * the callback is executed on apply and save. Bind it to the application
   * @param {function} callback
   */
  setCloseCallback(callback) {
    if (typeof callback === "function") {
      this.closeCallback = callback;
    } else {
      throw new Error("Function attempted to set as colorPicker closing callback is not a function.");
    }
  }
  /**
   *
   * @param {string} color
   * @returns {String}
   * @private
   */
  _isColorString(color) {
    if (typeof color === "string") {
      return htmlColors[color];
    }
  }
  /**
   * Set the color of the colorPicker
   * Supported formats:
   * 'red'                   --> HTML color string
   * '#ffffff'               --> hex string
   * 'rgb(255,255,255)'      --> rgb string
   * 'rgba(255,255,255,1.0)' --> rgba string
   * {r:255,g:255,b:255}     --> rgb object
   * {r:255,g:255,b:255,a:1.0} --> rgba object
   * @param {string|Object} color
   * @param {boolean} [setInitial=true]
   */
  setColor(color) {
    let setInitial = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (color === "none") {
      return;
    }
    let rgba;
    var htmlColor = this._isColorString(color);
    if (htmlColor !== void 0) {
      color = htmlColor;
    }
    if (availableUtils.isString(color) === true) {
      if (availableUtils.isValidRGB(color) === true) {
        let rgbaArray = color.substr(4).substr(0, color.length - 5).split(",");
        rgba = {
          r: rgbaArray[0],
          g: rgbaArray[1],
          b: rgbaArray[2],
          a: 1
        };
      } else if (availableUtils.isValidRGBA(color) === true) {
        let rgbaArray = color.substr(5).substr(0, color.length - 6).split(",");
        rgba = {
          r: rgbaArray[0],
          g: rgbaArray[1],
          b: rgbaArray[2],
          a: rgbaArray[3]
        };
      } else if (availableUtils.isValidHex(color) === true) {
        let rgbObj = availableUtils.hexToRGB(color);
        rgba = {
          r: rgbObj.r,
          g: rgbObj.g,
          b: rgbObj.b,
          a: 1
        };
      }
    } else {
      if (color instanceof Object) {
        if (color.r !== void 0 && color.g !== void 0 && color.b !== void 0) {
          let alpha = color.a !== void 0 ? color.a : "1.0";
          rgba = {
            r: color.r,
            g: color.g,
            b: color.b,
            a: alpha
          };
        }
      }
    }
    if (rgba === void 0) {
      throw new Error("Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: " + _JSON$stringify(color));
    } else {
      this._setColor(rgba, setInitial);
    }
  }
  /**
   * this shows the color picker.
   * The hue circle is constructed once and stored.
   */
  show() {
    if (this.closeCallback !== void 0) {
      this.closeCallback();
      this.closeCallback = void 0;
    }
    this.applied = false;
    this.frame.style.display = "block";
    this._generateHueCircle();
  }
  // ------------------------------------------ PRIVATE ----------------------------- //
  /**
   * Hide the picker. Is called by the cancel button.
   * Optional boolean to store the previous color for easy access later on.
   * @param {boolean} [storePrevious=true]
   * @private
   */
  _hide() {
    let storePrevious = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    if (storePrevious === true) {
      this.previousColor = availableUtils.extend({}, this.color);
    }
    if (this.applied === true) {
      this.updateCallback(this.initialColor);
    }
    this.frame.style.display = "none";
    _setTimeout(() => {
      if (this.closeCallback !== void 0) {
        this.closeCallback();
        this.closeCallback = void 0;
      }
    }, 0);
  }
  /**
   * bound to the save button. Saves and hides.
   * @private
   */
  _save() {
    this.updateCallback(this.color);
    this.applied = false;
    this._hide();
  }
  /**
   * Bound to apply button. Saves but does not close. Is undone by the cancel button.
   * @private
   */
  _apply() {
    this.applied = true;
    this.updateCallback(this.color);
    this._updatePicker(this.color);
  }
  /**
   * load the color from the previous session.
   * @private
   */
  _loadLast() {
    if (this.previousColor !== void 0) {
      this.setColor(this.previousColor, false);
    } else {
      alert("There is no last color to load...");
    }
  }
  /**
   * set the color, place the picker
   * @param {Object} rgba
   * @param {boolean} [setInitial=true]
   * @private
   */
  _setColor(rgba) {
    let setInitial = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (setInitial === true) {
      this.initialColor = availableUtils.extend({}, rgba);
    }
    this.color = rgba;
    let hsv = availableUtils.RGBToHSV(rgba.r, rgba.g, rgba.b);
    let angleConvert = 2 * Math.PI;
    let radius = this.r * hsv.s;
    let x = this.centerCoordinates.x + radius * Math.sin(angleConvert * hsv.h);
    let y = this.centerCoordinates.y + radius * Math.cos(angleConvert * hsv.h);
    this.colorPickerSelector.style.left = x - 0.5 * this.colorPickerSelector.clientWidth + "px";
    this.colorPickerSelector.style.top = y - 0.5 * this.colorPickerSelector.clientHeight + "px";
    this._updatePicker(rgba);
  }
  /**
   * bound to opacity control
   * @param {number} value
   * @private
   */
  _setOpacity(value) {
    this.color.a = value / 100;
    this._updatePicker(this.color);
  }
  /**
   * bound to brightness control
   * @param {number} value
   * @private
   */
  _setBrightness(value) {
    let hsv = availableUtils.RGBToHSV(this.color.r, this.color.g, this.color.b);
    hsv.v = value / 100;
    let rgba = availableUtils.HSVToRGB(hsv.h, hsv.s, hsv.v);
    rgba["a"] = this.color.a;
    this.color = rgba;
    this._updatePicker();
  }
  /**
   * update the color picker. A black circle overlays the hue circle to mimic the brightness decreasing.
   * @param {Object} rgba
   * @private
   */
  _updatePicker() {
    let rgba = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.color;
    let hsv = availableUtils.RGBToHSV(rgba.r, rgba.g, rgba.b);
    let ctx = this.colorPickerCanvas.getContext("2d");
    if (this.pixelRation === void 0) {
      this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
    }
    ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
    let w = this.colorPickerCanvas.clientWidth;
    let h = this.colorPickerCanvas.clientHeight;
    ctx.clearRect(0, 0, w, h);
    ctx.putImageData(this.hueCircle, 0, 0);
    ctx.fillStyle = "rgba(0,0,0," + (1 - hsv.v) + ")";
    ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
    _fillInstanceProperty(ctx).call(ctx);
    this.brightnessRange.value = 100 * hsv.v;
    this.opacityRange.value = 100 * rgba.a;
    this.initialColorDiv.style.backgroundColor = "rgba(" + this.initialColor.r + "," + this.initialColor.g + "," + this.initialColor.b + "," + this.initialColor.a + ")";
    this.newColorDiv.style.backgroundColor = "rgba(" + this.color.r + "," + this.color.g + "," + this.color.b + "," + this.color.a + ")";
  }
  /**
   * used by create to set the size of the canvas.
   * @private
   */
  _setSize() {
    this.colorPickerCanvas.style.width = "100%";
    this.colorPickerCanvas.style.height = "100%";
    this.colorPickerCanvas.width = 289 * this.pixelRatio;
    this.colorPickerCanvas.height = 289 * this.pixelRatio;
  }
  /**
   * create all dom elements
   * TODO: cleanup, lots of similar dom elements
   * @private
   */
  _create() {
    var _context, _context2, _context3, _context4;
    this.frame = document.createElement("div");
    this.frame.className = "vis-color-picker";
    this.colorPickerDiv = document.createElement("div");
    this.colorPickerSelector = document.createElement("div");
    this.colorPickerSelector.className = "vis-selector";
    this.colorPickerDiv.appendChild(this.colorPickerSelector);
    this.colorPickerCanvas = document.createElement("canvas");
    this.colorPickerDiv.appendChild(this.colorPickerCanvas);
    if (!this.colorPickerCanvas.getContext) {
      let noCanvas = document.createElement("DIV");
      noCanvas.style.color = "red";
      noCanvas.style.fontWeight = "bold";
      noCanvas.style.padding = "10px";
      noCanvas.innerHTML = "Error: your browser does not support HTML canvas";
      this.colorPickerCanvas.appendChild(noCanvas);
    } else {
      let ctx = this.colorPickerCanvas.getContext("2d");
      this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
      this.colorPickerCanvas.getContext("2d").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
    }
    this.colorPickerDiv.className = "vis-color";
    this.opacityDiv = document.createElement("div");
    this.opacityDiv.className = "vis-opacity";
    this.brightnessDiv = document.createElement("div");
    this.brightnessDiv.className = "vis-brightness";
    this.arrowDiv = document.createElement("div");
    this.arrowDiv.className = "vis-arrow";
    this.opacityRange = document.createElement("input");
    try {
      this.opacityRange.type = "range";
      this.opacityRange.min = "0";
      this.opacityRange.max = "100";
    } catch (err) {
    }
    this.opacityRange.value = "100";
    this.opacityRange.className = "vis-range";
    this.brightnessRange = document.createElement("input");
    try {
      this.brightnessRange.type = "range";
      this.brightnessRange.min = "0";
      this.brightnessRange.max = "100";
    } catch (err) {
    }
    this.brightnessRange.value = "100";
    this.brightnessRange.className = "vis-range";
    this.opacityDiv.appendChild(this.opacityRange);
    this.brightnessDiv.appendChild(this.brightnessRange);
    var me = this;
    this.opacityRange.onchange = function() {
      me._setOpacity(this.value);
    };
    this.opacityRange.oninput = function() {
      me._setOpacity(this.value);
    };
    this.brightnessRange.onchange = function() {
      me._setBrightness(this.value);
    };
    this.brightnessRange.oninput = function() {
      me._setBrightness(this.value);
    };
    this.brightnessLabel = document.createElement("div");
    this.brightnessLabel.className = "vis-label vis-brightness";
    this.brightnessLabel.innerHTML = "brightness:";
    this.opacityLabel = document.createElement("div");
    this.opacityLabel.className = "vis-label vis-opacity";
    this.opacityLabel.innerHTML = "opacity:";
    this.newColorDiv = document.createElement("div");
    this.newColorDiv.className = "vis-new-color";
    this.newColorDiv.innerHTML = "new";
    this.initialColorDiv = document.createElement("div");
    this.initialColorDiv.className = "vis-initial-color";
    this.initialColorDiv.innerHTML = "initial";
    this.cancelButton = document.createElement("div");
    this.cancelButton.className = "vis-button vis-cancel";
    this.cancelButton.innerHTML = "cancel";
    this.cancelButton.onclick = _bindInstanceProperty(_context = this._hide).call(_context, this, false);
    this.applyButton = document.createElement("div");
    this.applyButton.className = "vis-button vis-apply";
    this.applyButton.innerHTML = "apply";
    this.applyButton.onclick = _bindInstanceProperty(_context2 = this._apply).call(_context2, this);
    this.saveButton = document.createElement("div");
    this.saveButton.className = "vis-button vis-save";
    this.saveButton.innerHTML = "save";
    this.saveButton.onclick = _bindInstanceProperty(_context3 = this._save).call(_context3, this);
    this.loadButton = document.createElement("div");
    this.loadButton.className = "vis-button vis-load";
    this.loadButton.innerHTML = "load last";
    this.loadButton.onclick = _bindInstanceProperty(_context4 = this._loadLast).call(_context4, this);
    this.frame.appendChild(this.colorPickerDiv);
    this.frame.appendChild(this.arrowDiv);
    this.frame.appendChild(this.brightnessLabel);
    this.frame.appendChild(this.brightnessDiv);
    this.frame.appendChild(this.opacityLabel);
    this.frame.appendChild(this.opacityDiv);
    this.frame.appendChild(this.newColorDiv);
    this.frame.appendChild(this.initialColorDiv);
    this.frame.appendChild(this.cancelButton);
    this.frame.appendChild(this.applyButton);
    this.frame.appendChild(this.saveButton);
    this.frame.appendChild(this.loadButton);
  }
  /**
   * bind hammer to the color picker
   * @private
   */
  _bindHammer() {
    this.drag = {};
    this.pinch = {};
    this.hammer = new Hammer(this.colorPickerCanvas);
    this.hammer.get("pinch").set({
      enable: true
    });
    onTouch(this.hammer, (event2) => {
      this._moveSelector(event2);
    });
    this.hammer.on("tap", (event2) => {
      this._moveSelector(event2);
    });
    this.hammer.on("panstart", (event2) => {
      this._moveSelector(event2);
    });
    this.hammer.on("panmove", (event2) => {
      this._moveSelector(event2);
    });
    this.hammer.on("panend", (event2) => {
      this._moveSelector(event2);
    });
  }
  /**
   * generate the hue circle. This is relatively heavy (200ms) and is done only once on the first time it is shown.
   * @private
   */
  _generateHueCircle() {
    if (this.generated === false) {
      let ctx = this.colorPickerCanvas.getContext("2d");
      if (this.pixelRation === void 0) {
        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
      }
      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
      let w = this.colorPickerCanvas.clientWidth;
      let h = this.colorPickerCanvas.clientHeight;
      ctx.clearRect(0, 0, w, h);
      let x, y, hue, sat;
      this.centerCoordinates = {
        x: w * 0.5,
        y: h * 0.5
      };
      this.r = 0.49 * w;
      let angleConvert = 2 * Math.PI / 360;
      let hfac = 1 / 360;
      let sfac = 1 / this.r;
      let rgb;
      for (hue = 0; hue < 360; hue++) {
        for (sat = 0; sat < this.r; sat++) {
          x = this.centerCoordinates.x + sat * Math.sin(angleConvert * hue);
          y = this.centerCoordinates.y + sat * Math.cos(angleConvert * hue);
          rgb = availableUtils.HSVToRGB(hue * hfac, sat * sfac, 1);
          ctx.fillStyle = "rgb(" + rgb.r + "," + rgb.g + "," + rgb.b + ")";
          ctx.fillRect(x - 0.5, y - 0.5, 2, 2);
        }
      }
      ctx.strokeStyle = "rgba(0,0,0,1)";
      ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
      ctx.stroke();
      this.hueCircle = ctx.getImageData(0, 0, w, h);
    }
    this.generated = true;
  }
  /**
   * move the selector. This is called by hammer functions.
   *
   * @param {Event}  event   The event
   * @private
   */
  _moveSelector(event2) {
    let rect = this.colorPickerDiv.getBoundingClientRect();
    let left = event2.center.x - rect.left;
    let top = event2.center.y - rect.top;
    let centerY = 0.5 * this.colorPickerDiv.clientHeight;
    let centerX = 0.5 * this.colorPickerDiv.clientWidth;
    let x = left - centerX;
    let y = top - centerY;
    let angle = Math.atan2(x, y);
    let radius = 0.98 * Math.min(Math.sqrt(x * x + y * y), centerX);
    let newTop = Math.cos(angle) * radius + centerY;
    let newLeft = Math.sin(angle) * radius + centerX;
    this.colorPickerSelector.style.top = newTop - 0.5 * this.colorPickerSelector.clientHeight + "px";
    this.colorPickerSelector.style.left = newLeft - 0.5 * this.colorPickerSelector.clientWidth + "px";
    let h = angle / (2 * Math.PI);
    h = h < 0 ? h + 1 : h;
    let s = radius / this.r;
    let hsv = availableUtils.RGBToHSV(this.color.r, this.color.g, this.color.b);
    hsv.h = h;
    hsv.s = s;
    let rgba = availableUtils.HSVToRGB(hsv.h, hsv.s, hsv.v);
    rgba["a"] = this.color.a;
    this.color = rgba;
    this.initialColorDiv.style.backgroundColor = "rgba(" + this.initialColor.r + "," + this.initialColor.g + "," + this.initialColor.b + "," + this.initialColor.a + ")";
    this.newColorDiv.style.backgroundColor = "rgba(" + this.color.r + "," + this.color.g + "," + this.color.b + "," + this.color.a + ")";
  }
};
var Configurator2 = class {
  /**
   * @param {Object} parentModule        | the location where parentModule.setOptions() can be called
   * @param {Object} defaultContainer    | the default container of the module
   * @param {Object} configureOptions    | the fully configured and predefined options set found in allOptions.js
   * @param {number} pixelRatio          | canvas pixel ratio
   */
  constructor(parentModule, defaultContainer, configureOptions2) {
    let pixelRatio = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
    this.parent = parentModule;
    this.changedOptions = [];
    this.container = defaultContainer;
    this.allowCreation = false;
    this.options = {};
    this.initialized = false;
    this.popupCounter = 0;
    this.defaultOptions = {
      enabled: false,
      filter: true,
      container: void 0,
      showButton: true
    };
    availableUtils.extend(this.options, this.defaultOptions);
    this.configureOptions = configureOptions2;
    this.moduleOptions = {};
    this.domElements = [];
    this.popupDiv = {};
    this.popupLimit = 5;
    this.popupHistory = {};
    this.colorPicker = new ColorPicker2(pixelRatio);
    this.wrapper = void 0;
  }
  /**
   * refresh all options.
   * Because all modules parse their options by themselves, we just use their options. We copy them here.
   *
   * @param {Object} options
   */
  setOptions(options) {
    if (options !== void 0) {
      this.popupHistory = {};
      this._removePopup();
      let enabled = true;
      if (typeof options === "string") {
        this.options.filter = options;
      } else if (_Array$isArray(options)) {
        this.options.filter = options.join();
      } else if (typeof options === "object") {
        if (options == null) {
          throw new TypeError("options cannot be null");
        }
        if (options.container !== void 0) {
          this.options.container = options.container;
        }
        if (_filterInstanceProperty(options) !== void 0) {
          this.options.filter = _filterInstanceProperty(options);
        }
        if (options.showButton !== void 0) {
          this.options.showButton = options.showButton;
        }
        if (options.enabled !== void 0) {
          enabled = options.enabled;
        }
      } else if (typeof options === "boolean") {
        this.options.filter = true;
        enabled = options;
      } else if (typeof options === "function") {
        this.options.filter = options;
        enabled = true;
      }
      if (_filterInstanceProperty(this.options) === false) {
        enabled = false;
      }
      this.options.enabled = enabled;
    }
    this._clean();
  }
  /**
   *
   * @param {Object} moduleOptions
   */
  setModuleOptions(moduleOptions) {
    this.moduleOptions = moduleOptions;
    if (this.options.enabled === true) {
      this._clean();
      if (this.options.container !== void 0) {
        this.container = this.options.container;
      }
      this._create();
    }
  }
  /**
   * Create all DOM elements
   * @private
   */
  _create() {
    this._clean();
    this.changedOptions = [];
    let filter2 = _filterInstanceProperty(this.options);
    let counter = 0;
    let show = false;
    for (let option2 in this.configureOptions) {
      if (!Object.prototype.hasOwnProperty.call(this.configureOptions, option2)) continue;
      this.allowCreation = false;
      show = false;
      if (typeof filter2 === "function") {
        show = filter2(option2, []);
        show = show || this._handleObject(this.configureOptions[option2], [option2], true);
      } else if (filter2 === true || _indexOfInstanceProperty(filter2).call(filter2, option2) !== -1) {
        show = true;
      }
      if (show !== false) {
        this.allowCreation = true;
        if (counter > 0) {
          this._makeItem([]);
        }
        this._makeHeader(option2);
        this._handleObject(this.configureOptions[option2], [option2]);
      }
      counter++;
    }
    this._makeButton();
    this._push();
  }
  /**
   * draw all DOM elements on the screen
   * @private
   */
  _push() {
    this.wrapper = document.createElement("div");
    this.wrapper.className = "vis-configuration-wrapper";
    this.container.appendChild(this.wrapper);
    for (var i = 0; i < this.domElements.length; i++) {
      this.wrapper.appendChild(this.domElements[i]);
    }
    this._showPopupIfNeeded();
  }
  /**
   * delete all DOM elements
   * @private
   */
  _clean() {
    for (var i = 0; i < this.domElements.length; i++) {
      this.wrapper.removeChild(this.domElements[i]);
    }
    if (this.wrapper !== void 0) {
      this.container.removeChild(this.wrapper);
      this.wrapper = void 0;
    }
    this.domElements = [];
    this._removePopup();
  }
  /**
   * get the value from the actualOptions if it exists
   * @param {array} path    | where to look for the actual option
   * @returns {*}
   * @private
   */
  _getValue(path2) {
    let base = this.moduleOptions;
    for (let i = 0; i < path2.length; i++) {
      if (base[path2[i]] !== void 0) {
        base = base[path2[i]];
      } else {
        base = void 0;
        break;
      }
    }
    return base;
  }
  /**
   * all option elements are wrapped in an item
   * @param {Array} path    | where to look for the actual option
   * @param {Array.<Element>} domElements
   * @returns {number}
   * @private
   */
  _makeItem(path2) {
    if (this.allowCreation === true) {
      let item = document.createElement("div");
      item.className = "vis-configuration vis-config-item vis-config-s" + path2.length;
      for (var _len = arguments.length, domElements = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        domElements[_key - 1] = arguments[_key];
      }
      _forEachInstanceProperty(domElements).call(domElements, (element) => {
        item.appendChild(element);
      });
      this.domElements.push(item);
      return this.domElements.length;
    }
    return 0;
  }
  /**
   * header for major subjects
   * @param {string} name
   * @private
   */
  _makeHeader(name) {
    let div = document.createElement("div");
    div.className = "vis-configuration vis-config-header";
    div.innerHTML = availableUtils.xss(name);
    this._makeItem([], div);
  }
  /**
   * make a label, if it is an object label, it gets different styling.
   * @param {string} name
   * @param {array} path    | where to look for the actual option
   * @param {string} objectLabel
   * @returns {HTMLElement}
   * @private
   */
  _makeLabel(name, path2) {
    let objectLabel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    let div = document.createElement("div");
    div.className = "vis-configuration vis-config-label vis-config-s" + path2.length;
    if (objectLabel === true) {
      div.innerHTML = availableUtils.xss("<i><b>" + name + ":</b></i>");
    } else {
      div.innerHTML = availableUtils.xss(name + ":");
    }
    return div;
  }
  /**
   * make a dropdown list for multiple possible string optoins
   * @param {Array.<number>} arr
   * @param {number} value
   * @param {array} path    | where to look for the actual option
   * @private
   */
  _makeDropdown(arr, value, path2) {
    let select = document.createElement("select");
    select.className = "vis-configuration vis-config-select";
    let selectedValue = 0;
    if (value !== void 0) {
      if (_indexOfInstanceProperty(arr).call(arr, value) !== -1) {
        selectedValue = _indexOfInstanceProperty(arr).call(arr, value);
      }
    }
    for (let i = 0; i < arr.length; i++) {
      let option2 = document.createElement("option");
      option2.value = arr[i];
      if (i === selectedValue) {
        option2.selected = "selected";
      }
      option2.innerHTML = arr[i];
      select.appendChild(option2);
    }
    let me = this;
    select.onchange = function() {
      me._update(this.value, path2);
    };
    let label = this._makeLabel(path2[path2.length - 1], path2);
    this._makeItem(path2, label, select);
  }
  /**
   * make a range object for numeric options
   * @param {Array.<number>} arr
   * @param {number} value
   * @param {array} path    | where to look for the actual option
   * @private
   */
  _makeRange(arr, value, path2) {
    let defaultValue = arr[0];
    let min = arr[1];
    let max = arr[2];
    let step = arr[3];
    let range = document.createElement("input");
    range.className = "vis-configuration vis-config-range";
    try {
      range.type = "range";
      range.min = min;
      range.max = max;
    } catch (err) {
    }
    range.step = step;
    let popupString = "";
    let popupValue = 0;
    if (value !== void 0) {
      let factor = 1.2;
      if (value < 0 && value * factor < min) {
        range.min = Math.ceil(value * factor);
        popupValue = range.min;
        popupString = "range increased";
      } else if (value / factor < min) {
        range.min = Math.ceil(value / factor);
        popupValue = range.min;
        popupString = "range increased";
      }
      if (value * factor > max && max !== 1) {
        range.max = Math.ceil(value * factor);
        popupValue = range.max;
        popupString = "range increased";
      }
      range.value = value;
    } else {
      range.value = defaultValue;
    }
    let input = document.createElement("input");
    input.className = "vis-configuration vis-config-rangeinput";
    input.value = Number(range.value);
    var me = this;
    range.onchange = function() {
      input.value = this.value;
      me._update(Number(this.value), path2);
    };
    range.oninput = function() {
      input.value = this.value;
    };
    let label = this._makeLabel(path2[path2.length - 1], path2);
    let itemIndex = this._makeItem(path2, label, range, input);
    if (popupString !== "" && this.popupHistory[itemIndex] !== popupValue) {
      this.popupHistory[itemIndex] = popupValue;
      this._setupPopup(popupString, itemIndex);
    }
  }
  /**
   * make a button object
   * @private
   */
  _makeButton() {
    if (this.options.showButton === true) {
      let generateButton = document.createElement("div");
      generateButton.className = "vis-configuration vis-config-button";
      generateButton.innerHTML = "generate options";
      generateButton.onclick = () => {
        this._printOptions();
      };
      generateButton.onmouseover = () => {
        generateButton.className = "vis-configuration vis-config-button hover";
      };
      generateButton.onmouseout = () => {
        generateButton.className = "vis-configuration vis-config-button";
      };
      this.optionsContainer = document.createElement("div");
      this.optionsContainer.className = "vis-configuration vis-config-option-container";
      this.domElements.push(this.optionsContainer);
      this.domElements.push(generateButton);
    }
  }
  /**
   * prepare the popup
   * @param {string} string
   * @param {number} index
   * @private
   */
  _setupPopup(string2, index) {
    if (this.initialized === true && this.allowCreation === true && this.popupCounter < this.popupLimit) {
      let div = document.createElement("div");
      div.id = "vis-configuration-popup";
      div.className = "vis-configuration-popup";
      div.innerHTML = availableUtils.xss(string2);
      div.onclick = () => {
        this._removePopup();
      };
      this.popupCounter += 1;
      this.popupDiv = {
        html: div,
        index
      };
    }
  }
  /**
   * remove the popup from the dom
   * @private
   */
  _removePopup() {
    if (this.popupDiv.html !== void 0) {
      this.popupDiv.html.parentNode.removeChild(this.popupDiv.html);
      clearTimeout(this.popupDiv.hideTimeout);
      clearTimeout(this.popupDiv.deleteTimeout);
      this.popupDiv = {};
    }
  }
  /**
   * Show the popup if it is needed.
   * @private
   */
  _showPopupIfNeeded() {
    if (this.popupDiv.html !== void 0) {
      let correspondingElement = this.domElements[this.popupDiv.index];
      let rect = correspondingElement.getBoundingClientRect();
      this.popupDiv.html.style.left = rect.left + "px";
      this.popupDiv.html.style.top = rect.top - 30 + "px";
      document.body.appendChild(this.popupDiv.html);
      this.popupDiv.hideTimeout = _setTimeout(() => {
        this.popupDiv.html.style.opacity = 0;
      }, 1500);
      this.popupDiv.deleteTimeout = _setTimeout(() => {
        this._removePopup();
      }, 1800);
    }
  }
  /**
   * make a checkbox for boolean options.
   * @param {number} defaultValue
   * @param {number} value
   * @param {array} path    | where to look for the actual option
   * @private
   */
  _makeCheckbox(defaultValue, value, path2) {
    var checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.className = "vis-configuration vis-config-checkbox";
    checkbox.checked = defaultValue;
    if (value !== void 0) {
      checkbox.checked = value;
      if (value !== defaultValue) {
        if (typeof defaultValue === "object") {
          if (value !== defaultValue.enabled) {
            this.changedOptions.push({
              path: path2,
              value
            });
          }
        } else {
          this.changedOptions.push({
            path: path2,
            value
          });
        }
      }
    }
    let me = this;
    checkbox.onchange = function() {
      me._update(this.checked, path2);
    };
    let label = this._makeLabel(path2[path2.length - 1], path2);
    this._makeItem(path2, label, checkbox);
  }
  /**
   * make a text input field for string options.
   * @param {number} defaultValue
   * @param {number} value
   * @param {array} path    | where to look for the actual option
   * @private
   */
  _makeTextInput(defaultValue, value, path2) {
    var checkbox = document.createElement("input");
    checkbox.type = "text";
    checkbox.className = "vis-configuration vis-config-text";
    checkbox.value = value;
    if (value !== defaultValue) {
      this.changedOptions.push({
        path: path2,
        value
      });
    }
    let me = this;
    checkbox.onchange = function() {
      me._update(this.value, path2);
    };
    let label = this._makeLabel(path2[path2.length - 1], path2);
    this._makeItem(path2, label, checkbox);
  }
  /**
   * make a color field with a color picker for color fields
   * @param {Array.<number>} arr
   * @param {number} value
   * @param {array} path    | where to look for the actual option
   * @private
   */
  _makeColorField(arr, value, path2) {
    let defaultColor = arr[1];
    let div = document.createElement("div");
    value = value === void 0 ? defaultColor : value;
    if (value !== "none") {
      div.className = "vis-configuration vis-config-colorBlock";
      div.style.backgroundColor = value;
    } else {
      div.className = "vis-configuration vis-config-colorBlock none";
    }
    value = value === void 0 ? defaultColor : value;
    div.onclick = () => {
      this._showColorPicker(value, div, path2);
    };
    let label = this._makeLabel(path2[path2.length - 1], path2);
    this._makeItem(path2, label, div);
  }
  /**
   * used by the color buttons to call the color picker.
   * @param {number} value
   * @param {HTMLElement} div
   * @param {array} path    | where to look for the actual option
   * @private
   */
  _showColorPicker(value, div, path2) {
    div.onclick = function() {
    };
    this.colorPicker.insertTo(div);
    this.colorPicker.show();
    this.colorPicker.setColor(value);
    this.colorPicker.setUpdateCallback((color) => {
      let colorString = "rgba(" + color.r + "," + color.g + "," + color.b + "," + color.a + ")";
      div.style.backgroundColor = colorString;
      this._update(colorString, path2);
    });
    this.colorPicker.setCloseCallback(() => {
      div.onclick = () => {
        this._showColorPicker(value, div, path2);
      };
    });
  }
  /**
   * parse an object and draw the correct items
   * @param {Object} obj
   * @param {array} [path=[]]    | where to look for the actual option
   * @param {boolean} [checkOnly=false]
   * @returns {boolean}
   * @private
   */
  _handleObject(obj) {
    let path2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    let checkOnly = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    let show = false;
    let filter2 = _filterInstanceProperty(this.options);
    let visibleInSet = false;
    for (let subObj in obj) {
      if (!Object.prototype.hasOwnProperty.call(obj, subObj)) continue;
      show = true;
      let item = obj[subObj];
      let newPath = availableUtils.copyAndExtendArray(path2, subObj);
      if (typeof filter2 === "function") {
        show = filter2(subObj, path2);
        if (show === false) {
          if (!_Array$isArray(item) && typeof item !== "string" && typeof item !== "boolean" && item instanceof Object) {
            this.allowCreation = false;
            show = this._handleObject(item, newPath, true);
            this.allowCreation = checkOnly === false;
          }
        }
      }
      if (show !== false) {
        visibleInSet = true;
        let value = this._getValue(newPath);
        if (_Array$isArray(item)) {
          this._handleArray(item, value, newPath);
        } else if (typeof item === "string") {
          this._makeTextInput(item, value, newPath);
        } else if (typeof item === "boolean") {
          this._makeCheckbox(item, value, newPath);
        } else if (item instanceof Object) {
          let draw = true;
          if (_indexOfInstanceProperty(path2).call(path2, "physics") !== -1) {
            if (this.moduleOptions.physics.solver !== subObj) {
              draw = false;
            }
          }
          if (draw === true) {
            if (item.enabled !== void 0) {
              let enabledPath = availableUtils.copyAndExtendArray(newPath, "enabled");
              let enabledValue = this._getValue(enabledPath);
              if (enabledValue === true) {
                let label = this._makeLabel(subObj, newPath, true);
                this._makeItem(newPath, label);
                visibleInSet = this._handleObject(item, newPath) || visibleInSet;
              } else {
                this._makeCheckbox(item, enabledValue, newPath);
              }
            } else {
              let label = this._makeLabel(subObj, newPath, true);
              this._makeItem(newPath, label);
              visibleInSet = this._handleObject(item, newPath) || visibleInSet;
            }
          }
        } else {
          console.error("dont know how to handle", item, subObj, newPath);
        }
      }
    }
    return visibleInSet;
  }
  /**
   * handle the array type of option
   * @param {Array.<number>} arr
   * @param {number} value
   * @param {array} path    | where to look for the actual option
   * @private
   */
  _handleArray(arr, value, path2) {
    if (typeof arr[0] === "string" && arr[0] === "color") {
      this._makeColorField(arr, value, path2);
      if (arr[1] !== value) {
        this.changedOptions.push({
          path: path2,
          value
        });
      }
    } else if (typeof arr[0] === "string") {
      this._makeDropdown(arr, value, path2);
      if (arr[0] !== value) {
        this.changedOptions.push({
          path: path2,
          value
        });
      }
    } else if (typeof arr[0] === "number") {
      this._makeRange(arr, value, path2);
      if (arr[0] !== value) {
        this.changedOptions.push({
          path: path2,
          value: Number(value)
        });
      }
    }
  }
  /**
   * called to update the network with the new settings.
   * @param {number} value
   * @param {array} path    | where to look for the actual option
   * @private
   */
  _update(value, path2) {
    let options = this._constructOptions(value, path2);
    if (this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit) {
      this.parent.body.emitter.emit("configChange", options);
    }
    this.initialized = true;
    this.parent.setOptions(options);
  }
  /**
   *
   * @param {string|Boolean} value
   * @param {Array.<string>} path
   * @param {{}} optionsObj
   * @returns {{}}
   * @private
   */
  _constructOptions(value, path2) {
    let optionsObj = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let pointer = optionsObj;
    value = value === "true" ? true : value;
    value = value === "false" ? false : value;
    for (let i = 0; i < path2.length; i++) {
      if (path2[i] !== "global") {
        if (pointer[path2[i]] === void 0) {
          pointer[path2[i]] = {};
        }
        if (i !== path2.length - 1) {
          pointer = pointer[path2[i]];
        } else {
          pointer[path2[i]] = value;
        }
      }
    }
    return optionsObj;
  }
  /**
   * @private
   */
  _printOptions() {
    let options = this.getOptions();
    this.optionsContainer.innerHTML = "<pre>var options = " + _JSON$stringify(options, null, 2) + "</pre>";
  }
  /**
   *
   * @returns {{}} options
   */
  getOptions() {
    let options = {};
    for (var i = 0; i < this.changedOptions.length; i++) {
      this._constructOptions(this.changedOptions[i].value, this.changedOptions[i].path, options);
    }
    return options;
  }
};
var Timeline = class _Timeline extends Core {
  /**
   * @param {HTMLElement} container
   * @param {vis.DataSet | vis.DataView | Array} [items]
   * @param {vis.DataSet | vis.DataView | Array} [groups]
   * @param {Object} [options]  See Timeline.setOptions for the available options.
   * @constructor Timeline
   */
  constructor(container, items, groups, options) {
    var _context2, _context3, _context4, _context5, _context6, _context7, _context8;
    super();
    this.initTime = /* @__PURE__ */ new Date();
    this.itemsDone = false;
    if (!(this instanceof _Timeline)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (!(_Array$isArray(groups) || isDataViewLike(groups)) && groups instanceof Object) {
      const forthArgument = options;
      options = groups;
      groups = forthArgument;
    }
    if (options && options.throttleRedraw) {
      console.warn('Timeline option "throttleRedraw" is DEPRICATED and no longer supported. It will be removed in the next MAJOR release.');
    }
    const me = this;
    this.defaultOptions = {
      autoResize: true,
      longSelectPressTime: 251,
      orientation: {
        axis: "bottom",
        // axis orientation: 'bottom', 'top', or 'both'
        item: "bottom"
        // not relevant
      },
      moment: moment$2
    };
    this.options = availableUtils.deepExtend({}, this.defaultOptions);
    options && availableUtils.setupXSSProtection(options.xss);
    this._create(container);
    if (!options || options && typeof options.rtl == "undefined") {
      this.dom.root.style.visibility = "hidden";
      let directionFromDom;
      let domNode = this.dom.root;
      while (!directionFromDom && domNode) {
        directionFromDom = window.getComputedStyle(domNode, null).direction;
        domNode = domNode.parentElement;
      }
      this.options.rtl = directionFromDom && directionFromDom.toLowerCase() == "rtl";
    } else {
      this.options.rtl = options.rtl;
    }
    if (options) {
      if (options.rollingMode) {
        this.options.rollingMode = options.rollingMode;
      }
      if (options.onInitialDrawComplete) {
        this.options.onInitialDrawComplete = options.onInitialDrawComplete;
      }
      if (options.onTimeout) {
        this.options.onTimeout = options.onTimeout;
      }
      if (options.loadingScreenTemplate) {
        this.options.loadingScreenTemplate = options.loadingScreenTemplate;
      }
    }
    const loadingScreenFragment = document.createElement("div");
    if (this.options.loadingScreenTemplate) {
      var _context;
      const templateFunction = _bindInstanceProperty(_context = this.options.loadingScreenTemplate).call(_context, this);
      const loadingScreen = templateFunction(this.dom.loadingScreen);
      if (loadingScreen instanceof Object && !(loadingScreen instanceof Element)) {
        templateFunction(loadingScreenFragment);
      } else {
        if (loadingScreen instanceof Element) {
          loadingScreenFragment.innerHTML = "";
          loadingScreenFragment.appendChild(loadingScreen);
        } else if (loadingScreen != void 0) {
          loadingScreenFragment.innerHTML = availableUtils.xss(loadingScreen);
        }
      }
    }
    this.dom.loadingScreen.appendChild(loadingScreenFragment);
    this.components = [];
    this.body = {
      dom: this.dom,
      domProps: this.props,
      emitter: {
        on: _bindInstanceProperty(_context2 = this.on).call(_context2, this),
        off: _bindInstanceProperty(_context3 = this.off).call(_context3, this),
        emit: _bindInstanceProperty(_context4 = this.emit).call(_context4, this)
      },
      hiddenDates: [],
      util: {
        getScale() {
          return me.timeAxis.step.scale;
        },
        getStep() {
          return me.timeAxis.step.step;
        },
        toScreen: _bindInstanceProperty(_context5 = me._toScreen).call(_context5, me),
        toGlobalScreen: _bindInstanceProperty(_context6 = me._toGlobalScreen).call(_context6, me),
        // this refers to the root.width
        toTime: _bindInstanceProperty(_context7 = me._toTime).call(_context7, me),
        toGlobalTime: _bindInstanceProperty(_context8 = me._toGlobalTime).call(_context8, me)
      }
    };
    this.range = new Range(this.body, this.options);
    this.components.push(this.range);
    this.body.range = this.range;
    this.timeAxis = new TimeAxis(this.body, this.options);
    this.timeAxis2 = null;
    this.components.push(this.timeAxis);
    this.currentTime = new CurrentTime(this.body, this.options);
    this.components.push(this.currentTime);
    this.itemSet = new ItemSet(this.body, this.options);
    this.components.push(this.itemSet);
    this.itemsData = null;
    this.groupsData = null;
    function emit(eventName, event2) {
      if (!me.hasListeners(eventName)) return;
      me.emit(eventName, me.getEventProperties(event2));
    }
    this.dom.root.onclick = (event2) => emit("click", event2);
    this.dom.root.ondblclick = (event2) => emit("doubleClick", event2);
    this.dom.root.oncontextmenu = (event2) => emit("contextmenu", event2);
    this.dom.root.onmouseover = (event2) => emit("mouseOver", event2);
    if (window.PointerEvent) {
      this.dom.root.onpointerdown = (event2) => emit("mouseDown", event2);
      this.dom.root.onpointermove = (event2) => emit("mouseMove", event2);
      this.dom.root.onpointerup = (event2) => emit("mouseUp", event2);
    } else {
      this.dom.root.onmousemove = (event2) => emit("mouseMove", event2);
      this.dom.root.onmousedown = (event2) => emit("mouseDown", event2);
      this.dom.root.onmouseup = (event2) => emit("mouseUp", event2);
    }
    this.initialFitDone = false;
    this.on("changed", () => {
      if (me.itemsData == null) return;
      if (!me.initialFitDone && !me.options.rollingMode) {
        me.initialFitDone = true;
        if (me.options.start != void 0 || me.options.end != void 0) {
          if (me.options.start == void 0 || me.options.end == void 0) {
            var range = me.getItemRange();
          }
          const start = me.options.start != void 0 ? me.options.start : range.min;
          const end = me.options.end != void 0 ? me.options.end : range.max;
          me.setWindow(start, end, {
            animation: false
          });
        } else {
          me.fit({
            animation: false
          });
        }
      }
      if (!me.initialDrawDone && (me.initialRangeChangeDone || !me.options.start && !me.options.end || me.options.rollingMode)) {
        me.initialDrawDone = true;
        me.itemSet.initialDrawDone = true;
        me.dom.root.style.visibility = "visible";
        me.dom.loadingScreen.parentNode.removeChild(me.dom.loadingScreen);
        if (me.options.onInitialDrawComplete) {
          _setTimeout(() => {
            return me.options.onInitialDrawComplete();
          }, 0);
        }
      }
    });
    this.on("destroyTimeline", () => {
      me.destroy();
    });
    if (options) {
      this.setOptions(options);
    }
    this.body.emitter.on("fit", (args) => {
      this._onFit(args);
      this.redraw();
    });
    if (groups) {
      this.setGroups(groups);
    }
    if (items) {
      this.setItems(items);
    }
    this._redraw();
  }
  /**
   * Load a configurator
   * @return {Object}
   * @private
   */
  _createConfigurator() {
    return new Configurator2(this, this.dom.container, configureOptions$1);
  }
  /**
   * Force a redraw. The size of all items will be recalculated.
   * Can be useful to manually redraw when option autoResize=false and the window
   * has been resized, or when the items CSS has been changed.
   *
   * Note: this function will be overridden on construction with a trottled version
   */
  redraw() {
    this.itemSet && this.itemSet.markDirty({
      refreshItems: true
    });
    this._redraw();
  }
  /**
   * Remove an item from the group
   * @param {object} options
   */
  setOptions(options) {
    let errorFound2 = Validator2.validate(options, allOptions$1);
    if (errorFound2 === true) {
      console.log("%cErrors have been found in the supplied options object.", printStyle);
    }
    Core.prototype.setOptions.call(this, options);
    if ("type" in options) {
      if (options.type !== this.options.type) {
        this.options.type = options.type;
        const itemsData = this.itemsData;
        if (itemsData) {
          const selection = this.getSelection();
          this.setItems(null);
          this.setItems(itemsData.rawDS);
          this.setSelection(selection);
        }
      }
    }
  }
  /**
   * Set items
   * @param {vis.DataSet | Array | null} items
   */
  setItems(items) {
    this.itemsDone = false;
    let newDataSet;
    if (!items) {
      newDataSet = null;
    } else if (isDataViewLike(items)) {
      newDataSet = typeCoerceDataSet(items);
    } else {
      newDataSet = typeCoerceDataSet(new DataSet(items));
    }
    if (this.itemsData) {
      this.itemsData.dispose();
    }
    this.itemsData = newDataSet;
    this.itemSet && this.itemSet.setItems(newDataSet != null ? newDataSet.rawDS : null);
  }
  /**
   * Set groups
   * @param {vis.DataSet | Array} groups
   */
  setGroups(groups) {
    let newDataSet;
    const filter2 = (group) => group.visible !== false;
    if (!groups) {
      newDataSet = null;
    } else {
      if (_Array$isArray(groups)) groups = new DataSet(groups);
      newDataSet = new DataView(groups, {
        filter: filter2
      });
    }
    if (this.groupsData != null && typeof this.groupsData.setData === "function") {
      this.groupsData.setData(null);
    }
    this.groupsData = newDataSet;
    this.itemSet.setGroups(newDataSet);
  }
  /**
   * Set both items and groups in one go
   * @param {{items: (Array | vis.DataSet), groups: (Array | vis.DataSet)}} data
   */
  setData(data) {
    if (data && data.groups) {
      this.setGroups(data.groups);
    }
    if (data && data.items) {
      this.setItems(data.items);
    }
  }
  /**
   * Set selected items by their id. Replaces the current selection
   * Unknown id's are silently ignored.
   * @param {string[] | string} [ids]  An array with zero or more id's of the items to be
   *                                selected. If ids is an empty array, all items will be
   *                                unselected.
   * @param {Object} [options]      Available options:
   *                                `focus: boolean`
   *                                    If true, focus will be set to the selected item(s)
   *                                `animation: boolean | {duration: number, easingFunction: string}`
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   *                                    Only applicable when option focus is true.
   */
  setSelection(ids, options) {
    this.itemSet && this.itemSet.setSelection(ids);
    if (options && options.focus) {
      this.focus(ids, options);
    }
  }
  /**
   * Get the selected items by their id
   * @return {Array} ids  The ids of the selected items
   */
  getSelection() {
    return this.itemSet && this.itemSet.getSelection() || [];
  }
  /**
   * Adjust the visible window such that the selected item (or multiple items)
   * are centered on screen.
   * @param {string | String[]} id     An item id or array with item ids
   * @param {Object} [options]      Available options:
   *                                `animation: boolean | {duration: number, easingFunction: string}`
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   *                                `zoom: boolean`
   *                                    If true (default), the timeline will
   *                                    zoom on the element after focus it.
   */
  focus(id, options) {
    if (!this.itemsData || id == void 0) return;
    const ids = _Array$isArray(id) ? id : [id];
    const itemsData = this.itemsData.get(ids);
    let start = null;
    let end = null;
    _forEachInstanceProperty(itemsData).call(itemsData, (itemData) => {
      const s = itemData.start.valueOf();
      const e = "end" in itemData ? itemData.end.valueOf() : itemData.start.valueOf();
      if (start === null || s < start) {
        start = s;
      }
      if (end === null || e > end) {
        end = e;
      }
    });
    if (start !== null && end !== null) {
      const me = this;
      const item = this.itemSet.items[ids[0]];
      let startPos = this._getScrollTop() * -1;
      let initialVerticalScroll = null;
      const verticalAnimationFrame = (ease, willDraw, done) => {
        const verticalScroll = getItemVerticalScroll(me, item);
        if (verticalScroll === false) {
          return;
        }
        if (!initialVerticalScroll) {
          initialVerticalScroll = verticalScroll;
        }
        if (initialVerticalScroll.itemTop == verticalScroll.itemTop && !initialVerticalScroll.shouldScroll) {
          return;
        } else if (initialVerticalScroll.itemTop != verticalScroll.itemTop && verticalScroll.shouldScroll) {
          initialVerticalScroll = verticalScroll;
          startPos = me._getScrollTop() * -1;
        }
        const from = startPos;
        const to = initialVerticalScroll.scrollOffset;
        const scrollTop = done ? to : from + (to - from) * ease;
        me._setScrollTop(-scrollTop);
        if (!willDraw) {
          me._redraw();
        }
      };
      const setFinalVerticalPosition = () => {
        const finalVerticalScroll = getItemVerticalScroll(me, item);
        if (finalVerticalScroll.shouldScroll && finalVerticalScroll.itemTop != initialVerticalScroll.itemTop) {
          me._setScrollTop(-finalVerticalScroll.scrollOffset);
          me._redraw();
        }
      };
      const finalVerticalCallback = () => {
        setFinalVerticalPosition();
        _setTimeout(setFinalVerticalPosition, 100);
      };
      const zoom = options && options.zoom !== void 0 ? options.zoom : true;
      const middle = (start + end) / 2;
      const interval = zoom ? (end - start) * 1.1 : Math.max(this.range.end - this.range.start, (end - start) * 1.1);
      const animation = options && options.animation !== void 0 ? options.animation : true;
      if (!animation) {
        initialVerticalScroll = {
          shouldScroll: false,
          scrollOffset: -1,
          itemTop: -1
        };
      }
      this.range.stopRolling();
      this.range.setRange(middle - interval / 2, middle + interval / 2, {
        animation
      }, finalVerticalCallback, verticalAnimationFrame);
    }
  }
  /**
   * Set Timeline window such that it fits all items
   * @param {Object} [options]  Available options:
   *                                `animation: boolean | {duration: number, easingFunction: string}`
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   * @param {function} [callback]
   */
  fit(options, callback) {
    const animation = options && options.animation !== void 0 ? options.animation : true;
    let range;
    if (this.itemsData.length === 1 && this.itemsData.get()[0].end === void 0) {
      range = this.getDataRange();
      this.moveTo(range.min.valueOf(), {
        animation
      }, callback);
    } else {
      range = this.getItemRange();
      this.range.setRange(range.min, range.max, {
        animation
      }, callback);
    }
  }
  /**
   * Determine the range of the items, taking into account their actual width
   * and a margin of 10 pixels on both sides.
   *
   * @returns {{min: Date, max: Date}}
   */
  getItemRange() {
    const range = this.getDataRange();
    let min = range.min !== null ? range.min.valueOf() : null;
    let max = range.max !== null ? range.max.valueOf() : null;
    let minItem = null;
    let maxItem = null;
    if (min != null && max != null) {
      let interval = max - min;
      if (interval <= 0) {
        interval = 10;
      }
      const factor = interval / this.props.center.width;
      const redrawQueue = {};
      let redrawQueueLength = 0;
      _forEachInstanceProperty(availableUtils).call(availableUtils, this.itemSet.items, (item, key) => {
        if (item.groupShowing) {
          const returnQueue = true;
          redrawQueue[key] = item.redraw(returnQueue);
          redrawQueueLength = redrawQueue[key].length;
        }
      });
      const needRedraw = redrawQueueLength > 0;
      if (needRedraw) {
        for (let i = 0; i < redrawQueueLength; i++) {
          _forEachInstanceProperty(availableUtils).call(availableUtils, redrawQueue, (fns) => {
            fns[i]();
          });
        }
      }
      _forEachInstanceProperty(availableUtils).call(availableUtils, this.itemSet.items, (item) => {
        const start = getStart(item);
        const end = getEnd(item);
        let startSide;
        let endSide;
        if (this.options.rtl) {
          startSide = start - (item.getWidthRight() + 10) * factor;
          endSide = end + (item.getWidthLeft() + 10) * factor;
        } else {
          startSide = start - (item.getWidthLeft() + 10) * factor;
          endSide = end + (item.getWidthRight() + 10) * factor;
        }
        if (startSide < min) {
          min = startSide;
          minItem = item;
        }
        if (endSide > max) {
          max = endSide;
          maxItem = item;
        }
      });
      if (minItem && maxItem) {
        const lhs = minItem.getWidthLeft() + 10;
        const rhs = maxItem.getWidthRight() + 10;
        const delta = this.props.center.width - lhs - rhs;
        if (delta > 0) {
          if (this.options.rtl) {
            min = getStart(minItem) - rhs * interval / delta;
            max = getEnd(maxItem) + lhs * interval / delta;
          } else {
            min = getStart(minItem) - lhs * interval / delta;
            max = getEnd(maxItem) + rhs * interval / delta;
          }
        }
      }
    }
    return {
      min: min != null ? new Date(min) : null,
      max: max != null ? new Date(max) : null
    };
  }
  /**
   * Calculate the data range of the items start and end dates
   * @returns {{min: Date, max: Date}}
   */
  getDataRange() {
    let min = null;
    let max = null;
    if (this.itemsData) {
      var _context9;
      _forEachInstanceProperty(_context9 = this.itemsData).call(_context9, (item) => {
        const start = availableUtils.convert(item.start, "Date").valueOf();
        const end = availableUtils.convert(item.end != void 0 ? item.end : item.start, "Date").valueOf();
        if (min === null || start < min) {
          min = start;
        }
        if (max === null || end > max) {
          max = end;
        }
      });
    }
    return {
      min: min != null ? new Date(min) : null,
      max: max != null ? new Date(max) : null
    };
  }
  /**
   * Generate Timeline related information from an event
   * @param {Event} event
   * @return {Object} An object with related information, like on which area
   *                  The event happened, whether clicked on an item, etc.
   */
  getEventProperties(event2) {
    const clientX = event2.center ? event2.center.x : event2.clientX;
    const clientY = event2.center ? event2.center.y : event2.clientY;
    const centerContainerRect = this.dom.centerContainer.getBoundingClientRect();
    const x = this.options.rtl ? centerContainerRect.right - clientX : clientX - centerContainerRect.left;
    const y = clientY - centerContainerRect.top;
    const item = this.itemSet.itemFromTarget(event2);
    const group = this.itemSet.groupFromTarget(event2);
    const customTime = CustomTime.customTimeFromTarget(event2);
    const snap = this.itemSet.options.snap || null;
    const scale = this.body.util.getScale();
    const step = this.body.util.getStep();
    const time = this._toTime(x);
    const snappedTime = snap ? snap(time, scale, step) : time;
    const element = availableUtils.getTarget(event2);
    let what = null;
    if (item != null) {
      what = "item";
    } else if (customTime != null) {
      what = "custom-time";
    } else if (availableUtils.hasParent(element, this.timeAxis.dom.foreground)) {
      what = "axis";
    } else if (this.timeAxis2 && availableUtils.hasParent(element, this.timeAxis2.dom.foreground)) {
      what = "axis";
    } else if (availableUtils.hasParent(element, this.itemSet.dom.labelSet)) {
      what = "group-label";
    } else if (availableUtils.hasParent(element, this.currentTime.bar)) {
      what = "current-time";
    } else if (availableUtils.hasParent(element, this.dom.center)) {
      what = "background";
    }
    return {
      event: event2,
      item: item ? item.id : null,
      isCluster: item ? !!item.isCluster : false,
      items: item ? item.items || [] : null,
      group: group ? group.groupId : null,
      customTime: customTime ? customTime.options.id : null,
      what,
      pageX: event2.srcEvent ? event2.srcEvent.pageX : event2.pageX,
      pageY: event2.srcEvent ? event2.srcEvent.pageY : event2.pageY,
      x,
      y,
      time,
      snappedTime
    };
  }
  /**
   * Toggle Timeline rolling mode
   */
  toggleRollingMode() {
    if (this.range.rolling) {
      this.range.stopRolling();
    } else {
      if (this.options.rollingMode == void 0) {
        this.setOptions(this.options);
      }
      this.range.startRolling();
    }
  }
  /**
   * redraw
   * @private
   */
  _redraw() {
    Core.prototype._redraw.call(this);
  }
  /**
   * on fit callback
   * @param {object} args
   * @private
   */
  _onFit(args) {
    const {
      start,
      end,
      animation
    } = args;
    if (!end) {
      this.moveTo(start.valueOf(), {
        animation
      });
    } else {
      this.range.setRange(start, end, {
        animation
      });
    }
  }
};
function getStart(item) {
  return availableUtils.convert(item.data.start, "Date").valueOf();
}
function getEnd(item) {
  const end = item.data.end != void 0 ? item.data.end : item.data.start;
  return availableUtils.convert(end, "Date").valueOf();
}
function getItemVerticalScroll(timeline2, item) {
  if (!item.parent) {
    return false;
  }
  const itemsetHeight = timeline2.options.rtl ? timeline2.props.rightContainer.height : timeline2.props.leftContainer.height;
  const contentHeight = timeline2.props.center.height;
  const group = item.parent;
  let offset = group.top;
  let shouldScroll = true;
  const orientation = timeline2.timeAxis.options.orientation.axis;
  const itemTop = () => {
    if (orientation == "bottom") {
      return group.height - item.top - item.height;
    } else {
      return item.top;
    }
  };
  const currentScrollHeight = timeline2._getScrollTop() * -1;
  const targetOffset = offset + itemTop();
  const height = item.height;
  if (targetOffset < currentScrollHeight) {
    if (offset + itemsetHeight <= offset + itemTop() + height) {
      offset += itemTop() - timeline2.itemSet.options.margin.item.vertical;
    }
  } else if (targetOffset + height > currentScrollHeight + itemsetHeight) {
    offset += itemTop() + height - itemsetHeight + timeline2.itemSet.options.margin.item.vertical;
  } else {
    shouldScroll = false;
  }
  offset = Math.min(offset, contentHeight - itemsetHeight);
  return {
    shouldScroll,
    scrollOffset: offset,
    itemTop: targetOffset
  };
}
var DataScale = class {
  /**
   *
   * @param {number} start
   * @param {number} end
   * @param {boolean} autoScaleStart
   * @param {boolean} autoScaleEnd
   * @param {number} containerHeight
   * @param {number} majorCharHeight
   * @param {boolean} zeroAlign
   * @param {function} formattingFunction
   * @constructor DataScale
   */
  constructor(start, end, autoScaleStart, autoScaleEnd, containerHeight, majorCharHeight) {
    let zeroAlign = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
    let formattingFunction = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
    this.majorSteps = [1, 2, 5, 10];
    this.minorSteps = [0.25, 0.5, 1, 2];
    this.customLines = null;
    this.containerHeight = containerHeight;
    this.majorCharHeight = majorCharHeight;
    this._start = start;
    this._end = end;
    this.scale = 1;
    this.minorStepIdx = -1;
    this.magnitudefactor = 1;
    this.determineScale();
    this.zeroAlign = zeroAlign;
    this.autoScaleStart = autoScaleStart;
    this.autoScaleEnd = autoScaleEnd;
    this.formattingFunction = formattingFunction;
    if (autoScaleStart || autoScaleEnd) {
      const me = this;
      const roundToMinor = (value) => {
        const rounded = value - value % (me.magnitudefactor * me.minorSteps[me.minorStepIdx]);
        if (value % (me.magnitudefactor * me.minorSteps[me.minorStepIdx]) > 0.5 * (me.magnitudefactor * me.minorSteps[me.minorStepIdx])) {
          return rounded + me.magnitudefactor * me.minorSteps[me.minorStepIdx];
        } else {
          return rounded;
        }
      };
      if (autoScaleStart) {
        this._start -= this.magnitudefactor * 2 * this.minorSteps[this.minorStepIdx];
        this._start = roundToMinor(this._start);
      }
      if (autoScaleEnd) {
        this._end += this.magnitudefactor * this.minorSteps[this.minorStepIdx];
        this._end = roundToMinor(this._end);
      }
      this.determineScale();
    }
  }
  /**
   * set chart height
   * @param {number} majorCharHeight
   */
  setCharHeight(majorCharHeight) {
    this.majorCharHeight = majorCharHeight;
  }
  /**
   * set height
   * @param {number} containerHeight
   */
  setHeight(containerHeight) {
    this.containerHeight = containerHeight;
  }
  /**
   * determine scale
   */
  determineScale() {
    const range = this._end - this._start;
    this.scale = this.containerHeight / range;
    const minimumStepValue = this.majorCharHeight / this.scale;
    const orderOfMagnitude = range > 0 ? Math.round(Math.log(range) / Math.LN10) : 0;
    this.minorStepIdx = -1;
    this.magnitudefactor = Math.pow(10, orderOfMagnitude);
    let start = 0;
    if (orderOfMagnitude < 0) {
      start = orderOfMagnitude;
    }
    let solutionFound = false;
    for (let l = start; Math.abs(l) <= Math.abs(orderOfMagnitude); l++) {
      this.magnitudefactor = Math.pow(10, l);
      for (let j = 0; j < this.minorSteps.length; j++) {
        const stepSize = this.magnitudefactor * this.minorSteps[j];
        if (stepSize >= minimumStepValue) {
          solutionFound = true;
          this.minorStepIdx = j;
          break;
        }
      }
      if (solutionFound === true) {
        break;
      }
    }
  }
  /**
   * returns if value is major
   * @param {number} value
   * @returns {boolean}
   */
  is_major(value) {
    return value % (this.magnitudefactor * this.majorSteps[this.minorStepIdx]) === 0;
  }
  /**
   * returns step size
   * @returns {number}
   */
  getStep() {
    return this.magnitudefactor * this.minorSteps[this.minorStepIdx];
  }
  /**
   * returns first major
   * @returns {number}
   */
  getFirstMajor() {
    const majorStep = this.magnitudefactor * this.majorSteps[this.minorStepIdx];
    return this.convertValue(this._start + (majorStep - this._start % majorStep) % majorStep);
  }
  /**
   * returns first major
   * @param {date} current
   * @returns {date} formatted date
   */
  formatValue(current) {
    let returnValue = current.toPrecision(5);
    if (typeof this.formattingFunction === "function") {
      returnValue = this.formattingFunction(current);
    }
    if (typeof returnValue === "number") {
      return "".concat(returnValue);
    } else if (typeof returnValue === "string") {
      return returnValue;
    } else {
      return current.toPrecision(5);
    }
  }
  /**
   * returns lines
   * @returns {object} lines
   */
  getLines() {
    const lines = [];
    const step = this.getStep();
    const bottomOffset = (step - this._start % step) % step;
    for (let i = this._start + bottomOffset; this._end - i > 1e-5; i += step) {
      if (i != this._start) {
        lines.push({
          major: this.is_major(i),
          y: this.convertValue(i),
          val: this.formatValue(i)
        });
      }
    }
    return lines;
  }
  /**
   * follow scale
   * @param {object} other
   */
  followScale(other) {
    const oldStepIdx = this.minorStepIdx;
    const oldStart = this._start;
    const oldEnd = this._end;
    const me = this;
    const increaseMagnitude = () => {
      me.magnitudefactor *= 2;
    };
    const decreaseMagnitude = () => {
      me.magnitudefactor /= 2;
    };
    if (other.minorStepIdx <= 1 && this.minorStepIdx <= 1 || other.minorStepIdx > 1 && this.minorStepIdx > 1) ;
    else if (other.minorStepIdx < this.minorStepIdx) {
      this.minorStepIdx = 1;
      if (oldStepIdx == 2) {
        increaseMagnitude();
      } else {
        increaseMagnitude();
        increaseMagnitude();
      }
    } else {
      this.minorStepIdx = 2;
      if (oldStepIdx == 1) {
        decreaseMagnitude();
      } else {
        decreaseMagnitude();
        decreaseMagnitude();
      }
    }
    const otherZero = other.convertValue(0);
    const otherStep = other.getStep() * other.scale;
    let done = false;
    let count = 0;
    while (!done && count++ < 5) {
      this.scale = otherStep / (this.minorSteps[this.minorStepIdx] * this.magnitudefactor);
      const newRange = this.containerHeight / this.scale;
      this._start = oldStart;
      this._end = this._start + newRange;
      const myOriginalZero = this._end * this.scale;
      const majorStep = this.magnitudefactor * this.majorSteps[this.minorStepIdx];
      const majorOffset = this.getFirstMajor() - other.getFirstMajor();
      if (this.zeroAlign) {
        const zeroOffset = otherZero - myOriginalZero;
        this._end += zeroOffset / this.scale;
        this._start = this._end - newRange;
      } else {
        if (!this.autoScaleStart) {
          this._start += majorStep - majorOffset / this.scale;
          this._end = this._start + newRange;
        } else {
          this._start -= majorOffset / this.scale;
          this._end = this._start + newRange;
        }
      }
      if (!this.autoScaleEnd && this._end > oldEnd + 1e-5) {
        decreaseMagnitude();
        done = false;
        continue;
      }
      if (!this.autoScaleStart && this._start < oldStart - 1e-5) {
        if (this.zeroAlign && oldStart >= 0) {
          console.warn("Can't adhere to given 'min' range, due to zeroalign");
        } else {
          decreaseMagnitude();
          done = false;
          continue;
        }
      }
      if (this.autoScaleStart && this.autoScaleEnd && newRange < oldEnd - oldStart) {
        increaseMagnitude();
        done = false;
        continue;
      }
      done = true;
    }
  }
  /**
   * convert value
   * @param {number} value
   * @returns {number}
   */
  convertValue(value) {
    return this.containerHeight - (value - this._start) * this.scale;
  }
  /**
   * returns screen to value
   * @param {number} pixels
   * @returns {number}
   */
  screenToValue(pixels) {
    return (this.containerHeight - pixels) / this.scale + this._start;
  }
};
var DataAxis = class extends Component {
  /**
   * @param {Object} body
   * @param {Object} [options]        See DataAxis.setOptions for the available
   *                                  options.
   * @param {SVGElement} svg
   * @param {timeline.LineGraph.options} linegraphOptions
   * @constructor DataAxis
   * @extends Component
   */
  constructor(body, options, svg, linegraphOptions) {
    super();
    this.id = v4();
    this.body = body;
    this.defaultOptions = {
      orientation: "left",
      // supported: 'left', 'right'
      showMinorLabels: true,
      showMajorLabels: true,
      showWeekScale: false,
      icons: false,
      majorLinesOffset: 7,
      minorLinesOffset: 4,
      labelOffsetX: 10,
      labelOffsetY: 2,
      iconWidth: 20,
      width: "40px",
      visible: true,
      alignZeros: true,
      left: {
        range: {
          min: void 0,
          max: void 0
        },
        format(value) {
          return "".concat(_parseFloat(value.toPrecision(3)));
        },
        title: {
          text: void 0,
          style: void 0
        }
      },
      right: {
        range: {
          min: void 0,
          max: void 0
        },
        format(value) {
          return "".concat(_parseFloat(value.toPrecision(3)));
        },
        title: {
          text: void 0,
          style: void 0
        }
      }
    };
    this.linegraphOptions = linegraphOptions;
    this.linegraphSVG = svg;
    this.props = {};
    this.DOMelements = {
      // dynamic elements
      lines: {},
      labels: {},
      title: {}
    };
    this.dom = {};
    this.scale = void 0;
    this.range = {
      start: 0,
      end: 0
    };
    this.options = availableUtils.extend({}, this.defaultOptions);
    this.conversionFactor = 1;
    this.setOptions(options);
    this.width = Number("".concat(this.options.width).replace("px", ""));
    this.minWidth = this.width;
    this.height = this.linegraphSVG.getBoundingClientRect().height;
    this.hidden = false;
    this.stepPixels = 25;
    this.zeroCrossing = -1;
    this.amountOfSteps = -1;
    this.lineOffset = 0;
    this.master = true;
    this.masterAxis = null;
    this.svgElements = {};
    this.iconsRemoved = false;
    this.groups = {};
    this.amountOfGroups = 0;
    this._create();
    if (this.scale == void 0) {
      this._redrawLabels();
    }
    this.framework = {
      svg: this.svg,
      svgElements: this.svgElements,
      options: this.options,
      groups: this.groups
    };
    const me = this;
    this.body.emitter.on("verticalDrag", () => {
      me.dom.lineContainer.style.top = "".concat(me.body.domProps.scrollTop, "px");
    });
  }
  /**
   * Adds group to data axis
   * @param {string} label
   * @param {object} graphOptions
   */
  addGroup(label, graphOptions) {
    if (!Object.prototype.hasOwnProperty.call(this.groups, label)) {
      this.groups[label] = graphOptions;
    }
    this.amountOfGroups += 1;
  }
  /**
   * updates group of data axis
   * @param {string} label
   * @param {object} graphOptions
   */
  updateGroup(label, graphOptions) {
    if (!Object.prototype.hasOwnProperty.call(this.groups, label)) {
      this.amountOfGroups += 1;
    }
    this.groups[label] = graphOptions;
  }
  /**
   * removes group of data axis
   * @param {string} label
   */
  removeGroup(label) {
    if (Object.prototype.hasOwnProperty.call(this.groups, label)) {
      delete this.groups[label];
      this.amountOfGroups -= 1;
    }
  }
  /**
   * sets options
   * @param {object} options
   */
  setOptions(options) {
    if (options) {
      let redraw = false;
      if (this.options.orientation != options.orientation && options.orientation !== void 0) {
        redraw = true;
      }
      const fields = ["orientation", "showMinorLabels", "showMajorLabels", "icons", "majorLinesOffset", "minorLinesOffset", "labelOffsetX", "labelOffsetY", "iconWidth", "width", "visible", "left", "right", "alignZeros"];
      availableUtils.selectiveDeepExtend(fields, this.options, options);
      this.minWidth = Number("".concat(this.options.width).replace("px", ""));
      if (redraw === true && this.dom.frame) {
        this.hide();
        this.show();
      }
    }
  }
  /**
   * Create the HTML DOM for the DataAxis
   */
  _create() {
    this.dom.frame = document.createElement("div");
    this.dom.frame.style.width = this.options.width;
    this.dom.frame.style.height = this.height;
    this.dom.lineContainer = document.createElement("div");
    this.dom.lineContainer.style.width = "100%";
    this.dom.lineContainer.style.height = this.height;
    this.dom.lineContainer.style.position = "relative";
    this.dom.lineContainer.style.visibility = "visible";
    this.dom.lineContainer.style.display = "block";
    this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this.svg.style.position = "absolute";
    this.svg.style.top = "0px";
    this.svg.style.height = "100%";
    this.svg.style.width = "100%";
    this.svg.style.display = "block";
    this.dom.frame.appendChild(this.svg);
  }
  /**
   * redraws groups icons
   */
  _redrawGroupIcons() {
    prepareElements(this.svgElements);
    let x;
    const iconWidth = this.options.iconWidth;
    const iconHeight = 15;
    const iconOffset = 4;
    let y = iconOffset + 0.5 * iconHeight;
    if (this.options.orientation === "left") {
      x = iconOffset;
    } else {
      x = this.width - iconWidth - iconOffset;
    }
    const groupArray = _Object$keys(this.groups);
    _sortInstanceProperty(groupArray).call(groupArray, (a, b) => a < b ? -1 : 1);
    for (const groupId of groupArray) {
      if (this.groups[groupId].visible === true && (this.linegraphOptions.visibility[groupId] === void 0 || this.linegraphOptions.visibility[groupId] === true)) {
        this.groups[groupId].getLegend(iconWidth, iconHeight, this.framework, x, y);
        y += iconHeight + iconOffset;
      }
    }
    cleanupElements(this.svgElements);
    this.iconsRemoved = false;
  }
  /**
   * Cleans up icons
   */
  _cleanupIcons() {
    if (this.iconsRemoved === false) {
      prepareElements(this.svgElements);
      cleanupElements(this.svgElements);
      this.iconsRemoved = true;
    }
  }
  /**
   * Create the HTML DOM for the DataAxis
   */
  show() {
    this.hidden = false;
    if (!this.dom.frame.parentNode) {
      if (this.options.orientation === "left") {
        this.body.dom.left.appendChild(this.dom.frame);
      } else {
        this.body.dom.right.appendChild(this.dom.frame);
      }
    }
    if (!this.dom.lineContainer.parentNode) {
      this.body.dom.backgroundHorizontal.appendChild(this.dom.lineContainer);
    }
    this.dom.lineContainer.style.display = "block";
  }
  /**
   * Create the HTML DOM for the DataAxis
   */
  hide() {
    this.hidden = true;
    if (this.dom.frame.parentNode) {
      this.dom.frame.parentNode.removeChild(this.dom.frame);
    }
    this.dom.lineContainer.style.display = "none";
  }
  /**
   * Set a range (start and end)
   * @param {number} start
   * @param {number} end
   */
  setRange(start, end) {
    this.range.start = start;
    this.range.end = end;
  }
  /**
   * Repaint the component
   * @return {boolean} Returns true if the component is resized
   */
  redraw() {
    let resized = false;
    let activeGroups = 0;
    this.dom.lineContainer.style.top = "".concat(this.body.domProps.scrollTop, "px");
    for (const groupId in this.groups) {
      if (!Object.prototype.hasOwnProperty.call(this.groups, groupId)) continue;
      if (this.groups[groupId].visible === true && (this.linegraphOptions.visibility[groupId] === void 0 || this.linegraphOptions.visibility[groupId] === true)) activeGroups++;
    }
    if (this.amountOfGroups === 0 || activeGroups === 0) {
      this.hide();
    } else {
      this.show();
      this.height = Number(this.linegraphSVG.style.height.replace("px", ""));
      this.dom.lineContainer.style.height = "".concat(this.height, "px");
      this.width = this.options.visible === true ? Number("".concat(this.options.width).replace("px", "")) : 0;
      const props = this.props;
      const frame = this.dom.frame;
      frame.className = "vis-data-axis";
      this._calculateCharSize();
      const orientation = this.options.orientation;
      const showMinorLabels = this.options.showMinorLabels;
      const showMajorLabels = this.options.showMajorLabels;
      const backgroundHorizontalOffsetWidth = this.body.dom.backgroundHorizontal.offsetWidth;
      props.minorLabelHeight = showMinorLabels ? props.minorCharHeight : 0;
      props.majorLabelHeight = showMajorLabels ? props.majorCharHeight : 0;
      props.minorLineWidth = backgroundHorizontalOffsetWidth - this.lineOffset - this.width + 2 * this.options.minorLinesOffset;
      props.minorLineHeight = 1;
      props.majorLineWidth = backgroundHorizontalOffsetWidth - this.lineOffset - this.width + 2 * this.options.majorLinesOffset;
      props.majorLineHeight = 1;
      if (orientation === "left") {
        frame.style.top = "0";
        frame.style.left = "0";
        frame.style.bottom = "";
        frame.style.width = "".concat(this.width, "px");
        frame.style.height = "".concat(this.height, "px");
        this.props.width = this.body.domProps.left.width;
        this.props.height = this.body.domProps.left.height;
      } else {
        frame.style.top = "";
        frame.style.bottom = "0";
        frame.style.left = "0";
        frame.style.width = "".concat(this.width, "px");
        frame.style.height = "".concat(this.height, "px");
        this.props.width = this.body.domProps.right.width;
        this.props.height = this.body.domProps.right.height;
      }
      resized = this._redrawLabels();
      resized = this._isResized() || resized;
      if (this.options.icons === true) {
        this._redrawGroupIcons();
      } else {
        this._cleanupIcons();
      }
      this._redrawTitle(orientation);
    }
    return resized;
  }
  /**
   * Repaint major and minor text labels and vertical grid lines
   *
   * @returns {boolean}
   * @private
   */
  _redrawLabels() {
    let resized = false;
    prepareElements(this.DOMelements.lines);
    prepareElements(this.DOMelements.labels);
    const orientation = this.options["orientation"];
    const customRange = this.options[orientation].range != void 0 ? this.options[orientation].range : {};
    let autoScaleEnd = true;
    if (customRange.max != void 0) {
      this.range.end = customRange.max;
      autoScaleEnd = false;
    }
    let autoScaleStart = true;
    if (customRange.min != void 0) {
      this.range.start = customRange.min;
      autoScaleStart = false;
    }
    this.scale = new DataScale(this.range.start, this.range.end, autoScaleStart, autoScaleEnd, this.dom.frame.offsetHeight, this.props.majorCharHeight, this.options.alignZeros, this.options[orientation].format);
    if (this.master === false && this.masterAxis != void 0) {
      this.scale.followScale(this.masterAxis.scale);
      this.dom.lineContainer.style.display = "none";
    } else {
      this.dom.lineContainer.style.display = "block";
    }
    this.maxLabelSize = 0;
    const lines = this.scale.getLines();
    _forEachInstanceProperty(lines).call(lines, (line) => {
      const y = line.y;
      const isMajor = line.major;
      if (this.options["showMinorLabels"] && isMajor === false) {
        this._redrawLabel(y - 2, line.val, orientation, "vis-y-axis vis-minor", this.props.minorCharHeight);
      }
      if (isMajor) {
        if (y >= 0) {
          this._redrawLabel(y - 2, line.val, orientation, "vis-y-axis vis-major", this.props.majorCharHeight);
        }
      }
      if (this.master === true) {
        if (isMajor) {
          this._redrawLine(y, orientation, "vis-grid vis-horizontal vis-major", this.options.majorLinesOffset, this.props.majorLineWidth);
        } else {
          this._redrawLine(y, orientation, "vis-grid vis-horizontal vis-minor", this.options.minorLinesOffset, this.props.minorLineWidth);
        }
      }
    });
    let titleWidth = 0;
    if (this.options[orientation].title !== void 0 && this.options[orientation].title.text !== void 0) {
      titleWidth = this.props.titleCharHeight;
    }
    const offset = this.options.icons === true ? Math.max(this.options.iconWidth, titleWidth) + this.options.labelOffsetX + 15 : titleWidth + this.options.labelOffsetX + 15;
    if (this.maxLabelSize > this.width - offset && this.options.visible === true) {
      this.width = this.maxLabelSize + offset;
      this.options.width = "".concat(this.width, "px");
      cleanupElements(this.DOMelements.lines);
      cleanupElements(this.DOMelements.labels);
      this.redraw();
      resized = true;
    } else if (this.maxLabelSize < this.width - offset && this.options.visible === true && this.width > this.minWidth) {
      this.width = Math.max(this.minWidth, this.maxLabelSize + offset);
      this.options.width = "".concat(this.width, "px");
      cleanupElements(this.DOMelements.lines);
      cleanupElements(this.DOMelements.labels);
      this.redraw();
      resized = true;
    } else {
      cleanupElements(this.DOMelements.lines);
      cleanupElements(this.DOMelements.labels);
      resized = false;
    }
    return resized;
  }
  /**
   * converts value
   * @param {number} value
   * @returns {number} converted number
   */
  convertValue(value) {
    return this.scale.convertValue(value);
  }
  /**
   * converts value
   * @param {number} x
   * @returns {number} screen value
   */
  screenToValue(x) {
    return this.scale.screenToValue(x);
  }
  /**
   * Create a label for the axis at position x
   *
   * @param {number} y
   * @param {string} text
   * @param {'top'|'right'|'bottom'|'left'} orientation
   * @param {string} className
   * @param {number} characterHeight
   * @private
   */
  _redrawLabel(y, text, orientation, className, characterHeight) {
    const label = getDOMElement("div", this.DOMelements.labels, this.dom.frame);
    label.className = className;
    label.innerHTML = availableUtils.xss(text);
    if (orientation === "left") {
      label.style.left = "-".concat(this.options.labelOffsetX, "px");
      label.style.textAlign = "right";
    } else {
      label.style.right = "-".concat(this.options.labelOffsetX, "px");
      label.style.textAlign = "left";
    }
    label.style.top = "".concat(y - 0.5 * characterHeight + this.options.labelOffsetY, "px");
    text += "";
    const largestWidth = Math.max(this.props.majorCharWidth, this.props.minorCharWidth);
    if (this.maxLabelSize < text.length * largestWidth) {
      this.maxLabelSize = text.length * largestWidth;
    }
  }
  /**
   * Create a minor line for the axis at position y
   * @param {number} y
   * @param {'top'|'right'|'bottom'|'left'} orientation
   * @param {string} className
   * @param {number} offset
   * @param {number} width
   */
  _redrawLine(y, orientation, className, offset, width) {
    if (this.master === true) {
      const line = getDOMElement("div", this.DOMelements.lines, this.dom.lineContainer);
      line.className = className;
      line.innerHTML = "";
      if (orientation === "left") {
        line.style.left = "".concat(this.width - offset, "px");
      } else {
        line.style.right = "".concat(this.width - offset, "px");
      }
      line.style.width = "".concat(width, "px");
      line.style.top = "".concat(y, "px");
    }
  }
  /**
   * Create a title for the axis
   * @private
   * @param {'top'|'right'|'bottom'|'left'} orientation
   */
  _redrawTitle(orientation) {
    prepareElements(this.DOMelements.title);
    if (this.options[orientation].title !== void 0 && this.options[orientation].title.text !== void 0) {
      const title = getDOMElement("div", this.DOMelements.title, this.dom.frame);
      title.className = "vis-y-axis vis-title vis-".concat(orientation);
      title.innerHTML = availableUtils.xss(this.options[orientation].title.text);
      if (this.options[orientation].title.style !== void 0) {
        availableUtils.addCssText(title, this.options[orientation].title.style);
      }
      if (orientation === "left") {
        title.style.left = "".concat(this.props.titleCharHeight, "px");
      } else {
        title.style.right = "".concat(this.props.titleCharHeight, "px");
      }
      title.style.width = "".concat(this.height, "px");
    }
    cleanupElements(this.DOMelements.title);
  }
  /**
   * Determine the size of text on the axis (both major and minor axis).
   * The size is calculated only once and then cached in this.props.
   * @private
   */
  _calculateCharSize() {
    if (!("minorCharHeight" in this.props)) {
      const textMinor = document.createTextNode("0");
      const measureCharMinor = document.createElement("div");
      measureCharMinor.className = "vis-y-axis vis-minor vis-measure";
      measureCharMinor.appendChild(textMinor);
      this.dom.frame.appendChild(measureCharMinor);
      this.props.minorCharHeight = measureCharMinor.clientHeight;
      this.props.minorCharWidth = measureCharMinor.clientWidth;
      this.dom.frame.removeChild(measureCharMinor);
    }
    if (!("majorCharHeight" in this.props)) {
      const textMajor = document.createTextNode("0");
      const measureCharMajor = document.createElement("div");
      measureCharMajor.className = "vis-y-axis vis-major vis-measure";
      measureCharMajor.appendChild(textMajor);
      this.dom.frame.appendChild(measureCharMajor);
      this.props.majorCharHeight = measureCharMajor.clientHeight;
      this.props.majorCharWidth = measureCharMajor.clientWidth;
      this.dom.frame.removeChild(measureCharMajor);
    }
    if (!("titleCharHeight" in this.props)) {
      const textTitle = document.createTextNode("0");
      const measureCharTitle = document.createElement("div");
      measureCharTitle.className = "vis-y-axis vis-title vis-measure";
      measureCharTitle.appendChild(textTitle);
      this.dom.frame.appendChild(measureCharTitle);
      this.props.titleCharHeight = measureCharTitle.clientHeight;
      this.props.titleCharWidth = measureCharTitle.clientWidth;
      this.dom.frame.removeChild(measureCharTitle);
    }
  }
};
function Points() {
}
Points.draw = function(dataset, group, framework, offset) {
  offset = offset || 0;
  var callback = getCallback(framework, group);
  for (var i = 0; i < dataset.length; i++) {
    if (!callback) {
      drawPoint(dataset[i].screen_x + offset, dataset[i].screen_y, getGroupTemplate(group), framework.svgElements, framework.svg, dataset[i].label);
    } else {
      var callbackResult = callback(dataset[i], group);
      if (callbackResult === true || typeof callbackResult === "object") {
        drawPoint(dataset[i].screen_x + offset, dataset[i].screen_y, getGroupTemplate(group, callbackResult), framework.svgElements, framework.svg, dataset[i].label);
      }
    }
  }
};
Points.drawIcon = function(group, x, y, iconWidth, iconHeight, framework) {
  var fillHeight = iconHeight * 0.5;
  var outline = getSVGElement("rect", framework.svgElements, framework.svg);
  outline.setAttributeNS(null, "x", x);
  outline.setAttributeNS(null, "y", y - fillHeight);
  outline.setAttributeNS(null, "width", iconWidth);
  outline.setAttributeNS(null, "height", 2 * fillHeight);
  outline.setAttributeNS(null, "class", "vis-outline");
  drawPoint(x + 0.5 * iconWidth, y, getGroupTemplate(group), framework.svgElements, framework.svg);
};
function getGroupTemplate(group, callbackResult) {
  callbackResult = typeof callbackResult === "undefined" ? {} : callbackResult;
  return {
    style: callbackResult.style || group.options.drawPoints.style,
    styles: callbackResult.styles || group.options.drawPoints.styles,
    size: callbackResult.size || group.options.drawPoints.size,
    className: callbackResult.className || group.className
  };
}
function getCallback(framework, group) {
  var callback = void 0;
  if (framework.options && framework.options.drawPoints && framework.options.drawPoints.onRender && typeof framework.options.drawPoints.onRender == "function") {
    callback = framework.options.drawPoints.onRender;
  }
  if (group.group.options && group.group.options.drawPoints && group.group.options.drawPoints.onRender && typeof group.group.options.drawPoints.onRender == "function") {
    callback = group.group.options.drawPoints.onRender;
  }
  return callback;
}
function Bargraph() {
}
Bargraph.drawIcon = function(group, x, y, iconWidth, iconHeight, framework) {
  var fillHeight = iconHeight * 0.5;
  var outline = getSVGElement("rect", framework.svgElements, framework.svg);
  outline.setAttributeNS(null, "x", x);
  outline.setAttributeNS(null, "y", y - fillHeight);
  outline.setAttributeNS(null, "width", iconWidth);
  outline.setAttributeNS(null, "height", 2 * fillHeight);
  outline.setAttributeNS(null, "class", "vis-outline");
  var barWidth = Math.round(0.3 * iconWidth);
  var originalWidth = group.options.barChart.width;
  var scale = originalWidth / barWidth;
  var bar1Height = Math.round(0.4 * iconHeight);
  var bar2Height = Math.round(0.75 * iconHeight);
  var offset = Math.round((iconWidth - 2 * barWidth) / 3);
  drawBar(x + 0.5 * barWidth + offset, y + fillHeight - bar1Height - 1, barWidth, bar1Height, group.className + " vis-bar", framework.svgElements, framework.svg, group.style);
  drawBar(x + 1.5 * barWidth + offset + 2, y + fillHeight - bar2Height - 1, barWidth, bar2Height, group.className + " vis-bar", framework.svgElements, framework.svg, group.style);
  if (group.options.drawPoints.enabled == true) {
    var groupTemplate = {
      style: group.options.drawPoints.style,
      styles: group.options.drawPoints.styles,
      size: group.options.drawPoints.size / scale,
      className: group.className
    };
    drawPoint(x + 0.5 * barWidth + offset, y + fillHeight - bar1Height - 1, groupTemplate, framework.svgElements, framework.svg);
    drawPoint(x + 1.5 * barWidth + offset + 2, y + fillHeight - bar2Height - 1, groupTemplate, framework.svgElements, framework.svg);
  }
};
Bargraph.draw = function(groupIds, processedGroupData, framework) {
  var combinedData = [];
  var intersections = {};
  var coreDistance;
  var key, drawData;
  var group;
  var i, j;
  var barPoints = 0;
  for (i = 0; i < groupIds.length; i++) {
    group = framework.groups[groupIds[i]];
    if (group.options.style === "bar") {
      if (group.visible === true && (framework.options.groups.visibility[groupIds[i]] === void 0 || framework.options.groups.visibility[groupIds[i]] === true)) {
        for (j = 0; j < processedGroupData[groupIds[i]].length; j++) {
          combinedData.push({
            screen_x: processedGroupData[groupIds[i]][j].screen_x,
            screen_end: processedGroupData[groupIds[i]][j].screen_end,
            screen_y: processedGroupData[groupIds[i]][j].screen_y,
            x: processedGroupData[groupIds[i]][j].x,
            end: processedGroupData[groupIds[i]][j].end,
            y: processedGroupData[groupIds[i]][j].y,
            groupId: groupIds[i],
            label: processedGroupData[groupIds[i]][j].label
          });
          barPoints += 1;
        }
      }
    }
  }
  if (barPoints === 0) {
    return;
  }
  _sortInstanceProperty(combinedData).call(combinedData, function(a, b) {
    if (a.screen_x === b.screen_x) {
      return a.groupId < b.groupId ? -1 : 1;
    } else {
      return a.screen_x - b.screen_x;
    }
  });
  Bargraph._getDataIntersections(intersections, combinedData);
  for (i = 0; i < combinedData.length; i++) {
    group = framework.groups[combinedData[i].groupId];
    var minWidth = group.options.barChart.minWidth != void 0 ? group.options.barChart.minWidth : 0.1 * group.options.barChart.width;
    key = combinedData[i].screen_x;
    var heightOffset = 0;
    if (intersections[key] === void 0) {
      if (i + 1 < combinedData.length) {
        coreDistance = Math.abs(combinedData[i + 1].screen_x - key);
      }
      drawData = Bargraph._getSafeDrawData(coreDistance, group, minWidth);
    } else {
      var nextKey = i + (intersections[key].amount - intersections[key].resolved);
      if (nextKey < combinedData.length) {
        coreDistance = Math.abs(combinedData[nextKey].screen_x - key);
      }
      drawData = Bargraph._getSafeDrawData(coreDistance, group, minWidth);
      intersections[key].resolved += 1;
      if (group.options.stack === true && group.options.excludeFromStacking !== true) {
        if (combinedData[i].screen_y < group.zeroPosition) {
          heightOffset = intersections[key].accumulatedNegative;
          intersections[key].accumulatedNegative += group.zeroPosition - combinedData[i].screen_y;
        } else {
          heightOffset = intersections[key].accumulatedPositive;
          intersections[key].accumulatedPositive += group.zeroPosition - combinedData[i].screen_y;
        }
      } else if (group.options.barChart.sideBySide === true) {
        drawData.width = drawData.width / intersections[key].amount;
        drawData.offset += intersections[key].resolved * drawData.width - 0.5 * drawData.width * (intersections[key].amount + 1);
      }
    }
    let dataWidth = drawData.width;
    let start = combinedData[i].screen_x;
    if (combinedData[i].screen_end != void 0) {
      dataWidth = combinedData[i].screen_end - combinedData[i].screen_x;
      start += dataWidth * 0.5;
    } else {
      start += drawData.offset;
    }
    drawBar(start, combinedData[i].screen_y - heightOffset, dataWidth, group.zeroPosition - combinedData[i].screen_y, group.className + " vis-bar", framework.svgElements, framework.svg, group.style);
    if (group.options.drawPoints.enabled === true) {
      let pointData = {
        screen_x: combinedData[i].screen_x,
        screen_y: combinedData[i].screen_y - heightOffset,
        x: combinedData[i].x,
        y: combinedData[i].y,
        groupId: combinedData[i].groupId,
        label: combinedData[i].label
      };
      Points.draw([pointData], group, framework, drawData.offset);
    }
  }
};
Bargraph._getDataIntersections = function(intersections, combinedData) {
  var coreDistance;
  for (var i = 0; i < combinedData.length; i++) {
    if (i + 1 < combinedData.length) {
      coreDistance = Math.abs(combinedData[i + 1].screen_x - combinedData[i].screen_x);
    }
    if (i > 0) {
      coreDistance = Math.min(coreDistance, Math.abs(combinedData[i - 1].screen_x - combinedData[i].screen_x));
    }
    if (coreDistance === 0) {
      if (intersections[combinedData[i].screen_x] === void 0) {
        intersections[combinedData[i].screen_x] = {
          amount: 0,
          resolved: 0,
          accumulatedPositive: 0,
          accumulatedNegative: 0
        };
      }
      intersections[combinedData[i].screen_x].amount += 1;
    }
  }
};
Bargraph._getSafeDrawData = function(coreDistance, group, minWidth) {
  var width, offset;
  if (coreDistance < group.options.barChart.width && coreDistance > 0) {
    width = coreDistance < minWidth ? minWidth : coreDistance;
    offset = 0;
    if (group.options.barChart.align === "left") {
      offset -= 0.5 * coreDistance;
    } else if (group.options.barChart.align === "right") {
      offset += 0.5 * coreDistance;
    }
  } else {
    width = group.options.barChart.width;
    offset = 0;
    if (group.options.barChart.align === "left") {
      offset -= 0.5 * group.options.barChart.width;
    } else if (group.options.barChart.align === "right") {
      offset += 0.5 * group.options.barChart.width;
    }
  }
  return {
    width,
    offset
  };
};
Bargraph.getStackedYRange = function(combinedData, groupRanges, groupIds, groupLabel, orientation) {
  if (combinedData.length > 0) {
    _sortInstanceProperty(combinedData).call(combinedData, function(a, b) {
      if (a.screen_x === b.screen_x) {
        return a.groupId < b.groupId ? -1 : 1;
      } else {
        return a.screen_x - b.screen_x;
      }
    });
    var intersections = {};
    Bargraph._getDataIntersections(intersections, combinedData);
    groupRanges[groupLabel] = Bargraph._getStackedYRange(intersections, combinedData);
    groupRanges[groupLabel].yAxisOrientation = orientation;
    groupIds.push(groupLabel);
  }
};
Bargraph._getStackedYRange = function(intersections, combinedData) {
  var key;
  var yMin = combinedData[0].screen_y;
  var yMax = combinedData[0].screen_y;
  for (var i = 0; i < combinedData.length; i++) {
    key = combinedData[i].screen_x;
    if (intersections[key] === void 0) {
      yMin = yMin > combinedData[i].screen_y ? combinedData[i].screen_y : yMin;
      yMax = yMax < combinedData[i].screen_y ? combinedData[i].screen_y : yMax;
    } else {
      if (combinedData[i].screen_y < 0) {
        intersections[key].accumulatedNegative += combinedData[i].screen_y;
      } else {
        intersections[key].accumulatedPositive += combinedData[i].screen_y;
      }
    }
  }
  for (var xpos in intersections) {
    if (!Object.prototype.hasOwnProperty.call(intersections, xpos)) continue;
    yMin = yMin > intersections[xpos].accumulatedNegative ? intersections[xpos].accumulatedNegative : yMin;
    yMin = yMin > intersections[xpos].accumulatedPositive ? intersections[xpos].accumulatedPositive : yMin;
    yMax = yMax < intersections[xpos].accumulatedNegative ? intersections[xpos].accumulatedNegative : yMax;
    yMax = yMax < intersections[xpos].accumulatedPositive ? intersections[xpos].accumulatedPositive : yMax;
  }
  return {
    min: yMin,
    max: yMax
  };
};
function Line() {
}
Line.calcPath = function(dataset, group) {
  if (dataset != null) {
    if (dataset.length > 0) {
      var d = [];
      if (group.options.interpolation.enabled == true) {
        d = Line._catmullRom(dataset, group);
      } else {
        d = Line._linear(dataset);
      }
      return d;
    }
  }
};
Line.drawIcon = function(group, x, y, iconWidth, iconHeight, framework) {
  var fillHeight = iconHeight * 0.5;
  var path2, fillPath;
  var outline = getSVGElement("rect", framework.svgElements, framework.svg);
  outline.setAttributeNS(null, "x", x);
  outline.setAttributeNS(null, "y", y - fillHeight);
  outline.setAttributeNS(null, "width", iconWidth);
  outline.setAttributeNS(null, "height", 2 * fillHeight);
  outline.setAttributeNS(null, "class", "vis-outline");
  path2 = getSVGElement("path", framework.svgElements, framework.svg);
  path2.setAttributeNS(null, "class", group.className);
  if (group.style !== void 0) {
    path2.setAttributeNS(null, "style", group.style);
  }
  path2.setAttributeNS(null, "d", "M" + x + "," + y + " L" + (x + iconWidth) + "," + y);
  if (group.options.shaded.enabled == true) {
    fillPath = getSVGElement("path", framework.svgElements, framework.svg);
    if (group.options.shaded.orientation == "top") {
      fillPath.setAttributeNS(null, "d", "M" + x + ", " + (y - fillHeight) + "L" + x + "," + y + " L" + (x + iconWidth) + "," + y + " L" + (x + iconWidth) + "," + (y - fillHeight));
    } else {
      fillPath.setAttributeNS(null, "d", "M" + x + "," + y + " L" + x + "," + (y + fillHeight) + " L" + (x + iconWidth) + "," + (y + fillHeight) + "L" + (x + iconWidth) + "," + y);
    }
    fillPath.setAttributeNS(null, "class", group.className + " vis-icon-fill");
    if (group.options.shaded.style !== void 0 && group.options.shaded.style !== "") {
      fillPath.setAttributeNS(null, "style", group.options.shaded.style);
    }
  }
  if (group.options.drawPoints.enabled == true) {
    var groupTemplate = {
      style: group.options.drawPoints.style,
      styles: group.options.drawPoints.styles,
      size: group.options.drawPoints.size,
      className: group.className
    };
    drawPoint(x + 0.5 * iconWidth, y, groupTemplate, framework.svgElements, framework.svg);
  }
};
Line.drawShading = function(pathArray, group, subPathArray, framework) {
  if (group.options.shaded.enabled == true) {
    var svgHeight = Number(framework.svg.style.height.replace("px", ""));
    var fillPath = getSVGElement("path", framework.svgElements, framework.svg);
    var type = "L";
    if (group.options.interpolation.enabled == true) {
      type = "C";
    }
    var dFill;
    var zero = 0;
    if (group.options.shaded.orientation == "top") {
      zero = 0;
    } else if (group.options.shaded.orientation == "bottom") {
      zero = svgHeight;
    } else {
      zero = Math.min(Math.max(0, group.zeroPosition), svgHeight);
    }
    if (group.options.shaded.orientation == "group" && subPathArray != null && subPathArray != void 0) {
      dFill = "M" + pathArray[0][0] + "," + pathArray[0][1] + " " + this.serializePath(pathArray, type, false) + " L" + subPathArray[subPathArray.length - 1][0] + "," + subPathArray[subPathArray.length - 1][1] + " " + this.serializePath(subPathArray, type, true) + subPathArray[0][0] + "," + subPathArray[0][1] + " Z";
    } else {
      dFill = "M" + pathArray[0][0] + "," + pathArray[0][1] + " " + this.serializePath(pathArray, type, false) + " V" + zero + " H" + pathArray[0][0] + " Z";
    }
    fillPath.setAttributeNS(null, "class", group.className + " vis-fill");
    if (group.options.shaded.style !== void 0) {
      fillPath.setAttributeNS(null, "style", group.options.shaded.style);
    }
    fillPath.setAttributeNS(null, "d", dFill);
  }
};
Line.draw = function(pathArray, group, framework) {
  if (pathArray != null && pathArray != void 0) {
    var path2 = getSVGElement("path", framework.svgElements, framework.svg);
    path2.setAttributeNS(null, "class", group.className);
    if (group.style !== void 0) {
      path2.setAttributeNS(null, "style", group.style);
    }
    var type = "L";
    if (group.options.interpolation.enabled == true) {
      type = "C";
    }
    path2.setAttributeNS(null, "d", "M" + pathArray[0][0] + "," + pathArray[0][1] + " " + this.serializePath(pathArray, type, false));
  }
};
Line.serializePath = function(pathArray, type, inverse) {
  if (pathArray.length < 2) {
    return "";
  }
  var d = type;
  var i;
  if (inverse) {
    for (i = pathArray.length - 2; i > 0; i--) {
      d += pathArray[i][0] + "," + pathArray[i][1] + " ";
    }
  } else {
    for (i = 1; i < pathArray.length; i++) {
      d += pathArray[i][0] + "," + pathArray[i][1] + " ";
    }
  }
  return d;
};
Line._catmullRomUniform = function(data) {
  var p0, p1, p2, p3, bp1, bp2;
  var d = [];
  d.push([Math.round(data[0].screen_x), Math.round(data[0].screen_y)]);
  var normalization = 1 / 6;
  var length = data.length;
  for (var i = 0; i < length - 1; i++) {
    p0 = i == 0 ? data[0] : data[i - 1];
    p1 = data[i];
    p2 = data[i + 1];
    p3 = i + 2 < length ? data[i + 2] : p2;
    bp1 = {
      screen_x: (-p0.screen_x + 6 * p1.screen_x + p2.screen_x) * normalization,
      screen_y: (-p0.screen_y + 6 * p1.screen_y + p2.screen_y) * normalization
    };
    bp2 = {
      screen_x: (p1.screen_x + 6 * p2.screen_x - p3.screen_x) * normalization,
      screen_y: (p1.screen_y + 6 * p2.screen_y - p3.screen_y) * normalization
    };
    d.push([bp1.screen_x, bp1.screen_y]);
    d.push([bp2.screen_x, bp2.screen_y]);
    d.push([p2.screen_x, p2.screen_y]);
  }
  return d;
};
Line._catmullRom = function(data, group) {
  var alpha = group.options.interpolation.alpha;
  if (alpha == 0 || alpha === void 0) {
    return this._catmullRomUniform(data);
  } else {
    var p0, p1, p2, p3, bp1, bp2, d1, d2, d3, A, B, N, M;
    var d3powA, d2powA, d3pow2A, d2pow2A, d1pow2A, d1powA;
    var d = [];
    d.push([Math.round(data[0].screen_x), Math.round(data[0].screen_y)]);
    var length = data.length;
    for (var i = 0; i < length - 1; i++) {
      p0 = i == 0 ? data[0] : data[i - 1];
      p1 = data[i];
      p2 = data[i + 1];
      p3 = i + 2 < length ? data[i + 2] : p2;
      d1 = Math.sqrt(Math.pow(p0.screen_x - p1.screen_x, 2) + Math.pow(p0.screen_y - p1.screen_y, 2));
      d2 = Math.sqrt(Math.pow(p1.screen_x - p2.screen_x, 2) + Math.pow(p1.screen_y - p2.screen_y, 2));
      d3 = Math.sqrt(Math.pow(p2.screen_x - p3.screen_x, 2) + Math.pow(p2.screen_y - p3.screen_y, 2));
      d3powA = Math.pow(d3, alpha);
      d3pow2A = Math.pow(d3, 2 * alpha);
      d2powA = Math.pow(d2, alpha);
      d2pow2A = Math.pow(d2, 2 * alpha);
      d1powA = Math.pow(d1, alpha);
      d1pow2A = Math.pow(d1, 2 * alpha);
      A = 2 * d1pow2A + 3 * d1powA * d2powA + d2pow2A;
      B = 2 * d3pow2A + 3 * d3powA * d2powA + d2pow2A;
      N = 3 * d1powA * (d1powA + d2powA);
      if (N > 0) {
        N = 1 / N;
      }
      M = 3 * d3powA * (d3powA + d2powA);
      if (M > 0) {
        M = 1 / M;
      }
      bp1 = {
        screen_x: (-d2pow2A * p0.screen_x + A * p1.screen_x + d1pow2A * p2.screen_x) * N,
        screen_y: (-d2pow2A * p0.screen_y + A * p1.screen_y + d1pow2A * p2.screen_y) * N
      };
      bp2 = {
        screen_x: (d3pow2A * p1.screen_x + B * p2.screen_x - d2pow2A * p3.screen_x) * M,
        screen_y: (d3pow2A * p1.screen_y + B * p2.screen_y - d2pow2A * p3.screen_y) * M
      };
      if (bp1.screen_x == 0 && bp1.screen_y == 0) {
        bp1 = p1;
      }
      if (bp2.screen_x == 0 && bp2.screen_y == 0) {
        bp2 = p2;
      }
      d.push([bp1.screen_x, bp1.screen_y]);
      d.push([bp2.screen_x, bp2.screen_y]);
      d.push([p2.screen_x, p2.screen_y]);
    }
    return d;
  }
};
Line._linear = function(data) {
  var d = [];
  for (var i = 0; i < data.length; i++) {
    d.push([data[i].screen_x, data[i].screen_y]);
  }
  return d;
};
function GraphGroup(group, groupId, options, groupsUsingDefaultStyles) {
  this.id = groupId;
  var fields = ["sampling", "style", "sort", "yAxisOrientation", "barChart", "drawPoints", "shaded", "interpolation", "zIndex", "excludeFromStacking", "excludeFromLegend"];
  this.options = availableUtils.selectiveBridgeObject(fields, options);
  this.usingDefaultStyle = group.className === void 0;
  this.groupsUsingDefaultStyles = groupsUsingDefaultStyles;
  this.zeroPosition = 0;
  this.update(group);
  if (this.usingDefaultStyle == true) {
    this.groupsUsingDefaultStyles[0] += 1;
  }
  this.itemsData = [];
  this.visible = group.visible === void 0 ? true : group.visible;
}
GraphGroup.prototype.setItems = function(items) {
  if (items != null) {
    this.itemsData = items;
    if (_sortInstanceProperty(this.options) == true) {
      availableUtils.insertSort(this.itemsData, function(a, b) {
        return a.x > b.x ? 1 : -1;
      });
    }
  } else {
    this.itemsData = [];
  }
};
GraphGroup.prototype.getItems = function() {
  return this.itemsData;
};
GraphGroup.prototype.setZeroPosition = function(pos) {
  this.zeroPosition = pos;
};
GraphGroup.prototype.setOptions = function(options) {
  if (options !== void 0) {
    var fields = ["sampling", "style", "sort", "yAxisOrientation", "barChart", "zIndex", "excludeFromStacking", "excludeFromLegend"];
    availableUtils.selectiveDeepExtend(fields, this.options, options);
    if (typeof options.drawPoints == "function") {
      options.drawPoints = {
        onRender: options.drawPoints
      };
    }
    availableUtils.mergeOptions(this.options, options, "interpolation");
    availableUtils.mergeOptions(this.options, options, "drawPoints");
    availableUtils.mergeOptions(this.options, options, "shaded");
    if (options.interpolation) {
      if (typeof options.interpolation == "object") {
        if (options.interpolation.parametrization) {
          if (options.interpolation.parametrization == "uniform") {
            this.options.interpolation.alpha = 0;
          } else if (options.interpolation.parametrization == "chordal") {
            this.options.interpolation.alpha = 1;
          } else {
            this.options.interpolation.parametrization = "centripetal";
            this.options.interpolation.alpha = 0.5;
          }
        }
      }
    }
  }
};
GraphGroup.prototype.update = function(group) {
  this.group = group;
  this.content = group.content || "graph";
  this.className = group.className || this.className || "vis-graph-group" + this.groupsUsingDefaultStyles[0] % 10;
  this.visible = group.visible === void 0 ? true : group.visible;
  this.style = group.style;
  this.setOptions(group.options);
};
GraphGroup.prototype.getLegend = function(iconWidth, iconHeight, framework, x, y) {
  if (framework == void 0 || framework == null) {
    var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    framework = {
      svg,
      svgElements: {},
      options: this.options,
      groups: [this]
    };
  }
  if (x == void 0 || x == null) {
    x = 0;
  }
  if (y == void 0 || y == null) {
    y = 0.5 * iconHeight;
  }
  switch (this.options.style) {
    case "line":
      Line.drawIcon(this, x, y, iconWidth, iconHeight, framework);
      break;
    case "points":
    //explicit no break
    case "point":
      Points.drawIcon(this, x, y, iconWidth, iconHeight, framework);
      break;
    case "bar":
      Bargraph.drawIcon(this, x, y, iconWidth, iconHeight, framework);
      break;
  }
  return {
    icon: framework.svg,
    label: this.content,
    orientation: this.options.yAxisOrientation
  };
};
GraphGroup.prototype.getYRange = function(groupData) {
  var yMin = groupData[0].y;
  var yMax = groupData[0].y;
  for (var j = 0; j < groupData.length; j++) {
    yMin = yMin > groupData[j].y ? groupData[j].y : yMin;
    yMax = yMax < groupData[j].y ? groupData[j].y : yMax;
  }
  return {
    min: yMin,
    max: yMax,
    yAxisOrientation: this.options.yAxisOrientation
  };
};
function Legend(body, options, side, linegraphOptions) {
  this.body = body;
  this.defaultOptions = {
    enabled: false,
    icons: true,
    iconSize: 20,
    iconSpacing: 6,
    left: {
      visible: true,
      position: "top-left"
      // top/bottom - left,center,right
    },
    right: {
      visible: true,
      position: "top-right"
      // top/bottom - left,center,right
    }
  };
  this.side = side;
  this.options = availableUtils.extend({}, this.defaultOptions);
  this.linegraphOptions = linegraphOptions;
  this.svgElements = {};
  this.dom = {};
  this.groups = {};
  this.amountOfGroups = 0;
  this._create();
  this.framework = {
    svg: this.svg,
    svgElements: this.svgElements,
    options: this.options,
    groups: this.groups
  };
  this.setOptions(options);
}
Legend.prototype = new Component();
Legend.prototype.clear = function() {
  this.groups = {};
  this.amountOfGroups = 0;
};
Legend.prototype.addGroup = function(label, graphOptions) {
  if (graphOptions.options.excludeFromLegend != true) {
    if (!Object.prototype.hasOwnProperty.call(this.groups, label)) {
      this.groups[label] = graphOptions;
    }
    this.amountOfGroups += 1;
  }
};
Legend.prototype.updateGroup = function(label, graphOptions) {
  this.groups[label] = graphOptions;
};
Legend.prototype.removeGroup = function(label) {
  if (Object.prototype.hasOwnProperty.call(this.groups, label)) {
    delete this.groups[label];
    this.amountOfGroups -= 1;
  }
};
Legend.prototype._create = function() {
  this.dom.frame = document.createElement("div");
  this.dom.frame.className = "vis-legend";
  this.dom.frame.style.position = "absolute";
  this.dom.frame.style.top = "10px";
  this.dom.frame.style.display = "block";
  this.dom.textArea = document.createElement("div");
  this.dom.textArea.className = "vis-legend-text";
  this.dom.textArea.style.position = "relative";
  this.dom.textArea.style.top = "0px";
  this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  this.svg.style.position = "absolute";
  this.svg.style.top = "0px";
  this.svg.style.width = this.options.iconSize + 5 + "px";
  this.svg.style.height = "100%";
  this.dom.frame.appendChild(this.svg);
  this.dom.frame.appendChild(this.dom.textArea);
};
Legend.prototype.hide = function() {
  if (this.dom.frame.parentNode) {
    this.dom.frame.parentNode.removeChild(this.dom.frame);
  }
};
Legend.prototype.show = function() {
  if (!this.dom.frame.parentNode) {
    this.body.dom.center.appendChild(this.dom.frame);
  }
};
Legend.prototype.setOptions = function(options) {
  var fields = ["enabled", "orientation", "icons", "left", "right"];
  availableUtils.selectiveDeepExtend(fields, this.options, options);
};
Legend.prototype.redraw = function() {
  var activeGroups = 0;
  var groupArray = _Object$keys(this.groups);
  _sortInstanceProperty(groupArray).call(groupArray, function(a, b) {
    return a < b ? -1 : 1;
  });
  for (var i = 0; i < groupArray.length; i++) {
    var groupId = groupArray[i];
    if (this.groups[groupId].visible == true && (this.linegraphOptions.visibility[groupId] === void 0 || this.linegraphOptions.visibility[groupId] == true)) {
      activeGroups++;
    }
  }
  if (this.options[this.side].visible == false || this.amountOfGroups == 0 || this.options.enabled == false || activeGroups == 0) {
    this.hide();
  } else {
    this.show();
    if (this.options[this.side].position == "top-left" || this.options[this.side].position == "bottom-left") {
      this.dom.frame.style.left = "4px";
      this.dom.frame.style.textAlign = "left";
      this.dom.textArea.style.textAlign = "left";
      this.dom.textArea.style.left = this.options.iconSize + 15 + "px";
      this.dom.textArea.style.right = "";
      this.svg.style.left = "0px";
      this.svg.style.right = "";
    } else {
      this.dom.frame.style.right = "4px";
      this.dom.frame.style.textAlign = "right";
      this.dom.textArea.style.textAlign = "right";
      this.dom.textArea.style.right = this.options.iconSize + 15 + "px";
      this.dom.textArea.style.left = "";
      this.svg.style.right = "0px";
      this.svg.style.left = "";
    }
    if (this.options[this.side].position == "top-left" || this.options[this.side].position == "top-right") {
      this.dom.frame.style.top = 4 - Number(this.body.dom.center.style.top.replace("px", "")) + "px";
      this.dom.frame.style.bottom = "";
    } else {
      var scrollableHeight = this.body.domProps.center.height - this.body.domProps.centerContainer.height;
      this.dom.frame.style.bottom = 4 + scrollableHeight + Number(this.body.dom.center.style.top.replace("px", "")) + "px";
      this.dom.frame.style.top = "";
    }
    if (this.options.icons == false) {
      this.dom.frame.style.width = this.dom.textArea.offsetWidth + 10 + "px";
      this.dom.textArea.style.right = "";
      this.dom.textArea.style.left = "";
      this.svg.style.width = "0px";
    } else {
      this.dom.frame.style.width = this.options.iconSize + 15 + this.dom.textArea.offsetWidth + 10 + "px";
      this.drawLegendIcons();
    }
    var content = "";
    for (i = 0; i < groupArray.length; i++) {
      groupId = groupArray[i];
      if (this.groups[groupId].visible == true && (this.linegraphOptions.visibility[groupId] === void 0 || this.linegraphOptions.visibility[groupId] == true)) {
        content += this.groups[groupId].content + "<br />";
      }
    }
    this.dom.textArea.innerHTML = availableUtils.xss(content);
    this.dom.textArea.style.lineHeight = 0.75 * this.options.iconSize + this.options.iconSpacing + "px";
  }
};
Legend.prototype.drawLegendIcons = function() {
  if (this.dom.frame.parentNode) {
    var groupArray = _Object$keys(this.groups);
    _sortInstanceProperty(groupArray).call(groupArray, function(a, b) {
      return a < b ? -1 : 1;
    });
    resetElements(this.svgElements);
    var padding = window.getComputedStyle(this.dom.frame).paddingTop;
    var iconOffset = Number(padding.replace("px", ""));
    var x = iconOffset;
    var iconWidth = this.options.iconSize;
    var iconHeight = 0.75 * this.options.iconSize;
    var y = iconOffset + 0.5 * iconHeight + 3;
    this.svg.style.width = iconWidth + 5 + iconOffset + "px";
    for (var i = 0; i < groupArray.length; i++) {
      var groupId = groupArray[i];
      if (this.groups[groupId].visible == true && (this.linegraphOptions.visibility[groupId] === void 0 || this.linegraphOptions.visibility[groupId] == true)) {
        this.groups[groupId].getLegend(iconWidth, iconHeight, this.framework, x, y);
        y += iconHeight + this.options.iconSpacing;
      }
    }
  }
};
var UNGROUPED = "__ungrouped__";
function LineGraph(body, options) {
  this.id = v4();
  this.body = body;
  this.defaultOptions = {
    yAxisOrientation: "left",
    defaultGroup: "default",
    sort: true,
    sampling: true,
    stack: false,
    graphHeight: "400px",
    shaded: {
      enabled: false,
      orientation: "bottom"
      // top, bottom, zero
    },
    style: "line",
    // line, bar
    barChart: {
      width: 50,
      sideBySide: false,
      align: "center"
      // left, center, right
    },
    interpolation: {
      enabled: true,
      parametrization: "centripetal",
      // uniform (alpha = 0.0), chordal (alpha = 1.0), centripetal (alpha = 0.5)
      alpha: 0.5
    },
    drawPoints: {
      enabled: true,
      size: 6,
      style: "square"
      // square, circle
    },
    dataAxis: {},
    //Defaults are done on DataAxis level
    legend: {},
    //Defaults are done on Legend level
    groups: {
      visibility: {}
    }
  };
  this.options = availableUtils.extend({}, this.defaultOptions);
  this.dom = {};
  this.props = {};
  this.hammer = null;
  this.groups = {};
  this.abortedGraphUpdate = false;
  this.updateSVGheight = false;
  this.updateSVGheightOnResize = false;
  this.forceGraphUpdate = true;
  var me = this;
  this.itemsData = null;
  this.groupsData = null;
  this.itemListeners = {
    add: function(_event, params) {
      me._onAdd(params.items);
    },
    update: function(_event, params) {
      me._onUpdate(params.items);
    },
    remove: function(_event, params) {
      me._onRemove(params.items);
    }
  };
  this.groupListeners = {
    add: function(_event, params) {
      me._onAddGroups(params.items);
    },
    update: function(_event, params) {
      me._onUpdateGroups(params.items);
    },
    remove: function(_event, params) {
      me._onRemoveGroups(params.items);
    }
  };
  this.items = {};
  this.selection = [];
  this.lastStart = this.body.range.start;
  this.touchParams = {};
  this.svgElements = {};
  this.setOptions(options);
  this.groupsUsingDefaultStyles = [0];
  this.body.emitter.on("rangechanged", function() {
    me.svg.style.left = availableUtils.option.asSize(-me.props.width);
    me.forceGraphUpdate = true;
    me.redraw.call(me);
  });
  this._create();
  this.framework = {
    svg: this.svg,
    svgElements: this.svgElements,
    options: this.options,
    groups: this.groups
  };
}
LineGraph.prototype = new Component();
LineGraph.prototype._create = function() {
  var frame = document.createElement("div");
  frame.className = "vis-line-graph";
  this.dom.frame = frame;
  this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  this.svg.style.position = "relative";
  this.svg.style.height = ("" + this.options.graphHeight).replace("px", "") + "px";
  this.svg.style.display = "block";
  frame.appendChild(this.svg);
  this.options.dataAxis.orientation = "left";
  this.yAxisLeft = new DataAxis(this.body, this.options.dataAxis, this.svg, this.options.groups);
  this.options.dataAxis.orientation = "right";
  this.yAxisRight = new DataAxis(this.body, this.options.dataAxis, this.svg, this.options.groups);
  delete this.options.dataAxis.orientation;
  this.legendLeft = new Legend(this.body, this.options.legend, "left", this.options.groups);
  this.legendRight = new Legend(this.body, this.options.legend, "right", this.options.groups);
  this.show();
};
LineGraph.prototype.setOptions = function(options) {
  if (options) {
    var fields = ["sampling", "defaultGroup", "stack", "height", "graphHeight", "yAxisOrientation", "style", "barChart", "dataAxis", "sort", "groups"];
    if (options.graphHeight === void 0 && options.height !== void 0) {
      this.updateSVGheight = true;
      this.updateSVGheightOnResize = true;
    } else if (this.body.domProps.centerContainer.height !== void 0 && options.graphHeight !== void 0) {
      if (_parseInt((options.graphHeight + "").replace("px", "")) < this.body.domProps.centerContainer.height) {
        this.updateSVGheight = true;
      }
    }
    availableUtils.selectiveDeepExtend(fields, this.options, options);
    availableUtils.mergeOptions(this.options, options, "interpolation");
    availableUtils.mergeOptions(this.options, options, "drawPoints");
    availableUtils.mergeOptions(this.options, options, "shaded");
    availableUtils.mergeOptions(this.options, options, "legend");
    if (options.interpolation) {
      if (typeof options.interpolation == "object") {
        if (options.interpolation.parametrization) {
          if (options.interpolation.parametrization == "uniform") {
            this.options.interpolation.alpha = 0;
          } else if (options.interpolation.parametrization == "chordal") {
            this.options.interpolation.alpha = 1;
          } else {
            this.options.interpolation.parametrization = "centripetal";
            this.options.interpolation.alpha = 0.5;
          }
        }
      }
    }
    if (this.yAxisLeft) {
      if (options.dataAxis !== void 0) {
        this.yAxisLeft.setOptions(this.options.dataAxis);
        this.yAxisRight.setOptions(this.options.dataAxis);
      }
    }
    if (this.legendLeft) {
      if (options.legend !== void 0) {
        this.legendLeft.setOptions(this.options.legend);
        this.legendRight.setOptions(this.options.legend);
      }
    }
    if (Object.prototype.hasOwnProperty.call(this.groups, UNGROUPED)) {
      this.groups[UNGROUPED].setOptions(options);
    }
  }
  if (this.dom.frame) {
    this.forceGraphUpdate = true;
    this.body.emitter.emit("_change", {
      queue: true
    });
  }
};
LineGraph.prototype.hide = function() {
  if (this.dom.frame.parentNode) {
    this.dom.frame.parentNode.removeChild(this.dom.frame);
  }
};
LineGraph.prototype.show = function() {
  if (!this.dom.frame.parentNode) {
    this.body.dom.center.appendChild(this.dom.frame);
  }
};
LineGraph.prototype.setItems = function(items) {
  var me = this, ids, oldItemsData = this.itemsData;
  if (!items) {
    this.itemsData = null;
  } else if (isDataViewLike(items)) {
    this.itemsData = typeCoerceDataSet(items);
  } else {
    throw new TypeError("Data must implement the interface of DataSet or DataView");
  }
  if (oldItemsData) {
    _forEachInstanceProperty(availableUtils).call(availableUtils, this.itemListeners, function(callback, event2) {
      oldItemsData.off(event2, callback);
    });
    oldItemsData.dispose();
    ids = oldItemsData.getIds();
    this._onRemove(ids);
  }
  if (this.itemsData) {
    var id = this.id;
    _forEachInstanceProperty(availableUtils).call(availableUtils, this.itemListeners, function(callback, event2) {
      me.itemsData.on(event2, callback, id);
    });
    ids = this.itemsData.getIds();
    this._onAdd(ids);
  }
};
LineGraph.prototype.setGroups = function(groups) {
  var me = this;
  var ids;
  if (this.groupsData) {
    _forEachInstanceProperty(availableUtils).call(availableUtils, this.groupListeners, function(callback, event2) {
      me.groupsData.off(event2, callback);
    });
    ids = this.groupsData.getIds();
    this.groupsData = null;
    for (var i = 0; i < ids.length; i++) {
      this._removeGroup(ids[i]);
    }
  }
  if (!groups) {
    this.groupsData = null;
  } else if (isDataViewLike(groups)) {
    this.groupsData = groups;
  } else {
    throw new TypeError("Data must implement the interface of DataSet or DataView");
  }
  if (this.groupsData) {
    var id = this.id;
    _forEachInstanceProperty(availableUtils).call(availableUtils, this.groupListeners, function(callback, event2) {
      me.groupsData.on(event2, callback, id);
    });
    ids = this.groupsData.getIds();
    this._onAddGroups(ids);
  }
};
LineGraph.prototype._onUpdate = function(ids) {
  this._updateAllGroupData(ids);
};
LineGraph.prototype._onAdd = function(ids) {
  this._onUpdate(ids);
};
LineGraph.prototype._onRemove = function(ids) {
  this._onUpdate(ids);
};
LineGraph.prototype._onUpdateGroups = function(groupIds) {
  this._updateAllGroupData(null, groupIds);
};
LineGraph.prototype._onAddGroups = function(groupIds) {
  this._onUpdateGroups(groupIds);
};
LineGraph.prototype._onRemoveGroups = function(groupIds) {
  for (var i = 0; i < groupIds.length; i++) {
    this._removeGroup(groupIds[i]);
  }
  this.forceGraphUpdate = true;
  this.body.emitter.emit("_change", {
    queue: true
  });
};
LineGraph.prototype._removeGroup = function(groupId) {
  if (!Object.prototype.hasOwnProperty.call(this.groups, groupId)) return;
  if (this.groups[groupId].options.yAxisOrientation == "right") {
    this.yAxisRight.removeGroup(groupId);
    this.legendRight.removeGroup(groupId);
    this.legendRight.redraw();
  } else {
    this.yAxisLeft.removeGroup(groupId);
    this.legendLeft.removeGroup(groupId);
    this.legendLeft.redraw();
  }
  delete this.groups[groupId];
};
LineGraph.prototype._updateGroup = function(group, groupId) {
  if (!Object.prototype.hasOwnProperty.call(this.groups, groupId)) {
    this.groups[groupId] = new GraphGroup(group, groupId, this.options, this.groupsUsingDefaultStyles);
    if (this.groups[groupId].options.yAxisOrientation == "right") {
      this.yAxisRight.addGroup(groupId, this.groups[groupId]);
      this.legendRight.addGroup(groupId, this.groups[groupId]);
    } else {
      this.yAxisLeft.addGroup(groupId, this.groups[groupId]);
      this.legendLeft.addGroup(groupId, this.groups[groupId]);
    }
  } else {
    this.groups[groupId].update(group);
    if (this.groups[groupId].options.yAxisOrientation == "right") {
      this.yAxisRight.updateGroup(groupId, this.groups[groupId]);
      this.legendRight.updateGroup(groupId, this.groups[groupId]);
      this.yAxisLeft.removeGroup(groupId);
      this.legendLeft.removeGroup(groupId);
    } else {
      this.yAxisLeft.updateGroup(groupId, this.groups[groupId]);
      this.legendLeft.updateGroup(groupId, this.groups[groupId]);
      this.yAxisRight.removeGroup(groupId);
      this.legendRight.removeGroup(groupId);
    }
  }
  this.legendLeft.redraw();
  this.legendRight.redraw();
};
LineGraph.prototype._updateAllGroupData = function(ids, groupIds) {
  if (this.itemsData != null) {
    var groupsContent = {};
    var items = this.itemsData.get();
    var fieldId = this.itemsData.idProp;
    var idMap = {};
    if (ids) {
      _mapInstanceProperty(ids).call(ids, function(id) {
        idMap[id] = id;
      });
    }
    var groupCounts = {};
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      var groupId = item.group;
      if (groupId === null || groupId === void 0) {
        groupId = UNGROUPED;
      }
      Object.prototype.hasOwnProperty.call(groupCounts, groupId) ? groupCounts[groupId]++ : groupCounts[groupId] = 1;
    }
    var existingItemsMap = {};
    if (!groupIds && ids) {
      for (groupId in this.groups) {
        if (!Object.prototype.hasOwnProperty.call(this.groups, groupId)) continue;
        group = this.groups[groupId];
        var existing_items = group.getItems();
        groupsContent[groupId] = _filterInstanceProperty(existing_items).call(existing_items, function(item2) {
          existingItemsMap[item2[fieldId]] = item2[fieldId];
          return item2[fieldId] !== idMap[item2[fieldId]];
        });
        var newLength = groupCounts[groupId];
        groupCounts[groupId] -= groupsContent[groupId].length;
        if (groupsContent[groupId].length < newLength) groupsContent[groupId][newLength - 1] = {};
      }
    }
    for (i = 0; i < items.length; i++) {
      item = items[i];
      groupId = item.group;
      if (groupId === null || groupId === void 0) {
        groupId = UNGROUPED;
      }
      if (!groupIds && ids && item[fieldId] !== idMap[item[fieldId]] && Object.prototype.hasOwnProperty.call(existingItemsMap, item[fieldId])) {
        continue;
      }
      if (!Object.prototype.hasOwnProperty.call(groupsContent, groupId)) {
        groupsContent[groupId] = new Array(groupCounts[groupId]);
      }
      var extended = availableUtils.bridgeObject(item);
      extended.x = availableUtils.convert(item.x, "Date");
      extended.end = availableUtils.convert(item.end, "Date");
      extended.orginalY = item.y;
      extended.y = Number(item.y);
      extended[fieldId] = item[fieldId];
      var index = groupsContent[groupId].length - groupCounts[groupId]--;
      groupsContent[groupId][index] = extended;
    }
    for (groupId in this.groups) {
      if (!Object.prototype.hasOwnProperty.call(this.groups, groupId) || Object.prototype.hasOwnProperty.call(groupsContent, groupId)) continue;
      groupsContent[groupId] = new Array(0);
    }
    for (groupId in groupsContent) {
      if (!Object.prototype.hasOwnProperty.call(groupsContent, groupId)) continue;
      if (groupsContent[groupId].length == 0) {
        if (Object.prototype.hasOwnProperty.call(this.groups, groupId)) {
          this._removeGroup(groupId);
        }
      } else {
        var group = void 0;
        if (this.groupsData != void 0) {
          group = this.groupsData.get(groupId);
        }
        if (group == void 0) {
          group = {
            id: groupId,
            content: this.options.defaultGroup + groupId
          };
        }
        this._updateGroup(group, groupId);
        this.groups[groupId].setItems(groupsContent[groupId]);
      }
    }
    this.forceGraphUpdate = true;
    this.body.emitter.emit("_change", {
      queue: true
    });
  }
};
LineGraph.prototype.redraw = function() {
  var resized = false;
  this.props.width = this.dom.frame.offsetWidth;
  this.props.height = this.body.domProps.centerContainer.height - this.body.domProps.border.top - this.body.domProps.border.bottom;
  resized = this._isResized() || resized;
  var visibleInterval = this.body.range.end - this.body.range.start;
  var zoomed = visibleInterval != this.lastVisibleInterval;
  this.lastVisibleInterval = visibleInterval;
  if (resized == true) {
    var _context;
    this.svg.style.width = availableUtils.option.asSize(3 * this.props.width);
    this.svg.style.left = availableUtils.option.asSize(-this.props.width);
    if (_indexOfInstanceProperty(_context = this.options.height + "").call(_context, "%") != -1 || this.updateSVGheightOnResize == true) {
      this.updateSVGheight = true;
    }
  }
  if (this.updateSVGheight == true) {
    if (this.options.graphHeight != this.props.height + "px") {
      this.options.graphHeight = this.props.height + "px";
      this.svg.style.height = this.props.height + "px";
    }
    this.updateSVGheight = false;
  } else {
    this.svg.style.height = ("" + this.options.graphHeight).replace("px", "") + "px";
  }
  if (resized == true || zoomed == true || this.abortedGraphUpdate == true || this.forceGraphUpdate == true) {
    resized = this._updateGraph() || resized;
    this.forceGraphUpdate = false;
    this.lastStart = this.body.range.start;
    this.svg.style.left = -this.props.width + "px";
  } else {
    if (this.lastStart != 0) {
      var offset = this.body.range.start - this.lastStart;
      var range = this.body.range.end - this.body.range.start;
      if (this.props.width != 0) {
        var rangePerPixelInv = this.props.width / range;
        var xOffset = offset * rangePerPixelInv;
        this.svg.style.left = -this.props.width - xOffset + "px";
      }
    }
  }
  this.legendLeft.redraw();
  this.legendRight.redraw();
  return resized;
};
LineGraph.prototype._getSortedGroupIds = function() {
  var grouplist = [];
  for (var groupId in this.groups) {
    if (Object.prototype.hasOwnProperty.call(this.groups, groupId)) {
      var group = this.groups[groupId];
      if (group.visible == true && (this.options.groups.visibility[groupId] === void 0 || this.options.groups.visibility[groupId] == true)) {
        grouplist.push({
          id: groupId,
          zIndex: group.options.zIndex
        });
      }
    }
  }
  availableUtils.insertSort(grouplist, function(a, b) {
    var az = a.zIndex;
    var bz = b.zIndex;
    if (az === void 0) az = 0;
    if (bz === void 0) bz = 0;
    return az == bz ? 0 : az < bz ? -1 : 1;
  });
  var groupIds = new Array(grouplist.length);
  for (var i = 0; i < grouplist.length; i++) {
    groupIds[i] = grouplist[i].id;
  }
  return groupIds;
};
LineGraph.prototype._updateGraph = function() {
  prepareElements(this.svgElements);
  if (this.props.width != 0 && this.itemsData != null) {
    var group, i;
    var groupRanges = {};
    var changeCalled = false;
    var minDate = this.body.util.toGlobalTime(-this.body.domProps.root.width);
    var maxDate = this.body.util.toGlobalTime(2 * this.body.domProps.root.width);
    var groupIds = this._getSortedGroupIds();
    if (groupIds.length > 0) {
      var groupsData = {};
      this._getRelevantData(groupIds, groupsData, minDate, maxDate);
      this._applySampling(groupIds, groupsData);
      for (i = 0; i < groupIds.length; i++) {
        this._convertXcoordinates(groupsData[groupIds[i]]);
      }
      this._getYRanges(groupIds, groupsData, groupRanges);
      changeCalled = this._updateYAxis(groupIds, groupRanges);
      if (changeCalled == true) {
        cleanupElements(this.svgElements);
        this.abortedGraphUpdate = true;
        return true;
      }
      this.abortedGraphUpdate = false;
      var below = void 0;
      for (i = 0; i < groupIds.length; i++) {
        group = this.groups[groupIds[i]];
        if (this.options.stack === true && this.options.style === "line") {
          if (group.options.excludeFromStacking == void 0 || !group.options.excludeFromStacking) {
            if (below != void 0) {
              this._stack(groupsData[group.id], groupsData[below.id]);
              if (group.options.shaded.enabled == true && group.options.shaded.orientation !== "group") {
                if (group.options.shaded.orientation == "top" && below.options.shaded.orientation !== "group") {
                  below.options.shaded.orientation = "group";
                  below.options.shaded.groupId = group.id;
                } else {
                  group.options.shaded.orientation = "group";
                  group.options.shaded.groupId = below.id;
                }
              }
            }
            below = group;
          }
        }
        this._convertYcoordinates(groupsData[groupIds[i]], group);
      }
      var paths = {};
      for (i = 0; i < groupIds.length; i++) {
        group = this.groups[groupIds[i]];
        if (group.options.style === "line" && group.options.shaded.enabled == true) {
          var dataset = groupsData[groupIds[i]];
          if (dataset == null || dataset.length == 0) {
            continue;
          }
          if (!Object.prototype.hasOwnProperty.call(paths, groupIds[i])) {
            paths[groupIds[i]] = Line.calcPath(dataset, group);
          }
          if (group.options.shaded.orientation === "group") {
            var subGroupId = group.options.shaded.groupId;
            if (_indexOfInstanceProperty(groupIds).call(groupIds, subGroupId) === -1) {
              console.log(group.id + ": Unknown shading group target given:" + subGroupId);
              continue;
            }
            if (!Object.prototype.hasOwnProperty.call(paths, subGroupId)) {
              paths[subGroupId] = Line.calcPath(groupsData[subGroupId], this.groups[subGroupId]);
            }
            Line.drawShading(paths[groupIds[i]], group, paths[subGroupId], this.framework);
          } else {
            Line.drawShading(paths[groupIds[i]], group, void 0, this.framework);
          }
        }
      }
      Bargraph.draw(groupIds, groupsData, this.framework);
      for (i = 0; i < groupIds.length; i++) {
        group = this.groups[groupIds[i]];
        if (groupsData[groupIds[i]].length > 0) {
          switch (group.options.style) {
            case "line":
              if (!Object.prototype.hasOwnProperty.call(paths, groupIds[i])) {
                paths[groupIds[i]] = Line.calcPath(groupsData[groupIds[i]], group);
              }
              Line.draw(paths[groupIds[i]], group, this.framework);
            // eslint-disable-next-line no-fallthrough
            case "point":
            // eslint-disable-next-line no-fallthrough
            case "points":
              if (group.options.style == "point" || group.options.style == "points" || group.options.drawPoints.enabled == true) {
                Points.draw(groupsData[groupIds[i]], group, this.framework);
              }
              break;
          }
        }
      }
    }
  }
  cleanupElements(this.svgElements);
  return false;
};
LineGraph.prototype._stack = function(data, subData) {
  var index, dx, dy, subPrevPoint, subNextPoint;
  index = 0;
  for (var j = 0; j < data.length; j++) {
    subPrevPoint = void 0;
    subNextPoint = void 0;
    for (var k = index; k < subData.length; k++) {
      if (subData[k].x === data[j].x) {
        subPrevPoint = subData[k];
        subNextPoint = subData[k];
        index = k;
        break;
      } else if (subData[k].x > data[j].x) {
        subNextPoint = subData[k];
        if (k == 0) {
          subPrevPoint = subNextPoint;
        } else {
          subPrevPoint = subData[k - 1];
        }
        index = k;
        break;
      }
    }
    if (subNextPoint === void 0) {
      subPrevPoint = subData[subData.length - 1];
      subNextPoint = subData[subData.length - 1];
    }
    dx = subNextPoint.x - subPrevPoint.x;
    dy = subNextPoint.y - subPrevPoint.y;
    if (dx == 0) {
      data[j].y = data[j].orginalY + subNextPoint.y;
    } else {
      data[j].y = data[j].orginalY + dy / dx * (data[j].x - subPrevPoint.x) + subPrevPoint.y;
    }
  }
};
LineGraph.prototype._getRelevantData = function(groupIds, groupsData, minDate, maxDate) {
  var group, i, j, item;
  if (groupIds.length > 0) {
    for (i = 0; i < groupIds.length; i++) {
      group = this.groups[groupIds[i]];
      var itemsData = group.getItems();
      if (_sortInstanceProperty(group.options) == true) {
        var dateComparator = function(a, b) {
          return a.getTime() == b.getTime() ? 0 : a < b ? -1 : 1;
        };
        var first = Math.max(0, availableUtils.binarySearchValue(itemsData, minDate, "x", "before", dateComparator));
        var last = Math.min(itemsData.length, availableUtils.binarySearchValue(itemsData, maxDate, "x", "after", dateComparator) + 1);
        if (last <= 0) {
          last = itemsData.length;
        }
        var dataContainer = new Array(last - first);
        for (j = first; j < last; j++) {
          item = group.itemsData[j];
          dataContainer[j - first] = item;
        }
        groupsData[groupIds[i]] = dataContainer;
      } else {
        groupsData[groupIds[i]] = group.itemsData;
      }
    }
  }
};
LineGraph.prototype._applySampling = function(groupIds, groupsData) {
  var group;
  if (groupIds.length > 0) {
    for (var i = 0; i < groupIds.length; i++) {
      group = this.groups[groupIds[i]];
      if (group.options.sampling == true) {
        var dataContainer = groupsData[groupIds[i]];
        if (dataContainer.length > 0) {
          var increment = 1;
          var amountOfPoints = dataContainer.length;
          var xDistance = this.body.util.toGlobalScreen(dataContainer[dataContainer.length - 1].x) - this.body.util.toGlobalScreen(dataContainer[0].x);
          var pointsPerPixel = amountOfPoints / xDistance;
          increment = Math.min(Math.ceil(0.2 * amountOfPoints), Math.max(1, Math.round(pointsPerPixel)));
          var sampledData = new Array(amountOfPoints);
          for (var j = 0; j < amountOfPoints; j += increment) {
            var idx = Math.round(j / increment);
            sampledData[idx] = dataContainer[j];
          }
          groupsData[groupIds[i]] = _spliceInstanceProperty(sampledData).call(sampledData, 0, Math.round(amountOfPoints / increment));
        }
      }
    }
  }
};
LineGraph.prototype._getYRanges = function(groupIds, groupsData, groupRanges) {
  var groupData, group, i;
  var combinedDataLeft = [];
  var combinedDataRight = [];
  var options;
  if (groupIds.length > 0) {
    for (i = 0; i < groupIds.length; i++) {
      groupData = groupsData[groupIds[i]];
      options = this.groups[groupIds[i]].options;
      if (groupData.length > 0) {
        group = this.groups[groupIds[i]];
        if (options.stack === true && options.style === "bar") {
          if (options.yAxisOrientation === "left") {
            combinedDataLeft = _concatInstanceProperty(combinedDataLeft).call(combinedDataLeft, groupData);
          } else {
            combinedDataRight = _concatInstanceProperty(combinedDataRight).call(combinedDataRight, groupData);
          }
        } else {
          groupRanges[groupIds[i]] = group.getYRange(groupData, groupIds[i]);
        }
      }
    }
    Bargraph.getStackedYRange(combinedDataLeft, groupRanges, groupIds, "__barStackLeft", "left");
    Bargraph.getStackedYRange(combinedDataRight, groupRanges, groupIds, "__barStackRight", "right");
  }
};
LineGraph.prototype._updateYAxis = function(groupIds, groupRanges) {
  var resized = false;
  var yAxisLeftUsed = false;
  var yAxisRightUsed = false;
  var minLeft = 1e9, minRight = 1e9, maxLeft = -1e9, maxRight = -1e9, minVal, maxVal;
  if (groupIds.length > 0) {
    for (var i = 0; i < groupIds.length; i++) {
      var group = this.groups[groupIds[i]];
      if (group && group.options.yAxisOrientation != "right") {
        yAxisLeftUsed = true;
        minLeft = 1e9;
        maxLeft = -1e9;
      } else if (group && group.options.yAxisOrientation) {
        yAxisRightUsed = true;
        minRight = 1e9;
        maxRight = -1e9;
      }
    }
    for (i = 0; i < groupIds.length; i++) {
      if (!Object.prototype.hasOwnProperty.call(groupRanges, groupIds[i]) || groupRanges[groupIds[i]].ignore === true) continue;
      minVal = groupRanges[groupIds[i]].min;
      maxVal = groupRanges[groupIds[i]].max;
      if (groupRanges[groupIds[i]].yAxisOrientation != "right") {
        yAxisLeftUsed = true;
        minLeft = minLeft > minVal ? minVal : minLeft;
        maxLeft = maxLeft < maxVal ? maxVal : maxLeft;
      } else {
        yAxisRightUsed = true;
        minRight = minRight > minVal ? minVal : minRight;
        maxRight = maxRight < maxVal ? maxVal : maxRight;
      }
    }
    if (yAxisLeftUsed == true) {
      this.yAxisLeft.setRange(minLeft, maxLeft);
    }
    if (yAxisRightUsed == true) {
      this.yAxisRight.setRange(minRight, maxRight);
    }
  }
  resized = this._toggleAxisVisiblity(yAxisLeftUsed, this.yAxisLeft) || resized;
  resized = this._toggleAxisVisiblity(yAxisRightUsed, this.yAxisRight) || resized;
  if (yAxisRightUsed == true && yAxisLeftUsed == true) {
    this.yAxisLeft.drawIcons = true;
    this.yAxisRight.drawIcons = true;
  } else {
    this.yAxisLeft.drawIcons = false;
    this.yAxisRight.drawIcons = false;
  }
  this.yAxisRight.master = !yAxisLeftUsed;
  this.yAxisRight.masterAxis = this.yAxisLeft;
  if (this.yAxisRight.master == false) {
    if (yAxisRightUsed == true) {
      this.yAxisLeft.lineOffset = this.yAxisRight.width;
    } else {
      this.yAxisLeft.lineOffset = 0;
    }
    resized = this.yAxisLeft.redraw() || resized;
    resized = this.yAxisRight.redraw() || resized;
  } else {
    resized = this.yAxisRight.redraw() || resized;
  }
  var tempGroups = ["__barStackLeft", "__barStackRight", "__lineStackLeft", "__lineStackRight"];
  for (i = 0; i < tempGroups.length; i++) {
    if (_indexOfInstanceProperty(groupIds).call(groupIds, tempGroups[i]) != -1) {
      _spliceInstanceProperty(groupIds).call(groupIds, _indexOfInstanceProperty(groupIds).call(groupIds, tempGroups[i]), 1);
    }
  }
  return resized;
};
LineGraph.prototype._toggleAxisVisiblity = function(axisUsed, axis) {
  var changed = false;
  if (axisUsed == false) {
    if (axis.dom.frame.parentNode && axis.hidden == false) {
      axis.hide();
      changed = true;
    }
  } else {
    if (!axis.dom.frame.parentNode && axis.hidden == true) {
      axis.show();
      changed = true;
    }
  }
  return changed;
};
LineGraph.prototype._convertXcoordinates = function(datapoints) {
  var toScreen2 = this.body.util.toScreen;
  for (var i = 0; i < datapoints.length; i++) {
    datapoints[i].screen_x = toScreen2(datapoints[i].x) + this.props.width;
    datapoints[i].screen_y = datapoints[i].y;
    if (datapoints[i].end != void 0) {
      datapoints[i].screen_end = toScreen2(datapoints[i].end) + this.props.width;
    } else {
      datapoints[i].screen_end = void 0;
    }
  }
};
LineGraph.prototype._convertYcoordinates = function(datapoints, group) {
  var axis = this.yAxisLeft;
  var svgHeight = Number(this.svg.style.height.replace("px", ""));
  if (group.options.yAxisOrientation == "right") {
    axis = this.yAxisRight;
  }
  for (var i = 0; i < datapoints.length; i++) {
    datapoints[i].screen_y = Math.round(axis.convertValue(datapoints[i].y));
  }
  group.setZeroPosition(Math.min(svgHeight, axis.convertValue(0)));
};
var string = "string";
var bool = "boolean";
var number = "number";
var array = "array";
var date = "date";
var object = "object";
var dom = "dom";
var moment = "moment";
var any = "any";
var allOptions = {
  configure: {
    enabled: {
      boolean: bool
    },
    filter: {
      boolean: bool,
      function: "function"
    },
    container: {
      dom
    },
    __type__: {
      object,
      boolean: bool,
      function: "function"
    }
  },
  //globals :
  alignCurrentTime: {
    string,
    undefined: "undefined"
  },
  yAxisOrientation: {
    string: ["left", "right"]
  },
  defaultGroup: {
    string
  },
  sort: {
    boolean: bool
  },
  sampling: {
    boolean: bool
  },
  stack: {
    boolean: bool
  },
  graphHeight: {
    string,
    number
  },
  shaded: {
    enabled: {
      boolean: bool
    },
    orientation: {
      string: ["bottom", "top", "zero", "group"]
    },
    // top, bottom, zero, group
    groupId: {
      object
    },
    __type__: {
      boolean: bool,
      object
    }
  },
  style: {
    string: ["line", "bar", "points"]
  },
  // line, bar
  barChart: {
    width: {
      number
    },
    minWidth: {
      number
    },
    sideBySide: {
      boolean: bool
    },
    align: {
      string: ["left", "center", "right"]
    },
    __type__: {
      object
    }
  },
  interpolation: {
    enabled: {
      boolean: bool
    },
    parametrization: {
      string: ["centripetal", "chordal", "uniform"]
    },
    // uniform (alpha = 0.0), chordal (alpha = 1.0), centripetal (alpha = 0.5)
    alpha: {
      number
    },
    __type__: {
      object,
      boolean: bool
    }
  },
  drawPoints: {
    enabled: {
      boolean: bool
    },
    onRender: {
      function: "function"
    },
    size: {
      number
    },
    style: {
      string: ["square", "circle"]
    },
    // square, circle
    __type__: {
      object,
      boolean: bool,
      function: "function"
    }
  },
  dataAxis: {
    showMinorLabels: {
      boolean: bool
    },
    showMajorLabels: {
      boolean: bool
    },
    showWeekScale: {
      boolean: bool
    },
    icons: {
      boolean: bool
    },
    width: {
      string,
      number
    },
    visible: {
      boolean: bool
    },
    alignZeros: {
      boolean: bool
    },
    left: {
      range: {
        min: {
          number,
          undefined: "undefined"
        },
        max: {
          number,
          undefined: "undefined"
        },
        __type__: {
          object
        }
      },
      format: {
        function: "function"
      },
      title: {
        text: {
          string,
          number,
          undefined: "undefined"
        },
        style: {
          string,
          undefined: "undefined"
        },
        __type__: {
          object
        }
      },
      __type__: {
        object
      }
    },
    right: {
      range: {
        min: {
          number,
          undefined: "undefined"
        },
        max: {
          number,
          undefined: "undefined"
        },
        __type__: {
          object
        }
      },
      format: {
        function: "function"
      },
      title: {
        text: {
          string,
          number,
          undefined: "undefined"
        },
        style: {
          string,
          undefined: "undefined"
        },
        __type__: {
          object
        }
      },
      __type__: {
        object
      }
    },
    __type__: {
      object
    }
  },
  legend: {
    enabled: {
      boolean: bool
    },
    icons: {
      boolean: bool
    },
    left: {
      visible: {
        boolean: bool
      },
      position: {
        string: ["top-right", "bottom-right", "top-left", "bottom-left"]
      },
      __type__: {
        object
      }
    },
    right: {
      visible: {
        boolean: bool
      },
      position: {
        string: ["top-right", "bottom-right", "top-left", "bottom-left"]
      },
      __type__: {
        object
      }
    },
    __type__: {
      object,
      boolean: bool
    }
  },
  groups: {
    visibility: {
      any
    },
    __type__: {
      object
    }
  },
  autoResize: {
    boolean: bool
  },
  throttleRedraw: {
    number
  },
  // TODO: DEPRICATED see https://github.com/almende/vis/issues/2511
  clickToUse: {
    boolean: bool
  },
  end: {
    number,
    date,
    string,
    moment
  },
  format: {
    minorLabels: {
      millisecond: {
        string,
        undefined: "undefined"
      },
      second: {
        string,
        undefined: "undefined"
      },
      minute: {
        string,
        undefined: "undefined"
      },
      hour: {
        string,
        undefined: "undefined"
      },
      weekday: {
        string,
        undefined: "undefined"
      },
      day: {
        string,
        undefined: "undefined"
      },
      week: {
        string,
        undefined: "undefined"
      },
      month: {
        string,
        undefined: "undefined"
      },
      quarter: {
        string,
        undefined: "undefined"
      },
      year: {
        string,
        undefined: "undefined"
      },
      __type__: {
        object
      }
    },
    majorLabels: {
      millisecond: {
        string,
        undefined: "undefined"
      },
      second: {
        string,
        undefined: "undefined"
      },
      minute: {
        string,
        undefined: "undefined"
      },
      hour: {
        string,
        undefined: "undefined"
      },
      weekday: {
        string,
        undefined: "undefined"
      },
      day: {
        string,
        undefined: "undefined"
      },
      week: {
        string,
        undefined: "undefined"
      },
      month: {
        string,
        undefined: "undefined"
      },
      quarter: {
        string,
        undefined: "undefined"
      },
      year: {
        string,
        undefined: "undefined"
      },
      __type__: {
        object
      }
    },
    __type__: {
      object
    }
  },
  moment: {
    function: "function"
  },
  height: {
    string,
    number
  },
  hiddenDates: {
    start: {
      date,
      number,
      string,
      moment
    },
    end: {
      date,
      number,
      string,
      moment
    },
    repeat: {
      string
    },
    __type__: {
      object,
      array
    }
  },
  locale: {
    string
  },
  locales: {
    __any__: {
      any
    },
    __type__: {
      object
    }
  },
  max: {
    date,
    number,
    string,
    moment
  },
  maxHeight: {
    number,
    string
  },
  maxMinorChars: {
    number
  },
  min: {
    date,
    number,
    string,
    moment
  },
  minHeight: {
    number,
    string
  },
  moveable: {
    boolean: bool
  },
  multiselect: {
    boolean: bool
  },
  orientation: {
    string
  },
  showCurrentTime: {
    boolean: bool
  },
  showMajorLabels: {
    boolean: bool
  },
  showMinorLabels: {
    boolean: bool
  },
  showWeekScale: {
    boolean: bool
  },
  snap: {
    function: "function",
    null: "null"
  },
  start: {
    date,
    number,
    string,
    moment
  },
  timeAxis: {
    scale: {
      string,
      undefined: "undefined"
    },
    step: {
      number,
      undefined: "undefined"
    },
    __type__: {
      object
    }
  },
  width: {
    string,
    number
  },
  zoomable: {
    boolean: bool
  },
  zoomKey: {
    string: ["ctrlKey", "altKey", "metaKey", ""]
  },
  zoomMax: {
    number
  },
  zoomMin: {
    number
  },
  zIndex: {
    number
  },
  __type__: {
    object
  }
};
var configureOptions = {
  global: {
    alignCurrentTime: ["none", "year", "month", "quarter", "week", "isoWeek", "day", "date", "hour", "minute", "second"],
    //yAxisOrientation: ['left','right'], // TDOO: enable as soon as Grahp2d doesn't crash when changing this on the fly
    sort: true,
    sampling: true,
    stack: false,
    shaded: {
      enabled: false,
      orientation: ["zero", "top", "bottom", "group"]
      // zero, top, bottom
    },
    style: ["line", "bar", "points"],
    // line, bar
    barChart: {
      width: [50, 5, 100, 5],
      minWidth: [50, 5, 100, 5],
      sideBySide: false,
      align: ["left", "center", "right"]
      // left, center, right
    },
    interpolation: {
      enabled: true,
      parametrization: ["centripetal", "chordal", "uniform"]
      // uniform (alpha = 0.0), chordal (alpha = 1.0), centripetal (alpha = 0.5)
    },
    drawPoints: {
      enabled: true,
      size: [6, 2, 30, 1],
      style: ["square", "circle"]
      // square, circle
    },
    dataAxis: {
      showMinorLabels: true,
      showMajorLabels: true,
      showWeekScale: false,
      icons: false,
      width: [40, 0, 200, 1],
      visible: true,
      alignZeros: true,
      left: {
        //range: {min:'undefined': 'undefined'ined,max:'undefined': 'undefined'ined},
        //format: function (value) {return value;},
        title: {
          text: "",
          style: ""
        }
      },
      right: {
        //range: {min:'undefined': 'undefined'ined,max:'undefined': 'undefined'ined},
        //format: function (value) {return value;},
        title: {
          text: "",
          style: ""
        }
      }
    },
    legend: {
      enabled: false,
      icons: true,
      left: {
        visible: true,
        position: ["top-right", "bottom-right", "top-left", "bottom-left"]
        // top/bottom - left,right
      },
      right: {
        visible: true,
        position: ["top-right", "bottom-right", "top-left", "bottom-left"]
        // top/bottom - left,right
      }
    },
    autoResize: true,
    clickToUse: false,
    end: "",
    format: {
      minorLabels: {
        millisecond: "SSS",
        second: "s",
        minute: "HH:mm",
        hour: "HH:mm",
        weekday: "ddd D",
        day: "D",
        week: "w",
        month: "MMM",
        quarter: "[Q]Q",
        year: "YYYY"
      },
      majorLabels: {
        millisecond: "HH:mm:ss",
        second: "D MMMM HH:mm",
        minute: "ddd D MMMM",
        hour: "ddd D MMMM",
        weekday: "MMMM YYYY",
        day: "MMMM YYYY",
        week: "MMMM YYYY",
        month: "YYYY",
        quarter: "YYYY",
        year: ""
      }
    },
    height: "",
    locale: "",
    max: "",
    maxHeight: "",
    maxMinorChars: [7, 0, 20, 1],
    min: "",
    minHeight: "",
    moveable: true,
    orientation: ["both", "bottom", "top"],
    showCurrentTime: false,
    showMajorLabels: true,
    showMinorLabels: true,
    showWeekScale: false,
    start: "",
    width: "100%",
    zoomable: true,
    zoomKey: ["ctrlKey", "altKey", "metaKey", ""],
    zoomMax: [31536e10, 10, 31536e10, 1],
    zoomMin: [10, 10, 31536e10, 1],
    zIndex: 0
  }
};
function Graph2d(container, items, groups, options) {
  var _context, _context2, _context3, _context4, _context5, _context6, _context7;
  if (!(_Array$isArray(groups) || isDataViewLike(groups)) && groups instanceof Object) {
    var forthArgument = options;
    options = groups;
    groups = forthArgument;
  }
  if (options && options.throttleRedraw) {
    console.warn('Graph2d option "throttleRedraw" is DEPRICATED and no longer supported. It will be removed in the next MAJOR release.');
  }
  var me = this;
  this.defaultOptions = {
    start: null,
    end: null,
    autoResize: true,
    orientation: {
      axis: "bottom",
      // axis orientation: 'bottom', 'top', or 'both'
      item: "bottom"
      // not relevant for Graph2d
    },
    moment: moment$2,
    width: null,
    height: null,
    maxHeight: null,
    minHeight: null
  };
  this.options = availableUtils.deepExtend({}, this.defaultOptions);
  this._create(container);
  this.components = [];
  this.body = {
    dom: this.dom,
    domProps: this.props,
    emitter: {
      on: _bindInstanceProperty(_context = this.on).call(_context, this),
      off: _bindInstanceProperty(_context2 = this.off).call(_context2, this),
      emit: _bindInstanceProperty(_context3 = this.emit).call(_context3, this)
    },
    hiddenDates: [],
    util: {
      getScale() {
        return me.timeAxis.step.scale;
      },
      getStep() {
        return me.timeAxis.step.step;
      },
      toScreen: _bindInstanceProperty(_context4 = me._toScreen).call(_context4, me),
      toGlobalScreen: _bindInstanceProperty(_context5 = me._toGlobalScreen).call(_context5, me),
      // this refers to the root.width
      toTime: _bindInstanceProperty(_context6 = me._toTime).call(_context6, me),
      toGlobalTime: _bindInstanceProperty(_context7 = me._toGlobalTime).call(_context7, me)
    }
  };
  this.range = new Range(this.body);
  this.components.push(this.range);
  this.body.range = this.range;
  this.timeAxis = new TimeAxis(this.body);
  this.components.push(this.timeAxis);
  this.currentTime = new CurrentTime(this.body);
  this.components.push(this.currentTime);
  this.linegraph = new LineGraph(this.body);
  this.components.push(this.linegraph);
  this.itemsData = null;
  this.groupsData = null;
  this.on("tap", function(event2) {
    me.emit("click", me.getEventProperties(event2));
  });
  this.on("doubletap", function(event2) {
    me.emit("doubleClick", me.getEventProperties(event2));
  });
  this.dom.root.oncontextmenu = function(event2) {
    me.emit("contextmenu", me.getEventProperties(event2));
  };
  this.initialFitDone = false;
  this.on("changed", function() {
    if (me.itemsData == null) return;
    if (!me.initialFitDone && !me.options.rollingMode) {
      me.initialFitDone = true;
      if (me.options.start != void 0 || me.options.end != void 0) {
        if (me.options.start == void 0 || me.options.end == void 0) {
          var range = me.getItemRange();
        }
        var start = me.options.start != void 0 ? me.options.start : range.min;
        var end = me.options.end != void 0 ? me.options.end : range.max;
        me.setWindow(start, end, {
          animation: false
        });
      } else {
        me.fit({
          animation: false
        });
      }
    }
    if (!me.initialDrawDone && (me.initialRangeChangeDone || !me.options.start && !me.options.end || me.options.rollingMode)) {
      me.initialDrawDone = true;
      me.dom.root.style.visibility = "visible";
      me.dom.loadingScreen.parentNode.removeChild(me.dom.loadingScreen);
      if (me.options.onInitialDrawComplete) {
        _setTimeout(() => {
          return me.options.onInitialDrawComplete();
        }, 0);
      }
    }
  });
  if (options) {
    this.setOptions(options);
  }
  if (groups) {
    this.setGroups(groups);
  }
  if (items) {
    this.setItems(items);
  }
  this._redraw();
}
Graph2d.prototype = new Core();
Graph2d.prototype.setOptions = function(options) {
  let errorFound2 = Validator2.validate(options, allOptions);
  if (errorFound2 === true) {
    console.log("%cErrors have been found in the supplied options object.", printStyle);
  }
  Core.prototype.setOptions.call(this, options);
};
Graph2d.prototype.setItems = function(items) {
  var initialLoad = this.itemsData == null;
  var newDataSet;
  if (!items) {
    newDataSet = null;
  } else if (isDataViewLike(items)) {
    newDataSet = typeCoerceDataSet(items);
  } else {
    newDataSet = typeCoerceDataSet(new DataSet(items));
  }
  if (this.itemsData) {
    this.itemsData.dispose();
  }
  this.itemsData = newDataSet;
  this.linegraph && this.linegraph.setItems(newDataSet != null ? newDataSet.rawDS : null);
  if (initialLoad) {
    if (this.options.start != void 0 || this.options.end != void 0) {
      var start = this.options.start != void 0 ? this.options.start : null;
      var end = this.options.end != void 0 ? this.options.end : null;
      this.setWindow(start, end, {
        animation: false
      });
    } else {
      this.fit({
        animation: false
      });
    }
  }
};
Graph2d.prototype.setGroups = function(groups) {
  var newDataSet;
  if (!groups) {
    newDataSet = null;
  } else if (isDataViewLike(groups)) {
    newDataSet = groups;
  } else {
    newDataSet = new DataSet(groups);
  }
  this.groupsData = newDataSet;
  this.linegraph.setGroups(newDataSet);
};
Graph2d.prototype.getLegend = function(groupId, width, height) {
  if (width === void 0) {
    width = 15;
  }
  if (height === void 0) {
    height = 15;
  }
  if (this.linegraph.groups[groupId] !== void 0) {
    return this.linegraph.groups[groupId].getLegend(width, height);
  } else {
    return "cannot find group:'" + groupId + "'";
  }
};
Graph2d.prototype.isGroupVisible = function(groupId) {
  if (this.linegraph.groups[groupId] !== void 0) {
    return this.linegraph.groups[groupId].visible && (this.linegraph.options.groups.visibility[groupId] === void 0 || this.linegraph.options.groups.visibility[groupId] == true);
  } else {
    return false;
  }
};
Graph2d.prototype.getDataRange = function() {
  var min = null;
  var max = null;
  for (var groupId in this.linegraph.groups) {
    if (!Object.prototype.hasOwnProperty.call(this.linegraph.groups, groupId) || this.linegraph.groups[groupId].visible !== true) continue;
    for (var i = 0; i < this.linegraph.groups[groupId].itemsData.length; i++) {
      var item = this.linegraph.groups[groupId].itemsData[i];
      var value = availableUtils.convert(item.x, "Date").valueOf();
      min = min == null ? value : min > value ? value : min;
      max = max == null ? value : max < value ? value : max;
    }
  }
  return {
    min: min != null ? new Date(min) : null,
    max: max != null ? new Date(max) : null
  };
};
Graph2d.prototype.getEventProperties = function(event2) {
  var clientX = event2.center ? event2.center.x : event2.clientX;
  var clientY = event2.center ? event2.center.y : event2.clientY;
  var x = clientX - availableUtils.getAbsoluteLeft(this.dom.centerContainer);
  var y = clientY - availableUtils.getAbsoluteTop(this.dom.centerContainer);
  var time = this._toTime(x);
  var customTime = CustomTime.customTimeFromTarget(event2);
  var element = availableUtils.getTarget(event2);
  var what = null;
  if (availableUtils.hasParent(element, this.timeAxis.dom.foreground)) {
    what = "axis";
  } else if (this.timeAxis2 && availableUtils.hasParent(element, this.timeAxis2.dom.foreground)) {
    what = "axis";
  } else if (availableUtils.hasParent(element, this.linegraph.yAxisLeft.dom.frame)) {
    what = "data-axis";
  } else if (availableUtils.hasParent(element, this.linegraph.yAxisRight.dom.frame)) {
    what = "data-axis";
  } else if (availableUtils.hasParent(element, this.linegraph.legendLeft.dom.frame)) {
    what = "legend";
  } else if (availableUtils.hasParent(element, this.linegraph.legendRight.dom.frame)) {
    what = "legend";
  } else if (customTime != null) {
    what = "custom-time";
  } else if (availableUtils.hasParent(element, this.currentTime.bar)) {
    what = "current-time";
  } else if (availableUtils.hasParent(element, this.dom.center)) {
    what = "background";
  }
  var value = [];
  var yAxisLeft = this.linegraph.yAxisLeft;
  var yAxisRight = this.linegraph.yAxisRight;
  if (!yAxisLeft.hidden && this.itemsData.length > 0) {
    value.push(yAxisLeft.screenToValue(y));
  }
  if (!yAxisRight.hidden && this.itemsData.length > 0) {
    value.push(yAxisRight.screenToValue(y));
  }
  return {
    event: event2,
    customTime: customTime ? customTime.options.id : null,
    what,
    pageX: event2.srcEvent ? event2.srcEvent.pageX : event2.pageX,
    pageY: event2.srcEvent ? event2.srcEvent.pageY : event2.pageY,
    x,
    y,
    time,
    value
  };
};
Graph2d.prototype._createConfigurator = function() {
  return new Configurator2(this, this.dom.container, configureOptions);
};
var defaultLanguage = getNavigatorLanguage();
moment$2.locale(defaultLanguage);
var timeline = {
  Core,
  DateUtil,
  Range,
  stack: stack$1,
  TimeStep,
  components: {
    items: {
      Item,
      BackgroundItem,
      BoxItem,
      ClusterItem,
      PointItem,
      RangeItem
    },
    BackgroundGroup,
    Component,
    CurrentTime,
    CustomTime,
    DataAxis,
    DataScale,
    GraphGroup,
    Group,
    ItemSet,
    Legend,
    LineGraph,
    TimeAxis
  }
};
export {
  DOMutil,
  DataSet,
  DataView,
  Graph2d,
  Hammer,
  Queue,
  Timeline,
  keycharm,
  moment$2 as moment,
  timeline,
  util$2 as util
};
//# sourceMappingURL=vis-timeline_standalone.js.map
